<!DOCTYPE html>
<html lang="en" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>NOC Operations Config Suite</title>
    <meta name="theme-color" content="#ff7a00">
    <meta http-equiv="Cache-Control" content="no-store, no-cache, must-revalidate, max-age=0">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <link rel="icon" href="/assets/favicon.svg" type="image/svg+xml">
    <link rel="manifest" href="/assets/site.webmanifest">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>

    <!-- Security: Prevent Source Code Access -->
    <!-- Security Script Removed for Debugging -->

    <style>
        :root {
            --bg-color: #f4f4f4;
            --text-color: #333;
            --container-bg: white;
            --border-color: #ddd;
            --input-bg: white;
            --button-bg: #d35400;
            --button-hover: #e67e22;
            --output-bg: #f8f8f8;
            --sidebar-bg: #2c3e50;
            --sidebar-active: #e67e22;
            --sidebar-hover: #34495e;
        }

        :root[data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #eee;
            --container-bg: #2a2a2a;
            --border-color: #444;
            --input-bg: #3a3a3a;
            --button-bg: #e67e22;
            --button-hover: #d35400;
            --output-bg: #333;
            --sidebar-bg: #1a1a1a;
            --sidebar-active: #e67e22;
            --sidebar-hover: #2a2a2a;
        }

        :root[data-theme="slate"] {
            --bg-color: #0b1220;
            --text-color: #e5e7eb;
            --text-color-secondary: #aab3c5;
            --container-bg: #111827;
            --border-color: #26324d;
            --input-bg: #0f1b34;
            --button-bg: #ff7a00;
            --button-hover: #e86f00;
            --output-bg: #0f172a;
            --sidebar-bg: #0b1220;
            --sidebar-active: #ff7a00;
            --sidebar-hover: #131c31;
        }

        :root[data-theme="graphite"] {
            --bg-color: #0f0f10;
            --text-color: #f0f0f0;
            --text-color-secondary: #b0b0b0;
            --container-bg: #1b1b1d;
            --border-color: #3a3a3f;
            --input-bg: #242428;
            --button-bg: #ff7a00;
            --button-hover: #e86f00;
            --output-bg: #151517;
            --sidebar-bg: #0f0f10;
            --sidebar-active: #ff7a00;
            --sidebar-hover: #1b1b1d;
        }

        :root[data-theme="neon-holo"] {
            --bg-color: #070816;
            --text-color: #eef0ff;
            --text-color-secondary: #b7baf1;
            --container-bg: #141636;
            --border-color: #3f3aa3;
            --input-bg: #1b1d45;
            --button-bg: #7b61ff;
            --button-hover: #5f45ff;
            --output-bg: #10122d;
            --sidebar-bg: #070816;
            --sidebar-active: #7b61ff;
            --sidebar-hover: #13153a;
        }

        :root[data-theme="neon-aero"] {
            --bg-color: #0a0d14;
            --text-color: #eaf6ff;
            --text-color-secondary: #a6c6da;
            --container-bg: #0f1622;
            --border-color: #1d3a4a;
            --input-bg: #152133;
            --button-bg: #00d2ff;
            --button-hover: #00b7de;
            --output-bg: #0d131d;
            --sidebar-bg: #0a0d14;
            --sidebar-active: #00d2ff;
            --sidebar-hover: #0f1f2b;
        }

        :root[data-theme="nx-ember"] {
            --bg-color: #140f0b;
            --text-color: #f3f0ee;
            --text-color-secondary: #c9bfb7;
            --container-bg: #1f1711;
            --border-color: #3a2a1f;
            --input-bg: #261c14;
            --button-bg: #ff7a00;
            --button-hover: #e86f00;
            --output-bg: #19120d;
            --sidebar-bg: #140f0b;
            --sidebar-active: #ff7a00;
            --sidebar-hover: #1f1711;
        }

        :root[data-theme="ocean"] {
            --bg-color: #07141a;
            --text-color: #e6fbff;
            --text-color-secondary: #a5c7d0;
            --container-bg: #0c1f28;
            --border-color: #21404b;
            --input-bg: #0f2732;
            --button-bg: #22c55e;
            --button-hover: #16a34a;
            --output-bg: #08161c;
            --sidebar-bg: #07141a;
            --sidebar-active: #22c55e;
            --sidebar-hover: #0c1f28;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html,
        body {
            font-family: Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            transition: all 0.3s ease;
            overflow-x: hidden;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }

        /* Header Navigation */
        .top-header {
            background: var(--sidebar-bg);
            color: white;
            padding: 0;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            position: sticky;
            top: 0;
            z-index: 1000;
            display: flex;
            align-items: center;
            justify-content: space-between;
            height: 35px;
        }

        .header-logo {
            padding: 0 12px;
            font-size: 13px;
            font-weight: bold;
            color: var(--sidebar-active);
            border-right: 1px solid rgba(255, 255, 255, 0.1);
            height: 100%;
            display: flex;
            align-items: center;
            gap: 6px;
            min-width: 180px;
        }

        .header-logo .subtitle {
            font-size: 8px;
            color: #bbb;
            font-weight: normal;
            display: block;
        }

        .main-nav {
            display: flex;
            align-items: center;
            gap: 2px;
            flex: 1;
            padding: 0 8px;
        }

        .nav-item {
            position: relative;
            padding: 6px 12px;
            background: transparent;
            border: none;
            color: white;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.2px;
            white-space: nowrap;
        }

        .nav-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-item.active {
            background: var(--sidebar-active);
            color: white;
        }

        .nav-item.dropdown {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .nav-item.dropdown>button {
            padding: 6px 12px;
            background: transparent;
            border: none;
            color: white;
            font-size: 10px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            text-transform: uppercase;
            letter-spacing: 0.2px;
            white-space: nowrap;
        }

        .nav-item.dropdown>button:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .nav-item.dropdown:not(.active)>button {
            background: transparent;
        }

        .dropdown-menu {
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--container-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
            min-width: 280px;
            padding: 6px 0;
            display: none;
            z-index: 1001;
            margin-top: 2px;
        }

        .nav-item.dropdown:hover .dropdown-menu,
        .dropdown-menu:hover {
            display: block;
        }

        .dropdown-menu a {
            display: block;
            padding: 10px 18px;
            color: var(--text-color);
            text-decoration: none;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s ease;
            border-left: 3px solid transparent;
        }

        .dropdown-menu a:hover {
            background: var(--input-bg);
            border-left-color: var(--sidebar-active);
        }

        .dropdown-menu a .desc {
            display: block;
            font-size: 10px;
            color: #999;
            margin-top: 2px;
            font-weight: normal;
        }

        .dropdown-menu a.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .user-section {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 0 12px;
            height: 100%;
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 9px;
        }

        .content-area {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 0;
            background: var(--bg-color);
        }

        .content-pane {
            display: none;
        }

        .content-pane.active {
            display: block;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: var(--container-bg);
            padding: 30px;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .testing-banner {
            background: #fff3cd;
            color: #856404;
            padding: 12px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
            font-size: 14px;
        }

        [data-theme="dark"] .testing-banner {
            background: #856404;
            color: #fff3cd;
        }

        .enterprise-testing-banner {
            background: #d1ecf1;
            color: #0c5460;
            padding: 12px;
            text-align: center;
            border-radius: 5px;
            margin-bottom: 20px;
            font-weight: bold;
            font-size: 14px;
        }

        [data-theme="dark"] .enterprise-testing-banner {
            background: #0c5460;
            color: #d1ecf1;
        }

        /* Dark mode contrast fixes for inline "Policy Compliance" banners
           These banners were authored with light backgrounds inline, which
           reduces contrast in dark mode. We override them here using
           attribute selectors and !important to beat inline styles. */
        [data-theme="dark"] div[style*="background: #e8f5e9"] {
            background: #1f2a1f !important;
            /* green variant */
            border-color: #66bb6a !important;
            color: #e8ffe8 !important;
        }

        [data-theme="dark"] div[style*="background: #e8f5e9"] h3 {
            color: #8be28b !important;
        }

        [data-theme="dark"] div[style*="background: #fff3e0"] {
            background: #2a241a !important;
            /* orange variant */
            border-color: #ffb74d !important;
            color: #ffe7c2 !important;
        }

        [data-theme="dark"] div[style*="background: #fff3e0"] h3 {
            color: #ffc977 !important;
        }

        [data-theme="dark"] div[style*="background: #e3f2fd"] {
            background: #17222b !important;
            /* blue variant */
            border-color: #64b5f6 !important;
            color: #d7ecff !important;
        }

        [data-theme="dark"] div[style*="background: #e3f2fd"] h3 {
            color: #90caf9 !important;
        }

        [data-theme="dark"] div[style*="background: #f3e5f5"] {
            background: #211a23 !important;
            /* purple variant */
            border-color: #ce93d8 !important;
            color: #f0dbf4 !important;
        }

        [data-theme="dark"] div[style*="background: #f3e5f5"] h3 {
            color: #e1bee7 !important;
        }

        /* Tower Mode selector & hints - dark mode contrast */
        [data-theme="dark"] #tower-pane .section[style*="background: #f8f9fa"] {
            background: #202225 !important;
            border-left-color: #ffb74d !important;
        }

        [data-theme="dark"] #tower-pane .section [style*="background: white"] {
            background: #2a2a2a !important;
            border-color: #666 !important;
            color: #eee !important;
        }

        [data-theme="dark"] #newModeHint[style*="background: #e8f5e9"] {
            background: #1f2a1f !important;
            color: #e8ffe8 !important;
        }

        [data-theme="dark"] #dropZone[style*="background: white"] {
            background: #2a2a2a !important;
            border-color: #777 !important;
        }

        [data-theme="dark"] #uploadedFileName[style*="background: #e3f2fd"] {
            background: #17222b !important;
            color: #d7ecff !important;
        }

        h1 {
            color: var(--button-bg);
            text-align: center;
        }

        h3 {
            color: var(--text-color);
            margin: 20px 0 15px 0;
        }

        h2 {
            color: var(--text-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 5px;
        }

        .section {
            margin-bottom: 20px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 5px;
            transition: all 0.3s ease;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: var(--text-color);
        }

        input,
        select,
        textarea {
            width: 100%;
            padding: 8px;
            margin-bottom: 10px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            box-sizing: border-box;
            background: var(--input-bg);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        button {
            background-color: var(--button-bg);
            color: white;
            padding: 12px 24px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 15px;
            font-weight: 500;
            margin: 0 8px 12px 0;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }

        button:hover:not(:disabled) {
            background-color: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        button:active:not(:disabled) {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            opacity: 0.6;
            transform: none;
        }

        /* Button groups - proper spacing */
        .button-group {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin: 20px 0;
            align-items: center;
        }

        .button-group button {
            margin: 0;
        }

        #output {
            background-color: var(--output-bg);
            color: var(--text-color);
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            white-space: pre-wrap;
            font-family: monospace;
            min-height: 300px;
            width: 100%;
            transition: all 0.3s ease;
        }

        .features {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .interface-item,
        .uplink-item,
        .switch-item,
        .ip-item,
        .vlan-item,
        .vpls-item,
        .customer-item {
            border: 1px solid var(--border-color);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            background: var(--input-bg);
            transition: all 0.3s ease;
        }

        .interface-item:hover,
        .uplink-item:hover,
        .switch-item:hover,
        .ip-item:hover,
        .vlan-item:hover,
        .vpls-item:hover,
        .customer-item:hover {
            border-color: var(--button-bg);
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        .interface-grid,
        .uplink-grid,
        .switch-grid,
        .ip-grid,
        .vlan-grid,
        .vpls-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .customer-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 10px;
        }

        .dhcp-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .device-selection-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
        }

        .toggle-dark {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .toggle-dark:hover {
            background: var(--button-bg);
            border-color: var(--button-bg);
            transform: scale(1.05);
        }

        /* Home Dashboard Styles */
        .dashboard-container {
            padding: 30px;
            max-width: 1400px;
            margin: 0 auto;
        }

        .dashboard-header {
            margin-bottom: 30px;
        }

        .dashboard-header h1 {
            font-size: 32px;
            margin-bottom: 10px;
            color: var(--text-color);
        }

        .dashboard-header p {
            color: #999;
            font-size: 14px;
        }

        .metrics-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .metric-card {
            background: var(--container-bg);
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: flex;
            flex-direction: column;
            gap: 10px;
            transition: all 0.3s ease;
            border-left: 4px solid var(--button-bg);
        }

        .metric-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        }

        .metric-icon {
            font-size: 32px;
        }

        .metric-value {
            font-size: 36px;
            font-weight: bold;
            color: var(--button-bg);
        }

        .metric-label {
            font-size: 13px;
            color: #999;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .activity-section {
            background: var(--container-bg);
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            margin-bottom: 30px;
        }

        .activity-section h2 {
            font-size: 20px;
            margin-bottom: 20px;
            color: var(--text-color);
            border-bottom: 2px solid var(--border-color);
            padding-bottom: 10px;
        }

        .activity-item {
            padding: 15px;
            border-left: 3px solid var(--button-bg);
            background: var(--input-bg);
            border-radius: 6px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
        }

        .activity-item:hover {
            background: var(--border-color);
            transform: translateX(5px);
        }

        .activity-item .title {
            font-weight: bold;
            color: var(--text-color);
            margin-bottom: 5px;
        }

        .activity-item .details {
            font-size: 12px;
            color: #999;
        }

        .activity-item .time {
            font-size: 11px;
            color: #666;
            margin-top: 5px;
        }

        .quick-actions {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }

        .quick-action-btn {
            padding: 20px;
            background: var(--button-bg);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: center;
        }

        .quick-action-btn:hover {
            background: var(--button-hover);
            transform: translateY(-3px);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: #999;
        }

        .empty-state-icon {
            font-size: 64px;
            margin-bottom: 15px;
            opacity: 0.5;
        }

        /* Announcements Section */
        .announcements-section {
            background: linear-gradient(135deg, #2a1a4a 0%, #1a1a2a 100%);
            border-radius: 12px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(230, 126, 34, 0.3);
        }

        .announcements-title {
            font-size: 28px;
            font-weight: bold;
            color: #e67e22;
            text-align: center;
            margin-bottom: 25px;
            text-transform: none;
            letter-spacing: 0.5px;
        }

        .announcements-title::after {
            content: '';
            display: block;
            width: 60px;
            height: 3px;
            background: #e67e22;
            margin: 10px auto 0;
        }

        .announcement-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(230, 126, 34, 0.2);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 15px;
        }

        .announcement-card:last-child {
            margin-bottom: 0;
        }

        .announcement-card h3 {
            color: white;
            font-size: 18px;
            margin-bottom: 15px;
        }

        .announcement-card p {
            color: #ccc;
            line-height: 1.6;
            margin-bottom: 10px;
        }

        .announcement-meta {
            font-size: 12px;
            color: #888;
            margin-top: 15px;
            font-style: italic;
        }

        .beta-badge {
            display: inline-block;
            background: #e74c3c;
            color: white;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            margin-left: 10px;
            text-transform: uppercase;
        }

        /* Feedback Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 2000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            animation: fadeIn 0.3s ease;
        }

        .modal.show {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal-content {
            background: var(--container-bg);
            padding: 30px;
            border-radius: 12px;
            max-width: 600px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
            }

            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(30px);
                opacity: 0;
            }

            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--border-color);
        }

        .modal-header h2 {
            color: var(--text-color);
            font-size: 24px;
            margin: 0;
        }

        .modal-close {
            background: transparent;
            border: none;
            font-size: 28px;
            color: var(--text-color);
            cursor: pointer;
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 4px;
            transition: all 0.2s;
        }

        .modal-close:hover {
            background: rgba(231, 76, 60, 0.2);
            color: #e74c3c;
        }

        .feedback-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .feedback-tab {
            padding: 10px 20px;
            background: var(--input-bg);
            border: 2px solid transparent;
            border-radius: 6px;
            color: var(--text-color);
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }

        .feedback-tab:hover {
            border-color: var(--button-bg);
        }

        .feedback-tab.active {
            background: var(--button-bg);
            color: white;
            border-color: var(--button-bg);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            color: var(--text-color);
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px;
            background: var(--input-bg);
            border: 1px solid var(--border-color);
            border-radius: 6px;
            color: var(--text-color);
            font-size: 14px;
            transition: all 0.3s;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: var(--button-bg);
            box-shadow: 0 0 0 3px rgba(230, 126, 34, 0.1);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 120px;
            font-family: Arial, sans-serif;
        }

        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            margin-top: 25px;
        }

        .btn-submit {
            background: var(--button-bg);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
        }

        .btn-submit:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(230, 126, 34, 0.3);
        }

        .btn-submit:disabled {
            background: #666;
            cursor: not-allowed;
            transform: none;
        }

        .feedback-success {
            background: #27ae60;
            color: white;
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: none;
        }

        .feedback-success.show {
            display: block;
        }

        /* Live Activity Section */
        .live-activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .live-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            color: #27ae60;
            font-size: 13px;
            font-weight: 600;
        }

        .live-dot {
            width: 10px;
            height: 10px;
            background: #27ae60;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }

        .activity-item .user-info {
            font-weight: bold;
            color: var(--button-bg);
        }

        /* Settings Modal */
        .settings-section {
            background: var(--input-bg);
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .settings-section h3 {
            color: var(--text-color);
            font-size: 18px;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid var(--border-color);
        }

        .settings-section p {
            color: #999;
            font-size: 13px;
            margin-top: 10px;
            line-height: 1.5;
        }

        .theme-option,
        .font-option {
            display: block;
            padding: 12px;
            margin: 8px 0;
            background: var(--container-bg);
            border: 2px solid var(--border-color);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.3s;
            color: var(--text-color);
        }

        .theme-option:hover,
        .font-option:hover {
            border-color: var(--button-bg);
            background: var(--input-bg);
        }

        .theme-option.selected,
        .font-option.selected {
            border-color: var(--button-bg);
            background: rgba(230, 126, 34, 0.1);
            font-weight: bold;
        }

        .theme-preview {
            display: inline-block;
            width: 20px;
            height: 20px;
            border-radius: 4px;
            margin-right: 10px;
            vertical-align: middle;
        }

        .save-settings-btn {
            background: var(--button-bg);
            color: white;
            padding: 12px 30px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            width: 100%;
            margin-top: 20px;
            transition: all 0.3s;
        }

        .save-settings-btn:hover {
            background: var(--button-hover);
            transform: translateY(-2px);
        }

        [data-font-size="compact"] {
            font-size: 14px;
        }

        [data-font-size="cozy"] {
            font-size: 15px;
        }

        [data-font-size="comfortable"] {
            font-size: 16px;
        }

        [data-font-size="roomy"] {
            font-size: 17px;
        }

        [data-font-size="relaxed"] {
            font-size: 18px;
        }

        select {
            cursor: pointer;
        }

        .interface-buttons,
        .uplink-buttons,
        .switch-buttons,
        .ip-buttons,
        .vlan-buttons,
        .vpls-buttons,
        .customer-buttons {
            display: flex;
            gap: 12px;
            justify-content: center;
            margin-top: 15px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .interface-buttons button,
        .uplink-buttons button,
        .switch-buttons button,
        .ip-buttons button,
        .vlan-buttons button,
        .vpls-buttons button,
        .customer-buttons button {
            margin: 0;
        }

        .remove-btn {
            background: #dc3545;
            padding: 5px 10px;
            font-size: 12px;
        }

        textarea {
            resize: vertical;
        }

        .generate-section {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background: var(--container-bg);
            border-radius: 10px;
            border: 2px dashed var(--border-color);
        }

        .generate-section button {
            margin: 0;
            padding: 16px 40px;
            font-size: 18px;
            font-weight: bold;
        }

        #generateBtn {
            background: #FF9800;
            color: white;
            border: none;
            padding: 15px 30px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            z-index: 1000;
            position: relative;
        }

        #generateBtn:hover {
            background: #F57C00;
        }

        #generateBtn:active {
            background: #E65100;
        }

        #upgradeBtn:hover:not(:disabled) {
            background: #F57C00;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        #upgradeBtn:active:not(:disabled) {
            background: #E65100;
            transform: translateY(0);
        }

        .pool-grid {
            display: grid;
            grid-template-columns: 1fr 2fr 1fr;
            gap: 10px;
            align-items: end;
        }

        .mpls-section {
            display: none;
        }

        .vpls-section {
            display: none;
        }

        .dhcp-note {
            background: #d4edda;
            color: #155724;
            padding: 10px;
            border-radius: 5px;
            margin-bottom: 15px;
            font-size: 14px;
            text-align: center;
        }

        .hint {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
        }

        [data-theme="dark"] .hint {
            color: #aaa;
        }

        [data-theme="dark"] .dhcp-note {
            background: #155724;
            color: #d4edda;
        }

        /* Dark mode fixes for inline style backgrounds */
        [data-theme="dark"] div[style*="background: #2a4a2a"] {
            background: #1a2a1a !important;
            color: #e8ffe8 !important;
        }

        [data-theme="dark"] div[style*="background: #2a2a4a"] {
            background: #1a1a2a !important;
            color: #e8e8ff !important;
        }

        /* Live Progress Tracker (Inline Horizontal) */
        .progress-tracker {
            display: none;
            width: 100%;
            margin: 20px 0;
            background: #1e1e1e;
            border: 2px solid #4CAF50;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            overflow: hidden;
            flex-direction: column;
        }

        .progress-tracker.active {
            display: flex;
        }

        .progress-tracker.collapsed {
            max-height: 60px;
            overflow: hidden;
        }

        .progress-tracker.collapsed .progress-log-content,
        .progress-tracker.collapsed .progress-details {
            display: none;
        }

        .progress-header {
            background: linear-gradient(135deg, #2d5a3d, #1e3a2d);
            padding: 12px 15px;
            border-bottom: 1px solid #4CAF50;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .progress-header:hover {
            background: linear-gradient(135deg, #3d6a4d, #2e4a3d);
        }

        .progress-title {
            font-size: 14px;
            font-weight: bold;
            color: #fff;
        }

        .progress-status {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .status-badge {
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 11px;
            font-weight: bold;
        }

        .status-badge.in-progress {
            background: #4CAF50;
            color: white;
        }

        .status-badge.queued {
            background: #FF9800;
            color: white;
        }

        .status-badge.completed {
            background: #2196F3;
            color: white;
        }

        .status-badge.error {
            background: #f44336;
            color: white;
        }

        .progress-bar-container {
            background: #2a2a2a;
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
            margin: 0;
        }

        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #66BB6A);
            transition: width 0.3s ease;
            width: 0%;
        }

        .progress-details {
            padding: 12px 15px;
            color: #e0e0e0;
            font-size: 13px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }

        .progress-current-step {
            flex: 1;
            color: #fff;
            font-weight: 500;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .progress-percent {
            color: #4CAF50;
            font-weight: bold;
            font-size: 16px;
            white-space: nowrap;
        }

        .progress-elapsed {
            color: #888;
            font-size: 12px;
            white-space: nowrap;
        }

        .progress-log-header {
            padding: 8px 15px;
            background: #2a2a2a;
            border-top: 1px solid #333;
            border-bottom: 1px solid #333;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
        }

        .progress-log-header:hover {
            background: #333;
        }

        .progress-log-title {
            font-size: 12px;
            font-weight: bold;
            color: #e0e0e0;
        }

        .progress-log-toggle {
            color: #888;
            font-size: 10px;
        }

        .progress-log-content {
            background: #1a1a1a;
            max-height: 200px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 10px;
            color: #e0e0e0;
            display: none;
        }

        .progress-log-content.expanded {
            display: block;
        }

        .log-entry {
            padding: 4px 0;
            display: flex;
            align-items: flex-start;
            gap: 8px;
        }

        .log-icon {
            flex-shrink: 0;
            width: 16px;
        }

        .log-entry.info .log-icon {
            color: #2196F3;
        }

        .log-entry.success .log-icon {
            color: #4CAF50;
        }

        .log-entry.warning .log-icon {
            color: #FF9800;
        }

        .log-entry.error .log-icon {
            color: #f44336;
        }

        .log-timestamp {
            color: #666;
            font-size: 10px;
            margin-right: 8px;
        }

        .progress-actions {
            padding: 8px 15px;
            border-top: 1px solid #333;
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        .progress-action-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            font-weight: bold;
        }

        .btn-abort {
            background: #f44336;
            color: white;
        }

        .btn-kill {
            background: #B71C1C;
            color: white;
        }

        .btn-close {
            background: #666;
            color: white;
        }

        [data-theme="dark"] div[style*="background: #1a3a1a"] {
            background: #0f1f0f !important;
            color: #d0ffd0 !important;
        }

        [data-theme="dark"] div[style*="background: #f0f8ff"] {
            background: #1a1f2a !important;
            color: #e0e8ff !important;
            border-color: #64b5f6 !important;
        }

        [data-theme="dark"] div[style*="background: #f0f8ff"] h3 {
            color: #90caf9 !important;
        }

        [data-theme="dark"] div[style*="color: #666"] {
            color: #aaa !important;
        }

        [data-theme="dark"] div[style*="color: #999"] {
            color: #bbb !important;
        }

        /* Dark mode for buttons - keep accent colors but adjust backgrounds */
        [data-theme="dark"] button[style*="background: #FF9800"] {
            background: var(--button-bg) !important;
        }

        [data-theme="dark"] button[style*="background: #2196F3"] {
            background: #2196F3 !important;
        }

        [data-theme="dark"] button[style*="background: #4CAF50"] {
            background: #4CAF50 !important;
        }

        [data-theme="dark"] button[style*="background: #28a745"] {
            background: #28a745 !important;
        }

        [data-theme="dark"] button[style*="background: #dc3545"] {
            background: #dc3545 !important;
        }

        [data-theme="dark"] button[style*="background: #9C27B0"] {
            background: #9C27B0 !important;
        }

        /* Dark mode link colors */
        [data-theme="dark"] a[style*="color: #FF9800"] {
            color: var(--button-bg) !important;
        }

        /* =========================
           Executive Dashboard UI
           ========================= */
        .status-strip {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 14px 0 6px;
            justify-content: center;
        }

        .status-pill {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
            color: var(--text-color);
            font-size: 12px;
            letter-spacing: 0.2px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #777;
            box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.06);
        }

        .status-pill.ok .status-dot {
            background: #28a745;
        }

        .status-pill.warn .status-dot {
            background: #ff9800;
        }

        .status-pill.err .status-dot {
            background: #dc3545;
        }

        .status-kv {
            display: inline-flex;
            gap: 6px;
            white-space: nowrap;
        }

        .status-kv .k {
            color: var(--text-color-secondary, #aaa);
        }

        .status-kv .v {
            font-weight: 700;
        }

        .header-status {
            display: inline-flex;
            align-items: center;
            gap: 8px;
            padding: 4px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255, 255, 255, 0.08);
            background: rgba(255, 255, 255, 0.03);
            color: var(--text-color);
            font-size: 9px;
            line-height: 1;
            white-space: nowrap;
        }

        :root:not([data-theme="dark"]) .header-status {
            border: 1px solid rgba(0, 0, 0, 0.08);
            background: rgba(0, 0, 0, 0.03);
        }

        .header-status.ok .status-dot {
            background: #28a745;
        }

        .header-status.err .status-dot {
            background: #dc3545;
        }

        .monthly-tracker {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-top: 10px;
        }

        .monthly-row {
            display: grid;
            grid-template-columns: 90px 1fr 54px;
            gap: 12px;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .monthly-label {
            font-size: 12px;
            color: var(--text-color);
            font-weight: 600;
        }

        .monthly-count {
            font-variant-numeric: tabular-nums;
            font-size: 12px;
            color: var(--text-color-secondary, #aaa);
            text-align: right;
        }

        .bar-track {
            position: relative;
            height: 10px;
            border-radius: 999px;
            background: rgba(255, 255, 255, 0.06);
            overflow: hidden;
            box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.05);
        }

        .bar-fill {
            height: 100%;
            display: flex;
            border-radius: 999px;
            overflow: hidden;
        }

        .bar-success {
            position: absolute;
            left: 0;
            top: 0;
            bottom: 0;
            background: linear-gradient(90deg, #1f9d55, #28a745);
        }

        .bar-fail {
            position: absolute;
            top: 0;
            bottom: 0;
            background: linear-gradient(90deg, #b52b3a, #dc3545);
        }

        .bar-fill .bar-success,
        .bar-fill .bar-fail {
            position: static;
        }

        .monthly-tracker.compact {
            max-width: 520px;
            margin-left: auto;
            margin-right: auto;
        }

        .monthly-tracker.compact .monthly-row {
            grid-template-columns: 76px minmax(160px, 330px) 34px;
            gap: 10px;
        }

        .monthly-tracker.compact .bar-track {
            height: 8px;
        }

        .monthly-help {
            margin-top: 10px;
            font-size: 12px;
            color: var(--text-color-secondary, #aaa);
            text-align: center;
        }

        .section-header-row {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 10px;
            flex-wrap: wrap;
        }

        .section-subtle {
            color: var(--text-color-secondary, #aaa);
            font-size: 12px;
        }

        /* Aviat Backhaul Firmware Updater (NOC themed) */
        .aviat-tool {
            --aviat-card: var(--container-bg);
            --aviat-border: var(--border-color);
            --aviat-accent: var(--button-bg);
            --aviat-accent-strong: var(--button-bg);
        }

        .aviat-header {
            background: var(--container-bg);
            border: 1px solid var(--aviat-border);
            border-left: 4px solid var(--aviat-accent-strong);
            border-radius: 14px;
            padding: 20px 26px;
            margin-bottom: 16px;
            text-align: center;
            box-shadow: 0 12px 26px rgba(9, 14, 30, 0.2);
        }

        .aviat-header h1 {
            margin: 0 0 6px 0;
            color: var(--text-color);
            font-size: 24px;
        }

        .aviat-header p {
            margin: 0;
            color: var(--text-color-secondary);
            font-size: 13px;
        }

        .aviat-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(240px, 1fr));
            gap: 16px;
            max-width: 100%;
        }

        .aviat-card {
            background: var(--aviat-card);
            border: 1px solid var(--aviat-border);
            border-radius: 14px;
            padding: 16px;
            box-shadow: 0 10px 18px rgba(10, 12, 24, 0.2);
            min-width: 0;
        }

        .aviat-card h2 {
            margin: 0 0 12px 0;
            font-size: 15px;
            color: var(--text-color);
            letter-spacing: 0.2px;
        }

        .checkbox-item {
            display: grid;
            grid-template-columns: 22px minmax(0, 1fr);
            gap: 12px;
            align-items: center;
            padding: 12px 14px;
            border-radius: 10px;
            background: var(--input-bg);
            border: 1px solid var(--aviat-border);
            margin-bottom: 10px;
            cursor: pointer;
            transition: border-color 0.2s ease, background 0.2s ease;
        }

        .checkbox-item input[type="checkbox"] {
            margin: 0;
        }

        .checkbox-item:hover {
            border-color: var(--aviat-accent-strong);
            background: rgba(255, 255, 255, 0.03);
        }

        .aviat-task-title {
            display: flex;
            align-items: baseline;
            justify-content: space-between;
            gap: 8px;
            font-weight: 600;
        }

        .aviat-task-step {
            color: var(--aviat-accent-strong);
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.3px;
            text-transform: uppercase;
        }

        .aviat-task-name {
            font-size: 14px;
            color: var(--text-color);
        }

        .aviat-task-desc {
            margin-top: 4px;
            color: var(--text-color-secondary);
            font-size: 12px;
        }

        .aviat-maintenance-banner {
            border-radius: 12px;
            padding: 10px 16px;
            border: 1px solid var(--aviat-border);
            margin-bottom: 16px;
            font-size: 12px;
            text-align: center;
            letter-spacing: 0.2px;
        }

        .aviat-maintenance-on {
            background: rgba(46, 164, 96, 0.15);
            color: #a7f3d0;
            border-color: rgba(46, 164, 96, 0.35);
        }

        .aviat-maintenance-off {
            background: rgba(255, 166, 0, 0.12);
            color: #ffd166;
            border-color: rgba(255, 166, 0, 0.35);
        }

        .aviat-btn {
            background: var(--aviat-accent-strong);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 8px 14px;
            cursor: pointer;
            font-size: 12px;
            font-weight: 600;
        }

        .aviat-btn.secondary {
            background: var(--border-color);
            color: var(--text-color);
        }

        .aviat-btn.danger {
            background: #c0392b;
        }

        .aviat-btn.success {
            background: #2ecc71;
        }

        .aviat-status-badge {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            min-width: 22px;
            height: 22px;
            padding: 0 6px;
            border-radius: 999px;
            font-size: 11px;
            font-weight: 700;
            border: 1px solid var(--aviat-border);
            color: #dbe7ff;
            background: rgba(255, 255, 255, 0.04);
        }

        .aviat-status-badge.pending {
            background: rgba(59, 130, 246, 0.12);
            color: #9ec5ff;
        }

        .aviat-status-badge.processing {
            background: rgba(255, 193, 7, 0.18);
            color: #ffd166;
        }

        .aviat-status-badge.scheduled,
        .aviat-status-badge.manual {
            background: rgba(132, 204, 22, 0.14);
            color: #c7f9a7;
        }

        .aviat-status-badge.loading {
            background: rgba(155, 89, 182, 0.18);
            color: #d7b7f1;
        }

        .aviat-status-badge.success {
            background: rgba(16, 185, 129, 0.18);
            color: #a7f3d0;
        }

        .aviat-status-badge.error {
            background: rgba(239, 68, 68, 0.2);
            color: #fecaca;
        }

        .aviat-queue {
            max-height: 360px;
            overflow-y: auto;
            border-radius: 12px;
            border: 1px solid var(--aviat-border);
            background: var(--input-bg);
        }

        .aviat-queue-item {
            display: grid;
            grid-template-columns: minmax(0, 1fr) auto;
            gap: 10px;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid var(--aviat-border);
        }

        .aviat-queue-item:last-child {
            border-bottom: none;
        }

        .aviat-status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            display: inline-block;
            margin-right: 6px;
        }

        .aviat-log {
            background: var(--output-bg);
            border: 1px solid var(--aviat-border);
            border-radius: 12px;
            padding: 12px;
            min-height: 240px;
            max-height: 240px;
            overflow-y: auto;
            font-family: "Courier New", monospace;
            font-size: 12px;
            color: var(--text-color);
            white-space: pre-wrap;
        }

        .aviat-log-entry {
            margin-bottom: 6px;
        }

        .aviat-log-time {
            color: var(--text-color-secondary);
            margin-right: 6px;
        }

        .aviat-stat-row {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-bottom: 10px;
            font-size: 12px;
            color: var(--text-color-secondary);
        }

        .aviat-pill {
            background: var(--input-bg);
            border: 1px solid var(--aviat-border);
            border-radius: 999px;
            padding: 4px 10px;
            color: var(--text-color-secondary);
        }

        @media (max-width: 1100px) {
            .aviat-grid {
                grid-template-columns: 1fr;
            }

            #aviat-backhaul-pane .aviat-card {
                padding: 14px;
            }
        }

        #aviat-backhaul-pane {
            overflow-x: hidden;
        }

        #aviat-backhaul-pane * {
            box-sizing: border-box;
        }

        #aviat-backhaul-pane .container {
            max-width: 100%;
            width: 100%;
            box-sizing: border-box;
            padding: 24px;
        }

        #aviat-backhaul-pane .aviat-grid,
        #aviat-backhaul-pane .aviat-card,
        #aviat-backhaul-pane .aviat-queue-item,
        #aviat-backhaul-pane .aviat-log {
            min-width: 0;
        }

        #aviat-backhaul-pane textarea,
        #aviat-backhaul-pane input,
        #aviat-backhaul-pane select {
            max-width: 100%;
        }

        @media (max-width: 900px) {
            #aviat-backhaul-pane .container {
                padding: 18px;
            }
        }
    </style>
</head>

<body>
    <div class="main-container">
        <!-- Header Navigation -->
        <header class="top-header">
            <div class="header-logo">
                <div style="display: flex; align-items: center; gap: 8px;">
                    <div
                        style="width: 28px; height: 28px; background: linear-gradient(135deg, #e67e22 0%, #d35400 100%); border-radius: 6px; display: flex; align-items: center; justify-content: center; box-shadow: 0 2px 8px rgba(230, 126, 34, 0.3);">
                        <span style="font-size: 16px; color: white; font-weight: bold;"></span>
                    </div>
                    <div>
                        <div style="font-size: 13px; font-weight: bold; color: var(--sidebar-active);">NOC OPERATIONS CONFIG SUITE
                        </div>
                        <span class="subtitle">Network Operations Center Tool</span>
                    </div>
                </div>
            </div>
            <nav class="main-nav">
                <button class="nav-item active" data-tab="home">HOME</button>
                <div class="nav-item dropdown">
                    <button>MIKROTIK CONFIG </button>
                    <div class="dropdown-menu">
                        <a data-tab="tower">
                             Tower Config
                            <span class="desc">Full BGP/OSPF/MPLS for tower sites</span>
                        </a>
                        <a data-tab="enterprise">
                             Non-MPLS Enterprise
                            <span class="desc">Simplified configs for enterprise (no MPLS)</span>
                        </a>
                        <a data-tab="enterprise-mpls">
                             MPLS Enterprise
                            <span class="desc">Enterprise with MPLS/OSPF/BGP support</span>
                        </a>
                        <a data-tab="tarana">
                             Tarana Sectors
                            <span class="desc">ALPHA/BETA/GAMMA/DELTA sector configuration</span>
                        </a>
                        <a data-tab="ftth" id="ftthMenuItem">
                             FTTH BNG CONFIG
                            <span class="desc">FTTH BNG configuration generator</span>
                        </a>
                        <a data-tab="enterprise-feeding">
                             Enterprise Feeding
                            <span class="desc">Commercial/enterprise uplink provisioning</span>
                        </a>
                        <a data-tab="ccr2004">
                             6GHz Switch Port
                            <span class="desc">6GHz switch configuration with VLAN 3000/4000</span>
                        </a>
                        <a data-tab="switch-maker">
                             MikroTik Switch Maker
                            <span class="desc">Full switch configuration generator (309/326/2004)</span>
                        </a>
                    </div>
                </div>
                <div class="nav-item dropdown">
                    <button>NOKIA CONFIG <span style="font-size: 10px;"></span></button>
                    <div class="dropdown-menu">
                        <a data-tab="nokia7250-maker">
                             IN-STATE Nokia 7250 Configuration Maker
                            <span class="desc">Generate Nokia 7250 configurations (IN DEVELOPMENT - DO NOT USE)</span>
                        </a>
                        <a data-tab="mikrotik-to-nokia">
                             NOKIA MIGRATION
                            <span class="desc">Convert RouterOS configs to Nokia syntax (IN DEVELOPMENT - DO NOT
                                USE)</span>
                        </a>
                    </div>
                </div>
                <button class="nav-item" data-tab="aviat-backhaul">AVIAT BACKHAUL UPDATER</button>
                <button class="nav-item" data-tab="cisco-config">CISCO CONFIG</button>
                <button class="nav-item" data-tab="completed-configs"> CONFIGS</button>
                <button class="nav-item" data-tab="log-history"> LOG HISTORY</button>
                <button class="nav-item"
                    onclick="window.openFeedbackModal && window.openFeedbackModal()">FEEDBACK</button>
                <button class="nav-item" id="adminNavBtn" data-tab="admin-panel" style="background: #d35400;">
                    ADMIN</button>
            </nav>
            <div class="user-section">
                <span id="userEmailDisplay"
                    style="color: #bbb; font-size: 9px; margin-right: 10px; text-transform: uppercase;"></span>
                <div class="header-status" id="globalUpdatedPill" title="Last UI refresh time (live)">
                    <span class="status-dot" id="globalUpdatedDot" style="width: 6px; height: 6px;"></span>
                    <span class="status-kv"><span class="k">Updated</span><span class="v"
                            id="globalUpdatedAt"></span></span>
                </div>
                <button class="toggle-dark" id="settingsBtn"
                    onclick="window.openSettingsModal && window.openSettingsModal()"
                    style="font-size: 9px; padding: 4px 8px;"> SETTINGS</button>
                <button class="toggle-dark" id="darkToggle" style="font-size: 9px; padding: 4px 8px;"> Dark</button>
                <button class="toggle-dark" onclick="handleLogout()"
                    style="margin-left: 8px; font-size: 9px; padding: 4px 8px;">LOG OUT</button>
            </div>
        </header>

        <!-- Content Area -->
        <div class="content-area">
            <!-- HOME DASHBOARD -->
            <div class="content-pane active" id="home-pane">
                <div class="dashboard-container">
                    <div class="dashboard-header">
                    <h1>Welcome to NOC Operations Config Suite</h1>
                        <p>Network operations configuration and management tool</p>
                    </div>

                    <!-- Executive status strip (minimal) -->
                    <div class="status-strip" id="homeStatusStrip">
                        <div class="status-pill" id="homeStatusUpdated">
                            <span class="status-dot"></span>
                            <span class="status-kv"><span class="k">Updated</span><span class="v"
                                    id="homeStatusUpdatedValue"></span></span>
                        </div>
                    </div>

                    <!-- Announcements -->
                    <div class="announcements-section">
                        <h2 class="announcements-title">Current Announcements</h2>
                        <div class="announcement-card" id="announcementsContainer">
                            <h3>Welcome! <span class="beta-badge">Beta Testing</span></h3>
                            <p>Welcome to NOC Operations Config Suite (Multi-Use Configuration Generator)!</p>
                            <p>This tool is currently in <strong>Beta Testing</strong> stage, so there might be some
                                bugs or improvements needed. We appreciate your feedback as we work to make this the
                                best configuration tool possible.</p>
                        </div>
                    </div>

                    <!-- Metrics -->
                    <div class="metrics-row">
                        <div class="metric-card">
                            <span class="metric-icon"></span>
                            <span class="metric-value" id="metricTotalConfigs">0</span>
                            <span class="metric-label">CONFIG & SCRIPTS GENERATED</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-icon"></span>
                            <span class="metric-value" id="metricMigrations">0</span>
                            <span class="metric-label">Migrations Completed</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-icon"></span>
                            <span class="metric-value" id="metricFirmwareUpgrades">0</span>
                            <span class="metric-label">Firmware Upgrades</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-icon"></span>
                            <span class="metric-value" id="metricSuccess">100%</span>
                            <span class="metric-label">Success Rate</span>
                        </div>
                        <div class="metric-card">
                            <span class="metric-icon"></span>
                            <span class="metric-value" id="metricToday">0</span>
                            <span class="metric-label">Generated Today</span>
                        </div>
                    </div>

                    <!-- Quick Actions -->
                    <div class="activity-section">
                        <h2>Quick Actions</h2>
                        <div class="quick-actions">
                            <button class="quick-action-btn"
                                onclick="window.navigateToTab && window.navigateToTab('tower')">
                                 New Tower Config
                            </button>
                            <button class="quick-action-btn"
                                onclick="window.navigateToTab && window.navigateToTab('enterprise')">
                                 New Enterprise Config
                            </button>
                            <button class="quick-action-btn"
                                onclick="if(window.navigateToTab) { window.navigateToTab('tower'); setTimeout(() => { if(typeof switchMode === 'function') switchMode('upgrade'); }, 100); }">
                                 Migrate/Upgrade Config
                            </button>
                            <button class="quick-action-btn"
                                onclick="window.navigateToTab && window.navigateToTab('completed-configs')">
                                 View Completed Configs
                            </button>
                        </div>
                    </div>

                    <!-- Recent Activity (Live Feed) -->
                    <div class="activity-section">
                        <div class="live-activity-header">
                            <h2>Recent Activity</h2>
                            <div class="live-indicator">
                                <span class="live-dot"></span>
                                <span>LIVE</span>
                            </div>
                        </div>

                        <details class="section" style="margin: 12px 0 14px 0;">
                            <summary style="cursor: pointer; color: var(--text-color); font-weight: 700;">Monthly
                                Activity</summary>
                            <div class="section-subtle" style="margin-top: 8px;">Updated <span
                                    id="homeMonthlyUpdated"></span></div>
                            <div id="homeMonthlySummary" class="monthly-help" style="margin-top: 6px;"></div>
                            <div id="homeMonthlyTracker" class="monthly-tracker compact"></div>
                            <div class="monthly-help" style="margin-top: 8px;">Tip: Click a month bar to jump to Log
                                History filters.</div>
                        </details>

                        <div id="recentActivityList">
                            <div class="empty-state">
                                <div class="empty-state-icon"></div>
                                <p>No recent activity yet. Generate your first config to get started!</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Settings Modal -->
            <div id="settingsModal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Account Settings</h2>
                        <button class="modal-close" onclick="closeSettingsModal()">&times;</button>
                    </div>

                    <p style="color: #999; margin-bottom: 20px;">Manage your account preferences and appearance settings
                    </p>

                    <!-- Password Management -->
                    <div class="settings-section">
                        <h3>Password Management</h3>
                        <div style="margin-bottom: 15px;">
                            <button onclick="openPasswordChangeModal()"
                                style="background: #e67e22; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: 600;">
                                 Change Password
                            </button>
                        </div>
                        <p style="font-size: 13px; color: #999;">Update your password or reset it if you've forgotten
                            it.</p>
                    </div>

                    <hr style="border: none; border-top: 1px solid var(--border-color); margin: 20px 0;">

                    <!-- Admin Reset Password -->
                    <div class="settings-section" id="adminResetSection" style="display: none;">
                        <h3>Admin: Reset User Password</h3>
                        <div class="form-group">
                            <label for="adminResetEmail">User Email</label>
                            <input type="email" id="adminResetEmail" class="form-input"
                                placeholder="user@team.nxlink.com">
                        </div>
                        <div class="form-group">
                            <label for="adminResetTempPassword">Temporary Password (optional)</label>
                            <input type="text" id="adminResetTempPassword" class="form-input"
                                placeholder="Leave blank to use default password">
                        </div>
                        <label style="display: flex; gap: 8px; align-items: center; font-size: 13px; color: #bbb; margin-bottom: 12px;">
                            <input type="checkbox" id="adminRequirePasswordChange" checked>
                            Require password change on next login
                        </label>
                        <button onclick="adminResetUserPassword()"
                            style="background: #d35400; color: white; padding: 10px 18px; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            Reset Password
                        </button>
                        <div id="adminResetStatus"
                            style="margin-top: 10px; font-size: 13px; color: #aaa; display: none;"></div>
                    </div>

                    <hr style="border: none; border-top: 1px solid var(--border-color); margin: 20px 0;">

                    <!-- Theme Selection -->
                    <div class="settings-section">
                        <h3>Theme</h3>
                        <select id="themeSelect"
                            style="width: 100%; padding: 10px; border-radius: 8px; border: 1px solid var(--border-color); background: var(--input-bg); color: var(--text-color);">
                            <option value="dark">Default (midnight)</option>
                            <option value="nx-ember">NX Ember (warm)</option>
                            <option value="slate">Slate (cool)</option>
                            <option value="graphite">Graphite (high contrast)</option>
                            <option value="ocean">Ocean (clean)</option>
                            <option value="neon-holo">Neon (holographic)</option>
                            <option value="neon-aero">Neon Aero</option>
                            <option value="light">Light</option>
                        </select>
                        <p>Choose how components render across the app. Your selection follows you on every sign-in.</p>
                    </div>

                    <!-- Font Size Selection -->
                    <div class="settings-section">
                        <h3>Font size</h3>
                        <div id="fontOptions">
                            <label class="font-option">
                                <input type="radio" name="fontSize" value="compact" style="margin-right: 10px;">
                                Compact (14pt)
                            </label>
                            <label class="font-option">
                                <input type="radio" name="fontSize" value="cozy" style="margin-right: 10px;">
                                Cozy (15pt)
                            </label>
                            <label class="font-option">
                                <input type="radio" name="fontSize" value="comfortable" style="margin-right: 10px;">
                                Comfortable (16pt)
                            </label>
                            <label class="font-option">
                                <input type="radio" name="fontSize" value="roomy" style="margin-right: 10px;">
                                Roomy (17pt)
                            </label>
                            <label class="font-option">
                                <input type="radio" name="fontSize" value="relaxed" style="margin-right: 10px;">
                                Relaxed (18pt)
                            </label>
                        </div>
                        <p>Adjust the base font size across the app. Component-level font sizes continue to respect
                            their design tokens.</p>
                    </div>

                    <button class="save-settings-btn" onclick="saveSettings()">
                        Save Appearance Preferences
                    </button>
                </div>
            </div>

            <!-- Password Change Modal -->
            <div id="passwordChangeModal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Change Password</h2>
                        <button class="modal-close" onclick="closePasswordChangeModal()">&times;</button>
                    </div>

                    <div id="passwordChangeError"
                        style="display: none; background: rgba(220, 53, 69, 0.1); border: 1px solid rgba(220, 53, 69, 0.3); color: #ff6b6b; padding: 12px; border-radius: 8px; margin-bottom: 20px; font-size: 13px;">
                    </div>
                    <div id="passwordChangeSuccess"
                        style="display: none; background: rgba(76, 175, 80, 0.1); border: 1px solid rgba(76, 175, 80, 0.3); color: #4caf50; padding: 12px; border-radius: 8px; margin-bottom: 20px; font-size: 13px;">
                    </div>

                    <form id="passwordChangeForm" onsubmit="handlePasswordChangeFromSettings(event)">
                        <div class="form-group">
                            <label for="settingsCurrentPassword">Current Password</label>
                            <input type="password" id="settingsCurrentPassword" class="form-input"
                                placeholder="Enter your current password" required>
                        </div>

                        <div class="form-group">
                            <label for="settingsNewPassword">New Password</label>
                            <input type="password" id="settingsNewPassword" class="form-input"
                                placeholder="Enter your new password" required minlength="8">
                            <p style="font-size: 12px; color: #999; margin-top: 5px;">Password must be at least 8
                                characters long</p>
                        </div>

                        <div class="form-group">
                            <label for="settingsConfirmPassword">Confirm New Password</label>
                            <input type="password" id="settingsConfirmPassword" class="form-input"
                                placeholder="Confirm your new password" required minlength="8">
                        </div>

                        <button type="submit" class="save-settings-btn" id="passwordChangeSubmitBtn">
                            Change Password
                        </button>
                    </form>
                </div>
            </div>

            <!-- Feedback Modal -->
            <div id="feedbackModal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Tell us what you need</h2>
                        <button class="modal-close" onclick="closeFeedbackModal()">&times;</button>
                    </div>

                    <div class="feedback-success" id="feedbackSuccess">
                         Thank you! Your feedback has been submitted successfully.
                    </div>

                    <p style="color: #999; margin-bottom: 20px;">Share general feedback, request new capabilities, or
                        tell us when something breaks.</p>

                    <div class="feedback-tabs">
                        <button class="feedback-tab active" data-type="feedback"
                            onclick="switchFeedbackTab(this)">FEEDBACK</button>
                        <button class="feedback-tab" data-type="feature" onclick="switchFeedbackTab(this)">Feature
                            Request</button>
                        <button class="feedback-tab" data-type="bug" onclick="switchFeedbackTab(this)">Bug
                            Report</button>
                    </div>

                    <form id="feedbackForm">
                        <div class="form-group">
                            <label for="feedbackSubject">Subject</label>
                            <input type="text" id="feedbackSubject" placeholder="Give your request a short title"
                                required>
                        </div>

                        <div class="form-group">
                            <label for="feedbackCategory">Category</label>
                            <select id="feedbackCategory" required>
                                <option value="">Select a category</option>
                                <option value="ui">User Interface</option>
                                <option value="config-generation">Config Generation</option>
                                <option value="migration">Migration/Upgrade</option>
                                <option value="validation">Validation</option>
                                <option value="performance">Performance</option>
                                <option value="documentation">Documentation</option>
                                <option value="other">Other</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="feedbackExperience">Overall experience</label>
                            <select id="feedbackExperience" required>
                                <option value="">Pick a rating</option>
                                <option value="5"> Excellent</option>
                                <option value="4"> Good</option>
                                <option value="3"> Average</option>
                                <option value="2"> Poor</option>
                                <option value="1"> Very Poor</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label for="feedbackDetails">Details</label>
                            <textarea id="feedbackDetails"
                                placeholder="Include context, desired outcomes, and any supporting links."
                                required></textarea>
                        </div>

                        <div class="form-group">
                            <label for="feedbackName">Your Name (Optional)</label>
                            <input type="text" id="feedbackName" placeholder="Enter your name">
                        </div>

                        <div class="form-actions">
                            <button type="submit" class="btn-submit">
                                 SUBMIT
                            </button>
                        </div>
                    </form>
                </div>
            </div>
            <!-- TOWER CONFIG TAB -->
            <div class="content-pane" id="tower-pane">
                <div class="container">
                    <div
                        style="background: #ff6b35; color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 5px solid #ff4500;">
                        <strong> IN DEVELOPMENT - DO NOT USE IN PRODUCTION</strong>
                        <p style="margin: 10px 0 0 0; font-size: 14px;">This feature is currently under development and
                            testing. Do not use generated configurations in production environments without thorough
                            review.</p>
                    </div>
                    <h1> Tower Configuration Generator</h1>
                    <p style="text-align: center; color: var(--text-color);">Nextlink-compliant tower site configuration
                        with standardized port assignments, BGP/OSPF/MPLS, and AI-powered validation.</p>
                    <p
                        style="text-align: center; color: var(--text-color-secondary); font-size: 14px; margin-top: 10px;">
                         <a href="javascript:void(0);" onclick="togglePolicyReference();"
                            style="color: #FF9800; text-decoration: underline;">View Policy Reference</a> for port
                        assignments and configuration details.</p>

                    <!-- Mode Selection -->
                    <div class="section"
                        style="background: var(--container-bg); border-left: 4px solid var(--button-bg); padding: 20px;">
                        <div style="display: flex; gap: 15px; margin-bottom: 15px;">
                            <label
                                style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 20px; background: var(--input-bg); border: 2px solid var(--button-bg); border-radius: 6px; flex: 1; color: var(--text-color);">
                                <input type="radio" name="configMode" value="new" checked onchange="switchMode('new')">
                                <span style="font-weight: bold;"> New Device</span>
                            </label>
                            <label
                                style="display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 20px; background: var(--input-bg); border: 2px solid var(--border-color); border-radius: 6px; flex: 1; color: var(--text-color);">
                                <input type="radio" name="configMode" value="upgrade" onchange="switchMode('upgrade')">
                                <span style="font-weight: bold;"> Upgrade Existing</span>
                            </label>
                        </div>

                        <!-- NEW MODE HINT -->
                        <div id="newModeHint"
                            style="padding: 12px; background: #e8f5e9; border-radius: 4px; font-size: 14px;">
                             <strong>New Device:</strong> Fill form below, click Generate. Nextlink defaults will be
                            auto-loaded.
                        </div>

                        <!-- UPGRADE MODE: File Upload or SSH Fetch -->
                        <div id="upgradeMode" style="display: none;">
                            <!-- Method Selection: File Upload vs SSH -->
                            <div
                                style="margin-bottom: 20px; padding: 15px; background: var(--container-bg); border-radius: 6px; border: 1px solid var(--border-color);">
                                <label style="font-weight: bold; display: block; margin-bottom: 10px;">Select
                                    Method:</label>
                                <div style="display: flex; gap: 20px;">
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="radio" name="upgradeMethod" value="ssh" checked
                                            onchange="toggleUpgradeMethod()" style="margin-right: 8px;">
                                        <span>SSH into Device</span>
                                    </label>
                                    <label style="display: flex; align-items: center; cursor: pointer;">
                                        <input type="radio" name="upgradeMethod" value="file"
                                            onchange="toggleUpgradeMethod()" style="margin-right: 8px;">
                                        <span>Upload Config File (optional)</span>
                                    </label>
                                </div>
                            </div>

                            <!-- FILE UPLOAD METHOD -->
                            <div id="fileUploadMethod" style="display: none;">
                                <div id="dropZone"
                                    style="border: 3px dashed var(--border-color); border-radius: 8px; padding: 40px; text-align: center; background: var(--input-bg); cursor: pointer; transition: all 0.3s; color: var(--text-color);">
                                    <div style="font-size: 48px; margin-bottom: 10px;"></div>
                                    <div style="font-size: 16px; font-weight: bold; margin-bottom: 8px;">Drag & Drop
                                        Config File</div>
                                    <div
                                        style="font-size: 13px; color: var(--text-color); opacity: 0.7; margin-bottom: 15px;">
                                        or click to browse (.rsc or .txt)</div>
                                    <input type="file" id="fileInput" accept=".rsc,.txt" style="display: none;">
                                    <button onclick="document.getElementById('fileInput').click()"
                                        style="background: #FF9800; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">
                                        Browse Files
                                    </button>
                                    <div style="font-size: 12px; color: #999; margin-top: 10px;">From old device:
                                        /export file=backup.rsc</div>
                                </div>
                            </div>

                            <!-- SSH FETCH METHOD -->
                            <div id="sshFetchMethod" style="display: block;">
                                <div
                                    style="padding: 20px; background: var(--container-bg); border-radius: 8px; border: 2px solid var(--border-color);">
                                    <h3 style="margin-top: 0; color: var(--text-color);"> SSH Device Connection</h3>
                                    <div
                                        style="margin-bottom: 15px; padding: 10px; background: #2a4a2a; border-radius: 5px; font-size: 13px;">
                                        <strong>Note:</strong> This will SSH into the device and run
                                        <code>/export</code> command to fetch the current configuration.
                                    </div>

                                    <div
                                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                        <div>
                                            <label style="font-weight: bold; display: block; margin-bottom: 5px;">Device
                                                IP Address:</label>
                                            <input type="text" id="sshDeviceIP" placeholder="192.168.88.1"
                                                style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                        </div>
                                        <div>
                                            <label
                                                style="font-weight: bold; display: block; margin-bottom: 5px;">RouterOS
                                                Version:</label>
                                            <select id="sshRouterOSVersion"
                                                style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                                <option value="7">RouterOS 7.x</option>
                                                <option value="6">RouterOS 6.x</option>
                                            </select>
                                        </div>
                                    </div>

                                    <div
                                        style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                        <div>
                                            <label style="font-weight: bold; display: block; margin-bottom: 5px;">SSH
                                                Username:</label>
                                            <input type="text" id="sshUsername" placeholder="e.g., admin"
                                                style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                        </div>
                                        <div>
                                            <label style="font-weight: bold; display: block; margin-bottom: 5px;">SSH
                                                Password:</label>
                                            <input type="password" id="sshPassword" placeholder="Enter password"
                                                style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                        </div>
                                    </div>

                                    <div class="form-group" style="margin-bottom: 15px;">
                                        <label style="font-weight: bold; display: block; margin-bottom: 5px;">SSH Ports
                                            (optional):</label>
                                        <input type="text" id="sshPorts" placeholder="22,5022"
                                            style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                        <div
                                            style="margin-top: 6px; font-size: 12px; color: var(--text-color-secondary);">
                                            Comma-separated. Default is <code>22</code>, then <code>5022</code>. You can
                                            add custom ports.
                                        </div>
                                    </div>

                                    <div style="margin-bottom: 15px;">
                                        <label style="font-weight: bold; display: block; margin-bottom: 5px;">Export
                                            Command:</label>
                                        <select id="sshExportCommand"
                                            style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                            <option value="export">export (default)</option>
                                            <option value="export show-sensitive">export show-sensitive (ROS7 - includes
                                                passwords)</option>
                                            <option value="export hide-sensitive">export hide-sensitive (ROS6 - excludes
                                                passwords)</option>
                                        </select>
                                    </div>

                                    <button id="sshFetchBtn" onclick="fetchConfigViaSSH()"
                                        style="width: 100%; background: #4CAF50; color: white; padding: 12px; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;">
                                         Fetch Config via SSH
                                    </button>

                                    <div id="sshStatus"
                                        style="margin-top: 15px; padding: 12px; border-radius: 4px; display: none;">
                                    </div>
                                </div>
                            </div>

                            <div id="uploadedFileName"
                                style="margin-top: 10px; padding: 10px; background: var(--container-bg); border: 1px solid var(--border-color); border-radius: 4px; display: none; color: var(--text-color);">
                                <strong> Loaded:</strong> <span id="fileName"></span>
                            </div>

                            <!-- Target Device Selection (only for upgrade) -->
                            <div id="upgradeTargetSelection"
                                style="margin-top: 15px; padding: 15px; background: var(--container-bg); border-radius: 6px; display: none; border: 1px solid var(--border-color);">
                                <div
                                    style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                                    <div>
                                        <label style="font-weight: bold; display: block; margin-bottom: 5px;">Target
                                            Device:</label>
                                        <select id="upgradeTargetDevice" style="width: 100%; padding: 8px;">
                                            <option value="ccr2004">CCR2004-1G-12S+2XS (12 SFP+, 2 SFP28)</option>
                                            <option value="ccr1036">CCR1036-12G-4S (4 SFP, 12 Ethernet)</option>
                                            <option value="ccr2216">CCR2216</option>
                                            <option value="ccr2116">CCR2116</option>
                                            <option value="ccr1072">CCR1072</option>
                                            <option value="rb5009">RB5009 (Small sites)</option>
                                            <option value="rb2011">RB2011</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label style="font-weight: bold; display: block; margin-bottom: 5px;">Target
                                            RouterOS:</label>
                                        <select id="upgradeTargetVersion" style="width: 100%; padding: 8px;">
                                            <option value="7.16.2">7.16.2 (Stable)</option>
                                            <option value="7.19.4">7.19.4 (Latest)</option>
                                            <option value="7.11.2">7.11.2</option>
                                        </select>
                                    </div>
                                </div>

                                <!-- Upgrade Button -->
                                <button id="upgradeBtn" onclick="performUpgrade()"
                                    style="width: 100%; background: #FF9800; color: white; padding: 15px; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer; transition: all 0.3s;">
                                     Start Upgrade
                                </button>
                            </div>

                            <div id="upgradeStatus"
                                style="margin-top: 15px; padding: 12px; border-radius: 4px; display: none;"></div>

                            <!-- PROGRESS BAR -->
                            <div id="upgradeProgressContainer" style="margin-top: 15px; display: none;">
                                <div
                                    style="background: #f0f0f0; border-radius: 8px; overflow: hidden; height: 30px; position: relative;">
                                    <div id="upgradeProgressBar"
                                        style="background: linear-gradient(90deg, #4CAF50, #8BC34A); height: 100%; width: 0%; transition: width 0.5s ease; display: flex; align-items: center; justify-content: center; color: white; font-weight: bold; font-size: 14px;">
                                        0%
                                    </div>
                                </div>
                                <div id="upgradeProgressLabel"
                                    style="margin-top: 5px; text-align: center; color: #666; font-size: 13px;">
                                    Initializing...</div>
                            </div>

                            <!-- UPGRADE OUTPUT SECTION -->
                            <div id="upgradeOutputSection" style="margin-top: 20px; display: none;">
                                <div
                                    style="background: var(--container-bg); padding: 20px; border-radius: 8px; border: 2px solid #4CAF50;">
                                    <h3 style="color: #4CAF50; margin-bottom: 15px;"> Translated Configuration</h3>
                                    <div style="margin-bottom: 15px; display: flex; gap: 10px;">
                                        <button id="upgradeCopyBtn"
                                            style="background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">
                                             Copy to Clipboard
                                        </button>
                                        <button id="upgradeDownloadBtn"
                                            style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">
                                             Download .rsc File
                                        </button>
                                    </div>
                                    <textarea id="upgradeOutput" readonly
                                        style="width: 100%; min-height: 500px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; white-space: pre; overflow-x: auto; word-wrap: normal;"
                                        spellcheck="false"></textarea>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Main Form (hidden during upgrade) -->
                    <div id="mainForm">
                        <!-- Configuration Type - Moved to Top -->
                        <div class="section"
                            style="background: var(--container-bg); border-left: 4px solid var(--button-bg); padding: 20px; margin-bottom: 20px;">
                            <h2 style="margin-top: 0;">Configuration Type</h2>
                            <div class="form-group">
                                <label for="configType" style="font-size: 16px; font-weight: bold;">Select Configuration
                                    Type:</label>
                                <select id="configType"
                                    style="font-size: 16px; padding: 10px; width: 100%; max-width: 500px;"
                                    onchange="handleConfigTypeChange()">
                                    <option value="in-state">In-State (Full BGP/OSPF)</option>
                                    <option value="out-of-state">Out-of-State (OSPF/MPLS/VPLS)</option>
                                    <option value="simple-baseline">Simple Bridge/DHCP</option>
                                </select>
                                <div style="margin-top: 12px; display: flex; align-items: center; gap: 10px;">
                                    <input type="checkbox" id="disableUnusedPorts">
                                    <label for="disableUnusedPorts" style="margin: 0; cursor: pointer;">
                                        Disable unused ports (optional)
                                    </label>
                                </div>
                                <div style="margin-top: 6px; font-size: 12px; color: var(--text-color-secondary);">
                                    Leave unchecked to avoid accidentally disabling live uplinks/backhauls not
                                    explicitly configured in the form.
                                </div>
                                <div
                                    style="margin-top: 10px; padding: 10px; background: #2a4a2a; border-radius: 5px; font-size: 14px;">
                                    <strong>Note:</strong> Configuration type determines which features are available
                                    and automatically configured.
                                </div>
                            </div>
                        </div>

                        <div class="section">
                            <h2>Site Information</h2>
                            <label for="siteName">Site Name (e.g., HALLETTSVILLE-NW-1):</label>
                            <input type="text" id="siteName" placeholder="HALLETTSVILLE-NW-1">
                            <label for="routerId">Router ID/Loopback IP (e.g., 10.25.0.46):</label>
                            <input type="text" id="routerId" placeholder="10.25.0.46">
                            <label for="systemName">System Identity (auto-fills):</label>
                            <input type="text" id="systemName" placeholder="RTR-MTCCR2004-1">
                            <div id="lanBridgeSection">
                                <label for="lanBridgeIP">LAN Bridge IP/Net (e.g., 10.45.40.1/22):</label>
                                <input type="text" id="lanBridgeIP" placeholder="10.45.40.1/22">
                            </div>
                            <div id="natPublicSection">
                                <label for="natPublicIP">NAT Public IP (e.g., 142.147.123.163):</label>
                                <input type="text" id="natPublicIP" placeholder="142.147.123.163">
                            </div>
                            <div class="form-group">
                                <label for="siteLatitude">Site Latitude (e.g., 29.08256):</label>
                                <input type="text" id="siteLatitude" placeholder="29.08256">
                            </div>
                            <div class="form-group">
                                <label for="siteLongitude">Site Longitude (e.g., -96.72243):</label>
                                <input type="text" id="siteLongitude" placeholder="-96.72243">
                            </div>
                        </div>


                        <div class="section">
                            <h2>Device Selection</h2>
                            <div class="device-selection-grid">
                                <!-- Hidden: current device is not needed for New Device configs.
                     Kept for backward-compatibility with any JS that still reads it. -->
                                <div style="display:none;">
                                    <label for="currentDevice">Current Device (optional):</label>
                                    <select id="currentDevice">
                                        <option value="">Select Current Device</option>
                                        <option value="rb1009">RB1009 (RouterOS 6.x/7.x)</option>
                                        <option value="rb2011">RB2011 (RouterOS 6.x/7.x)</option>
                                        <option value="ccr1036">CCR1036 (RouterOS 6.x/7.x)</option>
                                        <option value="ccr1072">CCR1072 (RouterOS 6.x/7.x)</option>
                                        <option value="rb5009">RB5009 (RouterOS 7.x)</option>
                                        <option value="ccr2004">CCR2004 (RouterOS 7.x)</option>
                                        <option value="ccr2116">CCR2116 (RouterOS 7.x)</option>
                                        <option value="ccr2216">CCR2216 (RouterOS 7.x)</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="targetDevice">Target Device (Upgrade To):</label>
                                    <select id="targetDevice" onchange="updateInterfacesForMigration()">
                                        <option value="">Select Target Device</option>
                                        <option value="CCR1036-12G-4S">CCR1036-12G-4S (12 Ethernet, 4 SFP)</option>
                                        <option value="CCR2004-1G-12S+2XS">CCR2004-1G-12S+2XS (12 SFP+, 2 XS, 1
                                            Ethernet)</option>
                                        <option value="CCR2004-16G-2S+">CCR2004-16G-2S+ (16 Ethernet, 2 SFP+)</option>
                                        <option value="CCR2116-12G-4S+">CCR2116-12G-4S+ (12 Ethernet, 4 SFP+)</option>
                                        <option value="CCR2216-1G-12XS-2XQ">CCR2216-1G-12XS-2XQ (12 SFP28, 2 QSFP28, 1
                                            Ethernet)</option>
                                        <option value="CRS326-24G-2S+">CRS326-24G-2S+ (24 Ethernet, 2 SFP+)</option>
                                        <option value="CRS354-48G-4S+2Q+">CRS354-48G-4S+2Q+ (48 Ethernet, 4 SFP+, 2
                                            QSFP+)</option>
                                        <option value="rb5009">RB5009</option>
                                        <option value="rb1009">RB1009</option>
                                        <option value="rb2011">RB2011</option>
                                    </select>
                                </div>
                                <!-- Hidden: current RouterOS version not needed for New Device configs -->
                                <div style="display:none;">
                                    <label for="currentRouterOS">Current RouterOS Version (pre-7.12 only):</label>
                                    <select id="currentRouterOS">
                                        <option value="">Select Version</option>
                                        <option value="6.45.2">6.45.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="6.49.2">6.49.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="7.11.2">7.11.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="7.16.2">7.16.2 (7.12+ Speed Syntax)</option>
                                        <option value="7.19.4">7.19.4 (7.12+ Speed Syntax)</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="targetRouterOS">Target RouterOS Version:</label>
                                    <select id="targetRouterOS">
                                        <option value="">Select Version</option>
                                        <option value="6.45.2">6.45.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="6.49.2">6.49.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="7.11.2">7.11.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="7.16.2">7.16.2 (7.12+ Speed Syntax)</option>
                                        <option value="7.19.4">7.19.4 (7.12+ Speed Syntax)</option>
                                    </select>
                                </div>
                            </div>
                            <!-- Device-specific features are handled in backend via DEVICE_CONFIGS; UI copy removed to reduce noise -->
                        </div>
                        <div class="section">
                            <h2>Routing (OSPF/BGP - Uses Router ID)</h2>
                            <label for="ospfArea">OSPF Area:</label>
                            <select id="ospfArea">
                                <option value="backbone-v2">backbone-v2 (BGP + OSPF)</option>
                                <option value="backbone-v2-IL">backbone-v2 IL (MPLS/VPLS)</option>
                                <option value="area243-v2">area243-v2 (MPLS/VPLS)</option>
                                <option value="area248-v2">area248-v2 (MPLS/VPLS)</option>
                                <option value="area249">area249 (MPLS/VPLS)</option>
                                <option value="area250">area250 (MPLS/VPLS)</option>
                                <option value="area42-v2">area42-v2 (MPLS/VPLS)</option>
                                <option value="area42">area42 (MPLS/VPLS)</option>
                                <option value="custom">Custom Area</option>
                            </select>
                            <input type="text" id="ospfAreaCustom" style="display:none;"
                                placeholder="Enter custom area name">
                            <label for="ospfAreaId">OSPF Area ID (auto-filled):</label>
                            <input type="text" id="ospfAreaId" value="0.0.0.0" readonly>
                            <div id="bgpSection">
                                <label for="bgpPeers">BGP Peers JSON (e.g.,
                                    [{"name":"CR7","remote":"10.2.0.107/32"}]):</label>
                                <textarea id="bgpPeers"
                                    rows="3">[{"name":"CR7","remote":"10.2.0.107/32"},{"name":"CR8","remote":"10.2.0.108/32"}]</textarea>
                                <label for="bgpAS">BGP Local AS (e.g., 26077):</label>
                                <input type="text" id="bgpAS" value="26077">
                            </div>
                        </div>

                        <div class="section">
                            <h2>Optional Features</h2>
                            <div class="features">
                                <label><input type="checkbox" id="enableTarana"> Enable Tarana Ports</label>
                                <label><input type="checkbox" id="enableSWT"> Enable SWT (VLAN 4000)</label>
                                <label><input type="checkbox" id="enableVPLS"> Enable VPLS Tunnels</label>
                                <label><input type="checkbox" id="enableMPLS"> Enable MPLS/LDP</label>
                                <label><input type="checkbox" id="enableDHCP"> Enable DHCP Server (backbone-v2
                                    only)</label>
                            </div>
                            <div id="vlanSection" class="dhcp-section" style="display:none;">
                                <div>
                                    <label for="vlan3000Subnet">VLAN 3000 Subnet (Tarana, CIDR e.g.,
                                        10.25.34.0/28):</label>
                                    <input type="text" id="vlan3000Subnet">
                                </div>
                                <div>
                                    <label for="vlan4000Subnet">VLAN 4000 Subnet (SWT, CIDR e.g., 10.10.9.0/22):</label>
                                    <input type="text" id="vlan4000Subnet">
                                </div>
                            </div>
                            <div id="taranaSection" class="dhcp-section" style="display:none;">
                                <div
                                    style="background: #2a4a2a; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                                    <h3 style="margin-top: 0; color: #4CAF50;">Tarana Sector Configuration Generator
                                    </h3>
                                    <div
                                        style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-bottom: 10px; align-items:start;">
                                        <div>
                                            <label for="tower_tarana_alpha">ALPHA Port:</label>
                                            <select id="tower_tarana_alpha">
                                                <option value="sfp-sfpplus6">sfp-sfpplus6</option>
                                                <option value="sfp-sfpplus7">sfp-sfpplus7</option>
                                                <option value="sfp-sfpplus8">sfp-sfpplus8</option>
                                                <option value="sfp-sfpplus9">sfp-sfpplus9</option>
                                            </select>
                                            <div style="margin-top:6px; display:flex; gap:6px;">
                                                <select id="tower_tarana_alpha_speed" style="width:60%;">
                                                    <option value="10G-baseCR">10G-baseCR</option>
                                                    <option value="10G-baseSR-LR">10G-baseSR/LR</option>
                                                    <option value="1G-baseT-full">1G-baseT-full</option>
                                                    <option value="auto">Auto-Negotiate</option>
                                                </select>
                                                <input type="number" id="tower_tarana_alpha_mtu" placeholder="MTU"
                                                    min="1500" value="1500" style="width:40%;">
                                            </div>
                                        </div>
                                        <div>
                                            <label for="tower_tarana_beta">BETA Port:</label>
                                            <select id="tower_tarana_beta">
                                                <option value="sfp-sfpplus6">sfp-sfpplus6</option>
                                                <option value="sfp-sfpplus7">sfp-sfpplus7</option>
                                                <option value="sfp-sfpplus8">sfp-sfpplus8</option>
                                                <option value="sfp-sfpplus9">sfp-sfpplus9</option>
                                            </select>
                                            <div style="margin-top:6px; display:flex; gap:6px;">
                                                <select id="tower_tarana_beta_speed" style="width:60%;">
                                                    <option value="10G-baseCR">10G-baseCR</option>
                                                    <option value="10G-baseSR-LR">10G-baseSR/LR</option>
                                                    <option value="1G-baseT-full">1G-baseT-full</option>
                                                    <option value="auto">Auto-Negotiate</option>
                                                </select>
                                                <input type="number" id="tower_tarana_beta_mtu" placeholder="MTU"
                                                    min="1500" value="1500" style="width:40%;">
                                            </div>
                                        </div>
                                        <div>
                                            <label for="tower_tarana_gamma">GAMMA Port:</label>
                                            <select id="tower_tarana_gamma">
                                                <option value="sfp-sfpplus6">sfp-sfpplus6</option>
                                                <option value="sfp-sfpplus7">sfp-sfpplus7</option>
                                                <option value="sfp-sfpplus8">sfp-sfpplus8</option>
                                                <option value="sfp-sfpplus9">sfp-sfpplus9</option>
                                            </select>
                                            <div style="margin-top:6px; display:flex; gap:6px;">
                                                <select id="tower_tarana_gamma_speed" style="width:60%;">
                                                    <option value="10G-baseCR">10G-baseCR</option>
                                                    <option value="10G-baseSR-LR">10G-baseSR/LR</option>
                                                    <option value="1G-baseT-full">1G-baseT-full</option>
                                                    <option value="auto">Auto-Negotiate</option>
                                                </select>
                                                <input type="number" id="tower_tarana_gamma_mtu" placeholder="MTU"
                                                    min="1500" value="1500" style="width:40%;">
                                            </div>
                                        </div>
                                        <div>
                                            <label for="tower_tarana_delta">DELTA Port (optional):</label>
                                            <select id="tower_tarana_delta">
                                                <option value="">None</option>
                                                <option value="sfp-sfpplus6">sfp-sfpplus6</option>
                                                <option value="sfp-sfpplus7">sfp-sfpplus7</option>
                                                <option value="sfp-sfpplus8">sfp-sfpplus8</option>
                                                <option value="sfp-sfpplus9">sfp-sfpplus9</option>
                                            </select>
                                            <div style="margin-top:6px; display:flex; gap:6px;">
                                                <select id="tower_tarana_delta_speed" style="width:60%;">
                                                    <option value="10G-baseCR">10G-baseCR</option>
                                                    <option value="10G-baseSR-LR">10G-baseSR/LR</option>
                                                    <option value="1G-baseT-full">1G-baseT-full</option>
                                                    <option value="auto">Auto-Negotiate</option>
                                                </select>
                                                <input type="number" id="tower_tarana_delta_mtu" placeholder="MTU"
                                                    min="1500" value="1500" style="width:40%;">
                                            </div>
                                        </div>
                                    </div>

                                    <div style="margin-bottom: 10px;">
                                        <label for="tower_unicornmgmt_subnet">UNICORNMGMT Subnet (CIDR):</label>
                                        <input type="text" id="tower_unicornmgmt_subnet"
                                            placeholder="e.g., 10.246.25.48/29" style="width: 50%;">
                                        <div style="font-size: 12px; color: #ddd; margin-top: 6px;">Router IP = first
                                            usable in the subnet.</div>
                                    </div>

                                    <div style="display:flex; gap:10px; margin-top:8px;">
                                        <div style="font-size:12px; color:#ddd; align-self:center;">(Tarana fragment
                                            included automatically in the full generated config when 'Enable Tarana
                                            Ports' is checked)</div>
                                    </div>
                                </div>

                                <div style="color: var(--text-color); font-size: 14px; margin-top: 10px;">
                                    <strong>Note:</strong> This generator creates the bridge, ethernet sets, VLAN
                                    interfaces (1000/2000/3000), bridge-port mappings and a management IP on UNICORNMGMT
                                    plus a basic OSPF interface-template entry.
                                </div>

                                <!-- preview removed: Tarana fragment generated automatically with full config -->
                            </div>
                        </div>
                        <div class="section dhcp-section" id="dhcpSection" style="display:none;">
                            <h2>DHCP Configuration (backbone-v2 BGP/OSPF Areas Only)</h2>
                            <div class="dhcp-note">
                                <strong>Note:</strong> DHCP is only used in backbone-v2 areas with BGP/OSPF. Other areas
                                (MPLS/VPLS) use BNGs for subscriber management.
                            </div>
                            <div class="dhcp-section" style="margin-bottom: 15px;">
                                <div>
                                    <label for="cgnatRange">CGNAT Private Range (100.x.x.x/22, e.g.,
                                        100.64.112.0/22):</label>
                                    <input type="text" id="cgnatRange" placeholder="100.64.112.0/22">
                                </div>
                                <div>
                                    <label for="cpeRange">CPE Range (10.x.x.x/22, auto-calculated from LAN
                                        Bridge):</label>
                                    <input type="text" id="cpeRange" readonly
                                        placeholder="Auto-filled from LAN Bridge IP">
                                </div>
                            </div>
                            <div class="dhcp-section">
                                <div>
                                    <label for="unauthRange">Unauth Range (10.1xx.x.x/22, auto-calculated):</label>
                                    <input type="text" id="unauthRange" readonly
                                        placeholder="Auto-calculated from CPE range">
                                </div>
                                <div>
                                    <label for="vlan4000Range">VLAN 4000 Range (if SWT enabled,
                                        auto-calculated):</label>
                                    <input type="text" id="vlan4000Range" readonly
                                        placeholder="Auto-calculated from VLAN 4000 subnet">
                                </div>
                            </div>
                        </div>

                        <div class="section vpls-section">
                            <h2>VPLS Configuration</h2>
                            <p>Configure VPLS tunnels for BNG connectivity.</p>
                            <div id="vplsInstances">
                                <div class="vpls-item" style="display:none;" id="vplsTemplate">
                                    <div class="vpls-grid">
                                        <div><label for="vpls2Name">VPLS Name:</label><input type="text" name="vplsName"
                                                id="vpls2Name"></div>
                                        <div><label for="vpls2Bridge">Bridge:</label><input type="text"
                                                name="vplsBridge" id="vpls2Bridge"></div>
                                        <div><label for="vpls2Peer">Peer IP:</label><input type="text" name="vplsPeer"
                                                id="vpls2Peer"></div>
                                        <div><label for="vpls2StaticId">Cisco Static ID:</label><input type="number"
                                                name="vplsStaticId" id="vpls2StaticId"></div>
                                    </div>
                                    <button class="remove-btn"
                                        onclick="this.closest('.vpls-item').remove(); updateVplsCount();">Remove</button>
                                </div>
                            </div>
                            <div class="vpls-buttons">
                                <button id="addVplsBtn">Add VPLS Instance</button>
                            </div>
                        </div>

                        <div class="section">
                            <h2>Port & Uplink Configuration</h2>
                            <p style="margin-bottom: 15px;">Configure ports with IP addresses for OSPF routing, bridge
                                assignment, or switch mode. The tool automatically handles OSPF templates, IP
                                addressing, and MPLS LDP configuration.</p>
                            <!-- Combined Port/Uplink Configuration -->
                            <div id="portConfigs">
                                <!-- First Port/Uplink Entry -->
                                <div class="uplink-item" id="portUplink1">
                                    <div class="uplink-grid" style="grid-template-columns: repeat(7, 1fr); gap: 10px;">
                                        <div>
                                            <label for="portUplink1Port" id="portUplink1PortLabel">Port:</label>
                                            <select id="portUplink1Port" name="portUplinkPort">
                                                <option value="sfp-sfpplus1">sfp-sfpplus1</option>
                                                <option value="sfp-sfpplus2">sfp-sfpplus2</option>
                                                <option value="sfp-sfpplus3">sfp-sfpplus3</option>
                                                <option value="sfp-sfpplus4">sfp-sfpplus4</option>
                                                <option value="sfp-sfpplus5">sfp-sfpplus5</option>
                                                <option value="sfp-sfpplus6">sfp-sfpplus6</option>
                                                <option value="sfp-sfpplus7">sfp-sfpplus7</option>
                                                <option value="sfp-sfpplus8">sfp-sfpplus8</option>
                                                <option value="sfp-sfpplus9">sfp-sfpplus9</option>
                                                <option value="sfp-sfpplus10">sfp-sfpplus10</option>
                                                <option value="sfp-sfpplus11">sfp-sfpplus11</option>
                                                <option value="sfp-sfpplus12">sfp-sfpplus12</option>
                                                <option value="sfp28-1">sfp28-1</option>
                                                <option value="sfp28-2">sfp28-2</option>
                                                <option value="ether1">ether1 (Mgmt)</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="portUplink1Type">Type:</label>
                                            <select id="portUplink1Type" name="portUplinkType"
                                                onchange="handlePortTypeChange(this)">
                                                <option value="routed">Routed (OSPF)</option>
                                                <option value="bridge">Bridge</option>
                                                <option value="switch">Switch</option>
                                            </select>
                                        </div>
                                        <div id="portUplink1IpContainer">
                                            <label for="portUplink1Ip">IP/Net (OSPF):</label>
                                            <input type="text" id="portUplink1Ip" name="portUplinkIp"
                                                placeholder="10.36.1.53/30">
                                        </div>
                                        <div id="portUplink1BridgeContainer" style="display:none;">
                                            <label for="portUplink1Bridge">Bridge:</label>
                                            <select id="portUplink1Bridge" name="portUplinkBridge">
                                                <option value="lan-bridge">lan-bridge</option>
                                                <option value="bridge1000">bridge1000</option>
                                                <option value="bridge2000">bridge2000</option>
                                                <option value="bridge3000">bridge3000</option>
                                                <option value="bridge4000">bridge4000</option>
                                                <option value="nat-public-bridge">nat-public-bridge</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="portUplink1Speed">Speed:</label>
                                            <select id="portUplink1Speed" name="portUplinkSpeed">
                                                <option value="auto">Auto</option>
                                                <option value="1Gbps">1Gbps</option>
                                                <option value="10Gbps">10Gbps</option>
                                                <option value="1G-baseT-full">1G-baseT-full</option>
                                                <option value="1G-baseX">1G-baseX</option>
                                                <option value="10G-baseSR-LR">10G-baseSR/LR</option>
                                                <option value="10G-baseCR">10G-baseCR</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="portUplink1Comment">Comment:</label>
                                            <input type="text" id="portUplink1Comment" name="portUplinkComment"
                                                placeholder="TX-LAGRANGE-FC-1">
                                        </div>
                                        <div id="portUplink1CostContainer">
                                            <label for="portUplink1Cost">OSPF Cost:</label>
                                            <input type="number" id="portUplink1Cost" name="portUplinkCost"
                                                placeholder="10" min="1" value="10">
                                        </div>
                                    </div>
                                </div>
                                <!-- Template for additional ports (hidden) -->
                                <div class="uplink-item" style="display:none;" id="portUplinkTemplate">
                                    <div class="uplink-grid" style="grid-template-columns: repeat(7, 1fr); gap: 10px;">
                                        <div><label>Port:</label><select name="portUplinkPort"></select></div>
                                        <div><label>Type:</label><select name="portUplinkType"
                                                onchange="handlePortTypeChange(this)">
                                                <option value="routed">Routed (OSPF)</option>
                                                <option value="bridge">Bridge</option>
                                                <option value="switch">Switch</option>
                                            </select></div>
                                        <div class="portUplinkIpContainer"><label>IP/Net:</label><input type="text"
                                                name="portUplinkIp" placeholder="10.36.1.53/30"></div>
                                        <div class="portUplinkBridgeContainer" style="display:none;">
                                            <label>Bridge:</label><select name="portUplinkBridge">
                                                <option value="lan-bridge">lan-bridge</option>
                                                <option value="bridge1000">bridge1000</option>
                                                <option value="bridge2000">bridge2000</option>
                                                <option value="bridge3000">bridge3000</option>
                                                <option value="bridge4000">bridge4000</option>
                                                <option value="nat-public-bridge">nat-public-bridge</option>
                                            </select>
                                        </div>
                                        <div><label>Speed:</label><select name="portUplinkSpeed">
                                                <option value="auto">Auto</option>
                                                <option value="1Gbps">1Gbps</option>
                                                <option value="10Gbps">10Gbps</option>
                                                <option value="1G-baseT-full">1G-baseT-full</option>
                                                <option value="1G-baseX">1G-baseX</option>
                                                <option value="10G-baseSR-LR">10G-baseSR/LR</option>
                                                <option value="10G-baseCR">10G-baseCR</option>
                                            </select></div>
                                        <div><label>Comment:</label><input type="text" name="portUplinkComment"
                                                placeholder="TX-LAGRANGE-FC-1"></div>
                                        <div class="portUplinkCostContainer"><label>OSPF Cost:</label><input
                                                type="number" name="portUplinkCost" placeholder="10" min="1" value="10">
                                        </div>
                                    </div>
                                    <button class="remove-btn"
                                        onclick="this.closest('.uplink-item').remove(); updatePortUplinkCount();">Remove</button>
                                </div>
                            </div>
                            <div class="uplink-buttons">
                                <button id="addPortUplinkBtn">Add Port/Uplink</button>
                                <button type="button" id="btnAutoPopulateNetonix">Auto-populate Switch Uplinks (1,2 @
                                    1Gbps)</button>
                            </div>
                            <div
                                style="margin-top: 15px; padding: 10px; background: #2a4a2a; border-radius: 5px; font-size: 14px;">
                                <strong>Auto-Configuration:</strong> When you configure ports:
                                <ul style="margin: 5px 0; padding-left: 20px;">
                                    <li><strong>Routed (OSPF):</strong> Automatically assigns IP, creates OSPF interface
                                        template with correct network matching the IP, includes in MPLS LDP (if enabled)
                                    </li>
                                    <li><strong>Bridge:</strong> Assigns port to selected bridge, configures bridge port
                                        settings</li>
                                    <li><strong>Switch:</strong> Configures as switch port (no OSPF, no IP)</li>
                                </ul>
                                <strong>Note:</strong> Unused SFP ports will be automatically disabled for security.
                            </div>
                        </div>

                        <div class="section">
                            <h2>VLAN Interfaces</h2>
                            <p>Create VLAN interfaces on physical interfaces.</p>
                            <div class="dhcp-section" style="margin-bottom: 15px;">
                                <div>
                                    <label for="vlanProfile">VLAN Profile:</label>
                                    <select id="vlanProfile">
                                        <option value="">Custom</option>
                                        <option value="nonvpls">Non-VPLS (1000lan-bridge, 2000,3000,4000)</option>
                                        <option value="vpls">VPLS Standard (1000,2000,3000,4000)</option>
                                    </select>
                                </div>
                                <div style="display: flex; align-items: end;">
                                    <button type="button" id="btnPopulateVlans">Auto-populate VLANs</button>
                                </div>
                            </div>
                            <div id="vlanInterfaces">
                                <div class="vlan-item" style="display:none;" id="vlanTemplate">
                                    <div class="vlan-grid">
                                        <div><label for="vlan2Parent">Parent Interface:</label><select name="vlanParent"
                                                id="vlan2Parent">
                                                <option value="sfp-sfpplus1">sfp-sfpplus1</option>
                                                <option value="sfp-sfpplus2">sfp-sfpplus2</option>
                                                <option value="sfp-sfpplus6">sfp-sfpplus6</option>
                                                <option value="sfp-sfpplus8">sfp-sfpplus8</option>
                                                <option value="sfp-sfpplus9">sfp-sfpplus9</option>
                                                <option value="sfp-sfpplus10">sfp-sfpplus10</option>
                                                <option value="bonding1">bonding1</option>
                                            </select></div>
                                        <div><label for="vlan2Id">VLAN ID:</label><input type="number" name="vlanId"
                                                id="vlan2Id" min="1" max="4094"></div>
                                        <div><label for="vlan2Comment">Comment:</label><input type="text"
                                                name="vlanComment" id="vlan2Comment"></div>
                                        <div><label for="vlan2Bridge">Bridge Assignment:</label><input type="text"
                                                name="vlanBridge" id="vlan2Bridge"></div>
                                    </div>
                                    <button class="remove-btn"
                                        onclick="this.closest('.vlan-item').remove(); updateVlanCount();">Remove</button>
                                </div>
                            </div>
                            <div class="uplink-buttons">
                                <button id="addVlanBtn">Add VLAN Interface</button>
                            </div>
                        </div>

                        <div class="section mpls-section">
                            <h2>MPLS/LDP Configuration</h2>
                            <label for="mplsMtu">MPLS MTU (default 9000):</label>
                            <input type="number" id="mplsMtu" value="9000" min="1500" max="9000">
                            <label for="ldpTransport">LDP Transport Address (usually Router ID):</label>
                            <input type="text" id="ldpTransport" value="10.25.0.46">
                        </div>

                        <div class="section" style="display: none;">
                            <h2>Backhaul Uplinks (IPs auto to ports/OSPF) - DEPRECATED: Use Port & Uplink Configuration
                                above</h2>
                            <p id="uplinksDescription">Up to 4; generates ethernet sets, /ip address, OSPF templates
                                (ptp type). Uses sfp4+ downwards.</p>
                            <div style="background: #2a4a2a; padding: 10px; border-radius: 5px; margin-bottom: 15px;">
                                <strong>Auto-Configuration:</strong> When you add uplinks here, the tool will
                                automatically:
                                <ul style="margin: 5px 0; padding-left: 20px;">
                                    <li>Assign IP addresses to the ports</li>
                                    <li>Configure OSPF interface templates with proper authentication</li>
                                    <li>Include in MPLS LDP configuration (if MPLS enabled)</li>
                                </ul>
                                <strong>Note:</strong> Interface speed and comments are configured in the "Port
                                Configuration" section below to avoid duplication.
                            </div>
                            <div id="uplinks">
                                <div class="uplink-item" id="uplink1">
                                    <div class="uplink-grid">
                                        <div>
                                            <label for="uplink1NewPort" id="uplink1NewPortLabel">New Port:</label>
                                            <select id="uplink1NewPort">
                                                <option value="sfp-sfpplus4">sfp-sfpplus4</option>
                                                <option value="sfp-sfpplus5">sfp-sfpplus5</option>
                                                <option value="sfp-sfpplus6">sfp-sfpplus6</option>
                                                <option value="sfp-sfpplus7">sfp-sfpplus7</option>
                                                <option value="sfp-sfpplus8">sfp-sfpplus8</option>
                                                <option value="sfp-sfpplus9">sfp-sfpplus9</option>
                                                <option value="sfp-sfpplus10">sfp-sfpplus10</option>
                                                <option value="sfp-sfpplus11">sfp-sfpplus11</option>
                                                <option value="sfp-sfpplus12">sfp-sfpplus12</option>
                                                <option value="sfp28-1">sfp28-1</option>
                                                <option value="sfp28-2">sfp28-2</option>
                                                <option value="ether1">ether1 (Mgmt)</option>
                                            </select>
                                        </div>
                                        <div>
                                            <label for="uplink1Ip">Backhaul IP/Net (e.g., 10.36.1.53/30):</label>
                                            <input type="text" id="uplink1Ip" placeholder="10.36.1.53/30">
                                        </div>
                                        <div>
                                            <label for="uplink1Comment">Comment (e.g., TX-LAGRANGE-FC-1):</label>
                                            <input type="text" id="uplink1Comment" placeholder="TX-LAGRANGE-FC-1">
                                        </div>
                                        <div>
                                            <label for="uplink1Cost">OSPF Cost (default 10):</label>
                                            <input type="number" id="uplink1Cost" placeholder="10" min="1">
                                        </div>
                                    </div>
                                </div>
                                <div class="uplink-item" style="display:none;" id="uplinkTemplate">
                                    <div class="uplink-grid">
                                        <div><label for="uplink2NewPort">New Port:</label><select
                                                id="uplink2NewPort"></select></div>
                                        <div><label for="uplink2Ip">IP/Net:</label><input type="text" id="uplink2Ip">
                                        </div>
                                        <div><label for="uplink2Comment">Comment:</label><input type="text"
                                                id="uplink2Comment"></div>
                                        <div><label for="uplink2Cost">OSPF Cost:</label><input type="number"
                                                id="uplink2Cost" value="10" min="1"></div>
                                    </div>
                                    <button class="remove-btn"
                                        onclick="this.closest('.uplink-item').remove(); updateUplinkCount();">Remove</button>
                                </div>
                            </div>
                            <div class="uplink-buttons">
                                <button id="addUplinkBtn">Add Uplink</button>
                            </div>
                        </div>

                        <div class="section" style="display: none;">
                            <h2>Static Customer Management</h2>
                            <p>Add static customer IP ranges that will be automatically included in firewall address
                                lists for proper routing and access control.</p>
                            <div id="staticCustomers">
                                <div class="customer-item" style="display:none;" id="customerTemplate">
                                    <div class="customer-grid">
                                        <div><label for="customer2Name">Customer Name:</label><input type="text"
                                                name="customerName" id="customer2Name" placeholder="Customer ABC"></div>
                                        <div><label for="customer2Range">IP Range:</label><input type="text"
                                                name="customerRange" id="customer2Range" placeholder="192.168.100.0/24">
                                        </div>
                                        <div><label for="customer2Comment">Comment:</label><input type="text"
                                                name="customerComment" id="customer2Comment"
                                                placeholder="Static customer network"></div>
                                    </div>
                                    <button class="remove-btn"
                                        onclick="this.closest('.customer-item').remove(); updateCustomerCount();">Remove</button>
                                </div>
                            </div>
                            <div class="customer-buttons">
                                <button id="addCustomerBtn">Add Static Customer</button>
                            </div>
                            <div style="background: #2a2a4a; padding: 10px; border-radius: 5px; margin-top: 10px;">
                                <strong>Note:</strong> Static customers will be automatically added to firewall address
                                lists for proper routing and access control.
                            </div>
                        </div>

                        <!-- Hidden: Keys & Settings (handled automatically by backend) -->
                        <div class="section" style="display: none;">
                            <h2>Keys & Settings</h2>
                            <label for="sharedKey">Shared Key (OSPF/BGP MD5):</label>
                            <input type="text" id="sharedKey" value="" placeholder="Enter OSPF/BGP MD5 shared key">
                            <label for="snmpCommunity">SNMP Community:</label>
                            <input type="text" id="snmpCommunity" value="" placeholder="Enter SNMP community">
                            <label for="dhcpSecret">DHCP Secret:</label>
                            <input type="text" id="dhcpSecret" placeholder="Enter DHCP secret" value="">
                            <label for="dnsServers">DNS Servers (comma-separated, NextLink DNS servers):</label>
                            <input type="text" id="dnsServers" value=""
                                placeholder="Enter DNS servers (comma-separated)">
                        </div>

                        <div class="generate-section">
                            <button id="generateBtn" onclick="generateConfig()">Generate Config Script</button>
                        </div>

                        <div class="section">
                            <h2>Generated Configuration</h2>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <h3 style="color: #4CAF50; margin-bottom: 10px;"> Configuration Metadata &
                                        Comments</h3>
                                    <textarea id="metadataOutput" readonly
                                        placeholder="Configuration metadata and comments will appear here..."
                                        style="height: 300px; font-family: 'Courier New', monospace; font-size: 12px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #555; padding: 10px; border-radius: 4px;"></textarea>
                                </div>
                                <div>
                                    <h3 style="color: #2196F3; margin-bottom: 10px;"> Router Commands (.rsc)</h3>
                                    <textarea id="output" readonly placeholder="Router commands will appear here..."
                                        style="height: 300px; font-family: 'Courier New', monospace; font-size: 12px; background: #2a2a2a; color: #e0e0e0; border: 1px solid #555; padding: 10px; border-radius: 4px;"></textarea>
                                </div>
                            </div>
                            <button id="downloadBtn" onclick="downloadConfig()"
                                style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px;">Download
                                .rsc File</button>
                            <button id="portMapBtn" onclick="downloadPortMap()"
                                style="background: #1f6feb; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; margin-left: 10px;">Download
                                Port Map</button>
                            <button id="zipDownloadBtn" onclick="downloadConfigZip()"
                                style="background: #ff8f1f; color: #1a1a1a; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; font-size: 16px; margin-left: 10px;">Download
                                Zip (Config + Port Map)</button>
                        </div>
                    </div>
                    <!-- End mainForm -->
                </div>
            </div>

            <!-- ENTERPRISE CONFIG TAB -->
            <div class="content-pane" id="enterprise-pane">
                <div class="container">
                    <div class="enterprise-testing-banner"> PRODUCTION READY - Non-MPLS Enterprise Configuration -
                        Nextlink Policy Compliant</div>
                    <h1> Non-MPLS Enterprise Configuration Generator</h1>
                    <p style="text-align: center; color: var(--text-color);">Nextlink-compliant enterprise customer
                        configuration with standardized port assignments and simplified IP routing (no MPLS/BGP/OSPF).
                    </p>
                    <p
                        style="text-align: center; color: var(--text-color-secondary); font-size: 14px; margin-top: 10px;">
                         <a href="javascript:void(0);" onclick="togglePolicyReference();"
                            style="color: #FF9800; text-decoration: underline;">View Policy Reference</a> for port
                        assignments and configuration details.</p>
                    <!-- Mode Toggle: AI default with Advanced manual fallback -->
                    <div id="ent_modeToggleBar"
                        style="display:flex; align-items:center; gap:12px; justify-content:center; margin:10px 0 20px 0;">
                        <span style="color: var(--text-color); font-weight: 600;">Mode:</span>
                        <span style="padding:4px 8px; background:#1f3b2e; color:#7ee2a8; border-radius:4px;">AI
                            (recommended)</span>
                        <label
                            style="display:flex; align-items:center; gap:8px; color: var(--text-color); cursor:pointer;">
                            <input type="checkbox" id="ent_advanced_toggle">
                            <span>Advanced (manual)</span>
                        </label>
                    </div>

                    <!-- Device Information -->
                    <div class="section">
                        <h2>Device Information</h2>

                        <!-- RouterBoard + RouterOS (kept visible in AI mode) -->
                        <div id="ent_manual_device_group"
                            style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div>
                                <label for="ent_routerboard_device">RouterBoard Device:</label>
                                <div class="form-group">
                                    <label for="targetDevice">Target Device:</label>
                                    <select id="targetDevice" class="form-control">
                                        <option value="CCR1036-12G-4S">CCR1036-12G-4S (12 Ethernet, 4 SFP)</option>
                                        <option value="CCR2004-1G-12S+2XS">CCR2004-1G-12S+2XS (12 SFP+, 2 XS, 1
                                            Ethernet)</option>
                                        <option value="CCR2004-16G-2S+">CCR2004-16G-2S+ (16 Ethernet, 2 SFP+)</option>
                                        <option value="CCR2116-12G-4S+">CCR2116-12G-4S+ (12 Ethernet, 4 SFP+)</option>
                                        <option value="CCR2216-1G-12XS-2XQ">CCR2216-1G-12XS-2XQ (12 SFP28, 2 QSFP28, 1
                                            Ethernet)</option>
                                        <option value="CRS326-24G-2S+">CRS326-24G-2S+ (24 Ethernet, 2 SFP+)</option>
                                        <option value="CRS354-48G-4S+2Q+">CRS354-48G-4S+2Q+ (48 Ethernet, 4 SFP+, 2
                                            QSFP+)</option>
                                    </select>
                                </div>
                                <select id="ent_routerboard_device"
                                    onchange="updateDeviceName(); updateEnterpriseInterfaces();">
                                    <option value="CCR1036-12G-4S">CCR1036-12G-4S (12 Ethernet, 4 SFP)</option>
                                    <option value="CCR2004-1G-12S+2XS">CCR2004-1G-12S+2XS (12 SFP+, 2 XS, 1 Ethernet)
                                    </option>
                                    <option value="CCR2004-16G-2S+">CCR2004-16G-2S+ (16 Ethernet, 2 SFP+)</option>
                                    <option value="CCR2116-12G-4S+">CCR2116-12G-4S+ (12 Ethernet, 4 SFP+)</option>
                                    <option value="CCR2216-1G-12XS-2XQ">CCR2216-1G-12XS-2XQ (12 SFP28, 2 QSFP28, 1
                                        Ethernet)</option>
                                    <option value="CRS326-24G-2S+">CRS326-24G-2S+ (24 Ethernet, 2 SFP+)</option>
                                    <option value="CRS354-48G-4S+2Q+">CRS354-48G-4S+2Q+ (48 Ethernet, 4 SFP+, 2 QSFP+)
                                    </option>
                                    <option value="ccr2216">CCR2216</option>
                                </select>
                            </div>
                            <div>
                                <label for="ent_routeros_version">RouterOS Version:</label>
                                <select id="ent_routeros_version">
                                    <option value="">Select RouterOS Version</option>
                                    <option value="7.16.2" selected>7.16.2 (Stable) - Recommended</option>
                                    <option value="7.19.4">7.19.4 (Latest)</option>
                                    <option value="7.11.2">7.11.2</option>
                                    <option value="6.49.2">6.49.2</option>
                                </select>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div style="display:none;" aria-hidden="true">
                                <label for="ent_deviceType">Device Type:</label>
                                <select id="ent_deviceType">
                                    <option value="CCR2004">CCR2004</option>
                                    <option value="CCR1036">CCR1036</option>
                                    <option value="RB5009">RB5009</option>
                                    <option value="CCR2216">CCR2216</option>
                                </select>
                            </div>
                            <div>
                                <label for="ent_customerCode">Customer Code (e.g.,
                                    NX-495635-Bureau-Veritas-Goody-Solar):</label>
                                <input type="text" id="ent_customerCode"
                                    placeholder="NX-495635-Bureau-Veritas-Goody-Solar" oninput="updateDeviceName()">
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px;">
                            <div>
                                <label for="ent_deviceName">Device Name (auto-fills):</label>
                                <input type="text" id="ent_deviceName" placeholder="RTR-MTCCR2004.NX-431940" readonly
                                    style="background: var(--output-bg);">
                            </div>
                            <div>
                                <label for="ent_loopbackIP">Loopback IP (e.g., 10.3.0.242):</label>
                                <input type="text" id="ent_loopbackIP" placeholder="10.3.0.242">
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px;">
                            <div>
                                <label for="ent_latitude">Site Latitude:</label>
                                <input type="text" id="ent_latitude" placeholder="31.12887">
                            </div>
                            <div>
                                <label for="ent_longitude">Site Longitude:</label>
                                <input type="text" id="ent_longitude" placeholder="-97.087951">
                            </div>
                        </div>

                        <div style="margin-top: 10px;">
                            <label for="ent_uplinkComment">Uplink Comment/Location (e.g., TX-LAGRANGE-FC-1):</label>
                            <input type="text" id="ent_uplinkComment" placeholder="TX-LAGRANGE-FC-1"
                                style="width: 100%;">
                            <small style="color: var(--text-color); opacity: 0.7;">This comment will be used for
                                backhaul interface and IP address</small>
                        </div>
                    </div>

                    <!-- Network Configuration -->
                    <div class="section">
                        <h2>Network Configuration</h2>

                        <!-- Public IP Configuration -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <label for="ent_publicIP">Public IP Address (e.g., 67.219.122.33/30):</label>
                                <input type="text" id="ent_publicIP" placeholder="67.219.122.33/30"
                                    oninput="updatePublicPoolFromPublicIp()">
                            </div>
                            <div>
                                <label for="ent_publicPool">Public DHCP Pool (auto-filled):</label>
                                <input type="text" id="ent_publicPool" placeholder="67.219.122.34-67.219.122.34"
                                    readonly style="background: var(--output-bg);">
                            </div>
                        </div>

                        <!-- Backhaul IP Configuration -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px;">
                            <div>
                                <label for="ent_backhaulIP">Backhaul IP Address (e.g., 10.11.1.68/29):</label>
                                <input type="text" id="ent_backhaulIP" placeholder="10.11.1.68/29"
                                    oninput="updateGatewayFromBackhaul()">
                            </div>
                            <div>
                                <label for="ent_gatewayIP">Backhaul Network Address:</label>
                                <input type="text" id="ent_gatewayIP" placeholder="10.11.1.64/29" readonly
                                    style="background: var(--output-bg);">
                            </div>
                        </div>

                        <!-- Private IP Configuration -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px;">
                            <div>
                                <label for="ent_privateIP">Private IP Address (e.g., 192.168.88.1/24):</label>
                                <input type="text" id="ent_privateIP" placeholder="192.168.88.1/24"
                                    value="192.168.88.1/24">
                            </div>
                            <div>
                                <label for="ent_privatePool">Private DHCP Pool (e.g.,
                                    192.168.88.10-192.168.88.254):</label>
                                <input type="text" id="ent_privatePool" placeholder="192.168.88.10-192.168.88.254"
                                    value="192.168.88.10-192.168.88.254">
                            </div>
                        </div>
                    </div>

                    <!-- Interface Configuration -->
                    <div class="section" id="ent_manual_interfaces" style="display:none;">
                        <h2>Interface Configuration</h2>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <label for="ent_publicInterface">Public/Customer Handoff Interface:</label>
                                <select id="ent_publicInterface">
                                    <option value="">Select Interface</option>
                                    <option value="sfp-sfpplus7">sfp-sfpplus7</option>
                                    <option value="ether7">ether7</option>
                                    <option value="ether1">ether1</option>
                                    <option value="sfp-sfpplus1">sfp-sfpplus1</option>
                                </select>
                            </div>
                            <div>
                                <label for="ent_natInterface">NAT Interface:</label>
                                <select id="ent_natInterface">
                                    <option value="">Select Interface</option>
                                    <option value="sfp-sfpplus8">sfp-sfpplus8</option>
                                    <option value="ether8">ether8</option>
                                    <option value="ether2">ether2</option>
                                    <option value="sfp-sfpplus2">sfp-sfpplus2</option>
                                </select>
                            </div>
                        </div>

                        <div style="margin-top: 15px;">
                            <label for="ent_backhaulInterface">Backhaul/Uplink Interface:</label>
                            <select id="ent_backhaulInterface">
                                <option value="">Select Interface</option>
                                <option value="sfp-sfpplus1">sfp-sfpplus1</option>
                                <option value="ether1">ether1</option>
                                <option value="ether2">ether2</option>
                                <option value="sfp28-1">sfp28-1</option>
                            </select>
                        </div>

                        <div class="dhcp-note" style="margin-top: 15px;">
                            <strong>Note:</strong> Interface speed negotiation will be set automatically based on device
                            type and firmware version.
                        </div>
                    </div>

                    <!-- Uplink/Backhaul Configuration -->
                    <div class="section" id="ent_manual_uplinks" style="display:none;">
                        <h2>Uplink/Backhaul Configuration</h2>
                        <div id="ent_uplinksContainer">
                            <div class="interface-item">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                    <div>
                                        <label>Uplink Interface:</label>
                                        <select class="ent_uplinkInterface">
                                            <option value="">Select Interface</option>
                                            <option value="sfp-sfpplus1">sfp-sfpplus1</option>
                                            <option value="ether1">ether1</option>
                                            <option value="ether2">ether2</option>
                                        </select>
                                    </div>
                                    <div>
                                        <label>Uplink IP/Net:</label>
                                        <input type="text" class="ent_uplinkIP" placeholder="10.1.241.92/29">
                                    </div>
                                </div>
                                <div style="margin-top: 10px;">
                                    <label>Uplink Comment/Location:</label>
                                    <input type="text" class="ent_uplinkComment" placeholder="TX-WESTPHALIA-EA-1">
                                </div>
                            </div>
                        </div>
                        <button class="add-btn" style="background: #28a745; margin-top: 10px;"
                            onclick="addEnterpriseUplink()">+ Add Another Uplink</button>
                    </div>

                    <!-- Optional Features -->
                    <div class="section" id="ent_manual_optional" style="display:none;">
                        <h2>Optional Features</h2>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <label><input type="checkbox" id="ent_enableOSPF"> Enable OSPF</label>
                                <div class="hint" style="font-size: 12px; color: #888; margin-top: 5px;">Adds OSPF
                                    interface templates and routing</div>
                            </div>
                            <div>
                                <label><input type="checkbox" id="ent_enableBGP"> Enable BGP</label>
                                <div class="hint" style="font-size: 12px; color: #888; margin-top: 5px;">Adds BGP
                                    connections to core routers</div>
                            </div>
                        </div>

                        <div id="ent_ospfBgpConfig"
                            style="display: none; margin-top: 15px; padding: 15px; background: #2a2a2a; border-radius: 5px;">
                            <h3 style="margin-top: 0; color: #FF9800;">OSPF/BGP Configuration</h3>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                <div>
                                    <label for="ent_sharedKey">Shared Key (OSPF/BGP MD5):</label>
                                    <input type="text" id="ent_sharedKey" value=""
                                        placeholder="Enter OSPF/BGP MD5 shared key">
                                </div>
                                <div>
                                    <label for="ent_ospfArea">OSPF Area:</label>
                                    <select id="ent_ospfArea">
                                        <option value="backbone-v2">backbone-v2</option>
                                        <option value="backbone">backbone</option>
                                        <option value="custom">Custom Area</option>
                                    </select>
                                </div>
                            </div>
                            <div id="ent_customOspfArea" style="display: none; margin-top: 10px;">
                                <label for="ent_ospfAreaCustom">Custom OSPF Area:</label>
                                <input type="text" id="ent_ospfAreaCustom" placeholder="e.g., 0.0.0.100">
                            </div>
                        </div>
                    </div>

                    <!-- Generate Button -->
                    <div class="generate-section" style="text-align: center; margin: 20px 0;">
                        <button id="generateEnterpriseBtn"
                            style="background: #FF9800; color: white; border: none; padding: 15px 30px; border-radius: 8px; cursor: pointer; font-size: 18px; font-weight: bold; box-shadow: 0 4px 8px rgba(0,0,0,0.2);"
                            onclick="generateEnterpriseConfig()">
                             Generate Enterprise Configuration
                        </button>
                        <div style="margin-top: 10px; font-size: 14px; color: #666;">
                            Includes automatic validation, AI suggestions, and Nextlink policy compliance
                        </div>

                        <!-- Status Display -->
                        <div id="aiStatus"
                            style="display: none; padding: 15px; border-radius: 8px; margin-top: 15px; font-size: 14px; font-weight: bold;">
                            <span id="aiStatusText">Status will appear here...</span>
                        </div>
                    </div>

                    <!-- Paste Export (optional) -->
                    <details style="margin: 10px 0 0 0;">
                        <summary style="cursor: pointer; color: var(--text-color);">Paste exported RouterOS config
                            (optional for Autofill)</summary>
                        <textarea id="ent_exportInput"
                            style="width: 100%; min-height: 160px; padding: 12px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: monospace; font-size: 12px; line-height: 1.5; margin-top: 8px;"
                            placeholder="# Paste your /export compact here..."></textarea>
                    </details>

                    <!-- Output Section -->
                    <div class="section">
                        <h2>Generated Configuration</h2>
                        <div style="margin-bottom: 20px;">
                            <button onclick="copyEnterpriseConfig()" style="background: #2196F3;"> Copy to
                                Clipboard</button>
                            <button onclick="downloadEnterpriseConfig()" style="background: #4CAF50;"> Download .rsc
                                File</button>
                            <button onclick="toggleEnterprisePasswords()" id="toggleEntPasswordBtn"
                                style="background: #FF9800;"> Show Passwords</button>
                            <button onclick="clearEnterpriseOutput()" style="background: #dc3545;"> Clear
                                Output</button>
                        </div>
                        <div class="dhcp-note" style="margin-bottom: 15px;">
                            <strong> Security:</strong> Passwords are hidden by default in the display. Click "Show
                            Passwords" to reveal. Downloaded .rsc file contains actual passwords.
                        </div>
                        <div id="enterpriseOutput"
                            style="background-color: var(--output-bg); color: var(--text-color); padding: 20px; border: 1px solid var(--border-color); border-radius: 4px; white-space: pre-wrap; font-family: monospace; min-height: 400px; width: 100%; transition: all 0.3s ease; font-size: 13px; line-height: 1.5;">
                        </div>
                        <div id="entValidateReport"
                            style="margin-top:10px; font-family: monospace; font-size: 12px; color: var(--text-color);">
                        </div>
                    </div>
                </div>
            </div>

            <!-- MPLS ENTERPRISE CONFIG TAB -->
            <div class="content-pane" id="enterprise-mpls-pane">
                <div class="container">
                    <div class="enterprise-testing-banner"> TESTING CONSISTENCY AND FUNCTIONALITY - MPLS Enterprise
                        Config</div>
                    <h1> MPLS Enterprise Configuration Generator</h1>
                    <p style="text-align: center; color: var(--text-color);">Nextlink-compliant MPLS enterprise
                        configuration with OSPF, BGP, VPLS, and standardized port assignments.</p>
                    <p
                        style="text-align: center; color: var(--text-color-secondary); font-size: 14px; margin-top: 10px;">
                         <a href="javascript:void(0);" onclick="togglePolicyReference();"
                            style="color: #FF9800; text-decoration: underline;">View Policy Reference</a> for port
                        assignments and configuration details.</p>

                    <!-- Simplified Device Information (Similar to Non-MPLS Enterprise) -->
                    <div class="section">
                        <h2>Device Information</h2>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                            <div>
                                <label for="ent_mpls_routerboard_device">RouterBoard Device:</label>
                                <select id="ent_mpls_routerboard_device"
                                    onchange="updateMPLSDeviceName(); updateMPLSEnterpriseInterfaces();">
                                    <option value="">Select RouterBoard Device</option>
                                    <option value="ccr2004">CCR2004 (Recommended)</option>
                                    <option value="ccr1036">CCR1036</option>
                                    <option value="rb5009">RB5009</option>
                                    <option value="ccr2216">CCR2216</option>
                                    <option value="ccr1072">CCR1072</option>
                                    <option value="rb1009">RB1009</option>
                                    <option value="rb2011">RB2011</option>
                                </select>
                            </div>
                            <div>
                                <label for="ent_mpls_routeros_version">RouterOS Version:</label>
                                <select id="ent_mpls_routeros_version">
                                    <option value="">Select RouterOS Version</option>
                                    <option value="7.16.2" selected>7.16.2 (Recommended)</option>
                                    <option value="7.19.4">7.19.4 (Latest)</option>
                                    <option value="7.11.2">7.11.2</option>
                                    <option value="6.49.2">6.49.2</option>
                                </select>
                            </div>
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                            <div>
                                <label for="ent_mpls_customerCode">Customer Code (e.g., NX-537853):</label>
                                <input type="text" id="ent_mpls_customerCode" placeholder="NX-537853"
                                    oninput="updateMPLSDeviceName()">
                            </div>
                            <div>
                                <label for="ent_mpls_loopbackIP">Loopback IP (e.g., 10.247.72.34/32):</label>
                                <input type="text" id="ent_mpls_loopbackIP" placeholder="10.247.72.34/32">
                            </div>
                        </div>

                        <div style="margin-top: 10px;">
                            <label for="ent_mpls_deviceName">System Identity (auto-fills):</label>
                            <input type="text" id="ent_mpls_deviceName" placeholder="NX-537853" readonly
                                style="background: var(--output-bg);">
                        </div>

                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px;">
                            <div>
                                <label for="ent_mpls_latitude">Site Latitude (optional):</label>
                                <input type="text" id="ent_mpls_latitude" placeholder="38.10013601">
                            </div>
                            <div>
                                <label for="ent_mpls_longitude">Site Longitude (optional):</label>
                                <input type="text" id="ent_mpls_longitude" placeholder="-88.14223402">
                            </div>
                        </div>
                    </div>

                    <!-- Customer Handoff Interface (Optional - for bridge2000) -->
                    <div class="section">
                        <h2>Customer Handoff Interface (Optional)</h2>
                        <p style="font-size: 14px; color: var(--text-color-secondary); margin-bottom: 10px;">Customer
                            handoff interface for bridge2000. Public/private IPs and DHCP pools are handled by the BNG.
                        </p>
                        <div>
                            <label for="ent_mpls_customerHandoff">Customer Handoff Interface:</label>
                            <select id="ent_mpls_customerHandoff">
                                <option value="">None (Auto-select based on device)</option>
                            </select>
                            <div class="hint">Ports will populate based on selected RouterBoard device</div>
                        </div>
                    </div>

                    <!-- Uplink/Backhaul Configuration -->
                    <div class="section">
                        <h2>Uplink/Backhaul Configuration</h2>
                        <div id="ent_mpls_uplinksContainer">
                            <div class="interface-item">
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                    <div>
                                        <label>Uplink Interface:</label>
                                        <select class="ent_mpls_uplinkInterface">
                                            <option value="">Select Interface (Choose Device First)</option>
                                        </select>
                                        <div class="hint">Ports will populate based on selected RouterBoard device</div>
                                    </div>
                                    <div>
                                        <label>Uplink IP/Net:</label>
                                        <input type="text" class="ent_mpls_uplinkIP" placeholder="10.247.57.4/29">
                                    </div>
                                </div>
                                <div style="margin-top: 10px;">
                                    <label>Uplink Comment/Location:</label>
                                    <input type="text" class="ent_mpls_uplinkComment" placeholder="IL-CARMI-CN-1">
                                </div>
                            </div>
                        </div>
                        <button class="add-btn" style="background: #28a745; margin-top: 10px;"
                            onclick="addMPLSUplink()">+ Add Another Uplink</button>
                    </div>

                    <!-- Generate Button -->
                    <div class="generate-section" style="margin-top: 30px;">
                        <button id="generateMPLSEnterpriseBtn" onclick="generateMPLSEnterpriseConfig()"
                            style="background: #FF9800; color: white; border: none; padding: 15px 40px; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">
                             Generate MPLS Enterprise Configuration
                        </button>
                    </div>

                    <div id="mplsEnterprise_warn" style="margin-top: 15px;"></div>

                    <!-- Output Section -->
                    <div class="section">
                        <h2>Generated Configuration</h2>
                        <div style="margin-bottom: 20px;">
                            <button onclick="copyMPLSEnterpriseConfig()" style="background: #2196F3;"> Copy to
                                Clipboard</button>
                            <button onclick="downloadMPLSEnterpriseConfig()" style="background: #4CAF50;"> Download
                                .rsc File</button>
                            <button onclick="toggleMPLSEnterprisePasswords()" id="toggleMPLSEntPasswordBtn"
                                style="background: #FF9800;"> Show Passwords</button>
                            <button onclick="clearMPLSEnterpriseOutput()" style="background: #dc3545;"> Clear
                                Output</button>
                        </div>
                        <div class="dhcp-note" style="margin-bottom: 15px;">
                            <strong> Security:</strong> Passwords are hidden by default in the display. Click "Show
                            Passwords" to reveal. Downloaded .rsc file contains actual passwords.
                        </div>
                        <div id="mplsEnterpriseOutput"
                            style="background-color: var(--output-bg); color: var(--text-color); padding: 20px; border: 1px solid var(--border-color); border-radius: 4px; white-space: pre-wrap; font-family: monospace; min-height: 400px; width: 100%; transition: all 0.3s ease; font-size: 13px; line-height: 1.5;">
                        </div>
                    </div>
                </div>
            </div>

            <!-- 6GHz SWITCH CONFIG TAB -->
            <div class="content-pane" id="ccr2004-pane">
                <div class="container">
                    <div class="testing-banner"> PRODUCTION READY - 6GHz Switch Configuration - Nextlink Policy
                        Compliant</div>
                    <h1> 6GHz Configuration Generator</h1>
                    <p style="text-align: center; color: var(--text-color);">Nextlink-compliant 6GHz switch
                        configuration with VLAN 3000/4000, standardized port assignments, bonding, and DHCP pools.</p>
                    <p
                        style="text-align: center; color: var(--text-color-secondary); font-size: 14px; margin-top: 10px;">
                         <a href="javascript:void(0);" onclick="togglePolicyReference();"
                            style="color: #FF9800; text-decoration: underline;">View Policy Reference</a> for port
                        assignments and configuration details.</p>

                    <!-- IN-STATE / OUT-OF-STATE Toggle -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
                        <button id="ghz_instate_btn" class="sub-tab-btn active" onclick="showGhzStateTab('instate')"
                            style="flex: 1; padding: 15px; background: #4CAF50; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer;">
                            <span style="font-weight: bold;">IN-STATE</span>
                        </button>
                        <button id="ghz_outstate_btn" class="sub-tab-btn" onclick="showGhzStateTab('outstate')"
                            style="flex: 1; padding: 15px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer;">
                            <span style="font-weight: bold;">OUT-OF-STATE</span>
                        </button>
                    </div>

                    <!-- IN-STATE Configuration Section -->
                    <div id="ghz-instate-section">
                        <div class="section">
                            <h2>6GHz Switch Configuration (IN-STATE)</h2>

                            <!-- Switch Type Selection -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="ghz_switch_type">Select Switch Type:</label>
                                    <select id="ghz_switch_type">
                                        <option value="">Select Switch Type</option>
                                        <option value="swt_mt326">SWT MT326</option>
                                        <option value="swt_ccr2004">SWT CCR 2004</option>
                                        <option value="swt_mt309">SWT MT309</option>
                                    </select>
                                    <div class="hint">Switch type determines port naming and bonding configuration</div>
                                </div>
                                <div>
                                    <label for="ghz_routeros_version">RouterOS Version:</label>
                                    <select id="ghz_routeros_version">
                                        <option value="">Select RouterOS Version</option>
                                        <option value="6.45.2">6.45.2</option>
                                        <option value="6.49.2">6.49.2</option>
                                        <option value="7.11.2">7.11.2</option>
                                        <option value="7.16.2">7.16.2</option>
                                        <option value="7.19.4">7.19.4</option>
                                    </select>
                                </div>
                            </div>

                            <!-- VLAN Configuration -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px;">
                                <div>
                                    <label for="ghz_subnet3000">VLAN 3000 (6 GHz) Subnet (CIDR):</label>
                                    <input type="text" id="ghz_subnet3000" placeholder="e.g. 10.246.31.240/28">
                                    <div class="hint">6GHz management subnet</div>
                                </div>
                                <div>
                                    <label for="ghz_subnet4000">VLAN 4000 Subnet (CIDR):</label>
                                    <input type="text" id="ghz_subnet4000" placeholder="e.g. 10.53.0.0/22">
                                    <div class="hint">6GHz CPE subnet</div>
                                </div>
                            </div>

                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 10px;">
                                <div>
                                    <label for="ghz_poolOffset">DHCP Pool Start Offset (after GW):</label>
                                    <input type="number" id="ghz_poolOffset" min="0" value="0" placeholder="0">
                                    <div class="hint">0 = GW+1; increase to reserve more in front</div>
                                </div>
                                <div>
                                    <label for="ghz_dns">DNS Servers:</label>
                                    <input type="text" id="ghz_dns"
                                        placeholder="NextLink DNS servers (comma-separated)">
                                </div>
                            </div>

                            <div style="margin-top: 20px; display: flex; gap: 10px;">
                                <button id="generateGhz" style="background: #FF9800;">Generate</button>
                                <button id="copyGhz" style="background: #6c757d;">Copy</button>
                            </div>

                            <div id="ghz_warnBox" style="margin-top: 15px;"></div>
                        </div>
                    </div>

                    <!-- OUT-OF-STATE Configuration Section -->
                    <div id="ghz-outstate-section" style="display: none;">
                        <div class="section">
                            <h2>6GHz Switch Configuration (OUT-OF-STATE)</h2>
                            <p style="color: var(--text-color-secondary); text-align: center; margin-bottom: 20px;">
                                Simple bridge and VLAN configuration for out-of-state deployments.
                            </p>

                            <!-- Switch Type Selection -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="ghz_outstate_switch_type">Select Switch Type:</label>
                                    <select id="ghz_outstate_switch_type">
                                        <option value="">Select Switch Type</option>
                                        <option value="swt_mt326">SWT MT326</option>
                                        <option value="swt_ccr2004">SWT CCR 2004</option>
                                        <option value="swt_mt309">SWT MT309</option>
                                    </select>
                                    <div class="hint">Switch type determines port naming</div>
                                </div>
                                <div>
                                    <label for="ghz_outstate_routeros_version">RouterOS Version:</label>
                                    <select id="ghz_outstate_routeros_version">
                                        <option value="">Select RouterOS Version</option>
                                        <option value="6.45.2">6.45.2</option>
                                        <option value="6.49.2">6.49.2</option>
                                        <option value="7.11.2">7.11.2</option>
                                        <option value="7.16.2">7.16.2</option>
                                        <option value="7.19.4">7.19.4</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Port Selection - Dynamic based on switch type -->
                            <!-- For MT326/CCR2004: Show bonding ports -->
                            <div id="ghz_outstate_bonding_ports"
                                style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="ghz_outstate_port1">Bonding Port #1:</label>
                                    <select id="ghz_outstate_port1">
                                        <option value="">Select Port (Choose Switch First)</option>
                                    </select>
                                    <div class="hint">First port for bonding</div>
                                </div>
                                <div>
                                    <label for="ghz_outstate_port2">Bonding Port #2:</label>
                                    <select id="ghz_outstate_port2">
                                        <option value="">Select Port (Choose Switch First)</option>
                                    </select>
                                    <div class="hint">Second port for bonding</div>
                                </div>
                            </div>

                            <!-- For MT309: Show single port -->
                            <div id="ghz_outstate_single_port" style="display: none; margin-bottom: 20px;">
                                <div>
                                    <label for="ghz_outstate_port_single">Port:</label>
                                    <select id="ghz_outstate_port_single">
                                        <option value="">Select Port (Choose Switch First)</option>
                                    </select>
                                    <div class="hint">Single port for MT309 (no bonding)</div>
                                </div>
                            </div>

                            <div style="margin-top: 20px; display: flex; gap: 10px;">
                                <button id="generateGhzOutstate" style="background: #FF9800;">Generate</button>
                                <button id="copyGhzOutstate" style="background: #6c757d;">Copy</button>
                            </div>

                            <div id="ghz_outstate_warnBox" style="margin-top: 15px;"></div>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Generated Configuration</h2>
                        <textarea id="ccr_output"
                            style="width: 100%; min-height: 400px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: monospace; font-size: 13px; line-height: 1.5;"
                            placeholder="Your 6GHz switch configuration will appear here..."></textarea>
                    </div>
                </div>
            </div>

            <!-- MIKROTIK SWITCH CONFIG MAKER TAB -->
            <div class="content-pane" id="switch-maker-pane">
                <div class="container">
                    <div class="testing-banner"> IN DEVELOPMENT - MikroTik Switch Config Maker - Testing Phase</div>
                    <h1> MikroTik Switch Config Maker</h1>
                    <p style="text-align: center; color: var(--text-color);">Complete switch configuration generator for
                        CRS309, CRS326, and CCR2004 switches with dynamic port management.</p>

                    <!-- IN-STATE / OUT-OF-STATE Toggle -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
                        <button id="switch_instate_btn" class="sub-tab-btn active"
                            onclick="showSwitchStateTab('instate')"
                            style="flex: 1; padding: 15px; background: #4CAF50; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer;">
                            <span style="font-weight: bold;">IN-STATE</span>
                        </button>
                        <button id="switch_outstate_btn" class="sub-tab-btn" onclick="showSwitchStateTab('outstate')"
                            style="flex: 1; padding: 15px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer;">
                            <span style="font-weight: bold;">OUT-OF-STATE</span>
                        </button>
                    </div>

                    <!-- IN-STATE Configuration Section -->
                    <div id="switch-instate-section">
                        <div class="section">
                            <h2>MikroTik Switch Configuration (IN-STATE)</h2>

                            <!-- Switch Type and RouterOS Selection -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="switch_maker_type">Switch Type:</label>
                                    <select id="switch_maker_type" onchange="updateSwitchPorts('instate')">
                                        <option value="">Select Switch Type</option>
                                        <option value="309">CRS309 (MT309)</option>
                                        <option value="326">CRS326 (MT326)</option>
                                        <option value="2004">CCR2004 Switch</option>
                                    </select>
                                    <div class="hint">Select the switch model</div>
                                </div>
                                <div>
                                    <label for="switch_maker_routeros">RouterOS Version:</label>
                                    <select id="switch_maker_routeros">
                                        <option value="">Select RouterOS Version</option>
                                        <option value="6.45.2">6.45.2</option>
                                        <option value="6.49.2">6.49.2</option>
                                        <option value="7.11.2">7.11.2</option>
                                        <option value="7.16.2">7.16.2</option>
                                        <option value="7.19.4">7.19.4</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Basic Information -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="switch_maker_name">Switch Name:</label>
                                    <input type="text" id="switch_maker_name" placeholder="e.g., SWT-CRS326.BLANKET">
                                    <div class="hint">System identity name</div>
                                </div>
                                <div>
                                    <label for="switch_maker_gps">GPS Coordinates:</label>
                                    <input type="text" id="switch_maker_gps" placeholder="e.g., 32.750817, -97.687826">
                                    <div class="hint">Latitude, Longitude for SNMP location</div>
                                </div>
                            </div>

                            <!-- Network Configuration -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="switch_maker_ip">Management IP (VLAN 3000):</label>
                                    <input type="text" id="switch_maker_ip" placeholder="e.g., 10.246.48.194/27">
                                    <div class="hint">IP address for VLAN 3000 interface</div>
                                </div>
                                <div>
                                    <label for="switch_maker_gateway">Default Gateway:</label>
                                    <input type="text" id="switch_maker_gateway" placeholder="e.g., 10.246.48.193">
                                    <div class="hint">Gateway IP for default route</div>
                                </div>
                            </div>

                            <!-- Router Uplink Ports (for bonding) -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="switch_maker_uplink1">Router Uplink Port 1:</label>
                                    <select id="switch_maker_uplink1">
                                        <option value="">Select Port (Choose Switch First)</option>
                                    </select>
                                    <div class="hint">First port for bonding (e.g., sfp-sfpplus23)</div>
                                </div>
                                <div>
                                    <label for="switch_maker_uplink2">Router Uplink Port 2:</label>
                                    <select id="switch_maker_uplink2">
                                        <option value="">Select Port (Choose Switch First)</option>
                                    </select>
                                    <div class="hint">Second port for bonding (e.g., sfp-sfpplus24)</div>
                                </div>
                            </div>

                            <!-- Dynamic Port Addition Section -->
                            <div class="section"
                                style="margin-top: 30px; border: 2px solid var(--border-color); padding: 20px; border-radius: 8px;">
                                <h3 style="margin-top: 0;">Port Configuration</h3>
                                <p style="color: var(--text-color-secondary); margin-bottom: 15px;">Add ports with
                                    comments for devices connected to the switch</p>

                                <div id="switch_ports_container">
                                    <!-- Port items will be added here dynamically -->
                                </div>

                                <button type="button" id="switch_add_port_btn" onclick="addSwitchPort('instate')"
                                    style="background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-top: 15px;">
                                     Add Port
                                </button>
                            </div>

                            <div style="margin-top: 20px; display: flex; gap: 10px;">
                                <button id="generateSwitchInstate" onclick="generateSwitchConfig('instate')"
                                    style="background: #FF9800;">Generate</button>
                                <button id="copySwitchInstate" onclick="copySwitchConfig('instate')"
                                    style="background: #6c757d;">Copy</button>
                            </div>

                            <div id="switch_instate_warn" style="margin-top: 15px;"></div>
                        </div>
                    </div>

                    <!-- OUT-OF-STATE Configuration Section -->
                    <div id="switch-outstate-section" style="display: none;">
                        <div class="section">
                            <h2>MikroTik Switch Configuration (OUT-OF-STATE)</h2>

                            <!-- Switch Type and RouterOS Selection -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="switch_outstate_type">Switch Type:</label>
                                    <select id="switch_outstate_type" onchange="updateSwitchPorts('outstate')">
                                        <option value="">Select Switch Type</option>
                                        <option value="309">CRS309 (MT309)</option>
                                        <option value="326">CRS326 (MT326)</option>
                                        <option value="2004">CCR2004 Switch</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="switch_outstate_routeros">RouterOS Version:</label>
                                    <select id="switch_outstate_routeros">
                                        <option value="">Select RouterOS Version</option>
                                        <option value="6.45.2">6.45.2</option>
                                        <option value="6.49.2">6.49.2</option>
                                        <option value="7.11.2">7.11.2</option>
                                        <option value="7.16.2">7.16.2</option>
                                        <option value="7.19.4">7.19.4</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Basic Information -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="switch_outstate_name">Switch Name:</label>
                                    <input type="text" id="switch_outstate_name"
                                        placeholder="e.g., SWT-CRS326.NE-ARLINGTON-NW-1">
                                </div>
                                <div>
                                    <label for="switch_outstate_gps">GPS Coordinates:</label>
                                    <input type="text" id="switch_outstate_gps"
                                        placeholder="e.g., 41.459229, -96.36953">
                                </div>
                            </div>

                            <!-- Network Configuration -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="switch_outstate_ip">Management IP (VLAN 3000):</label>
                                    <input type="text" id="switch_outstate_ip" placeholder="e.g., 10.249.168.43/20">
                                </div>
                                <div>
                                    <label for="switch_outstate_gateway">Default Gateway:</label>
                                    <input type="text" id="switch_outstate_gateway" placeholder="e.g., 10.249.160.1">
                                </div>
                            </div>

                            <!-- Router Uplink Ports -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="switch_outstate_uplink1">Router Uplink Port 1:</label>
                                    <select id="switch_outstate_uplink1">
                                        <option value="">Select Port (Choose Switch First)</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="switch_outstate_uplink2">Router Uplink Port 2:</label>
                                    <select id="switch_outstate_uplink2">
                                        <option value="">Select Port (Choose Switch First)</option>
                                    </select>
                                </div>
                            </div>

                            <!-- Dynamic Port Addition Section -->
                            <div class="section"
                                style="margin-top: 30px; border: 2px solid var(--border-color); padding: 20px; border-radius: 8px;">
                                <h3 style="margin-top: 0;">Port Configuration</h3>
                                <p style="color: var(--text-color-secondary); margin-bottom: 15px;">Add ports with
                                    comments for devices connected to the switch</p>

                                <div id="switch_outstate_ports_container">
                                    <!-- Port items will be added here dynamically -->
                                </div>

                                <button type="button" id="switch_outstate_add_port_btn"
                                    onclick="addSwitchPort('outstate')"
                                    style="background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: bold; margin-top: 15px;">
                                     Add Port
                                </button>
                            </div>

                            <div style="margin-top: 20px; display: flex; gap: 10px;">
                                <button id="generateSwitchOutstate" onclick="generateSwitchConfig('outstate')"
                                    style="background: #FF9800;">Generate</button>
                                <button id="copySwitchOutstate" onclick="copySwitchConfig('outstate')"
                                    style="background: #6c757d;">Copy</button>
                            </div>

                            <div id="switch_outstate_warn" style="margin-top: 15px;"></div>
                        </div>
                    </div>

                    <div class="section">
                        <h2>Generated Configuration</h2>
                        <textarea id="switch_maker_output"
                            style="width: 100%; min-height: 400px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: monospace; font-size: 13px; line-height: 1.5;"
                            placeholder="Your MikroTik switch configuration will appear here..."></textarea>
                    </div>
                </div>
            </div>

            <!-- TARANA SECTORS TAB -->
            <div class="content-pane" id="tarana-pane">
                <div class="container">
                    <div class="testing-banner"> PRODUCTION READY - Tarana Sector Configuration - Nextlink Policy
                        Compliant</div>
                    <h1> Tarana Sector Configuration Generator</h1>
                    <p style="text-align: center; color: var(--text-color);">Nextlink-compliant Tarana sector
                        configuration with standardized port assignments for ALPHA/BETA/GAMMA/DELTA sectors.</p>
                    <p
                        style="text-align: center; color: var(--text-color-secondary); font-size: 14px; margin-top: 10px;">
                         <a href="javascript:void(0);" onclick="togglePolicyReference();"
                            style="color: #FF9800; text-decoration: underline;">View Policy Reference</a> for port
                        assignments and configuration details.</p>

                    <!-- Sub-tab Selection (BNG1 vs BNG2) -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
                        <button id="tarana-bng1-btn" class="sub-tab-btn active" onclick="showTaranaSubTab('bng1')"
                            style="flex: 1; padding: 15px; background: #9C27B0; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer;">
                            <span style="font-weight: bold;">BNG1</span>
                        </button>
                        <button id="tarana-bng2-btn" class="sub-tab-btn" onclick="showTaranaSubTab('bng2')"
                            style="flex: 1; padding: 15px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer;">
                            <span style="font-weight: bold;">BNG2</span>
                        </button>
                    </div>

                    <!-- BNG1 Configuration (existing) -->
                    <div id="tarana-bng1-section">
                        <div class="section">
                            <h2>Tarana Sector Configuration (BNG1)</h2>

                            <!-- RouterBoard Device Selection -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="tarana_routerboard_device">RouterBoard Device:</label>
                                    <select id="tarana_routerboard_device">
                                        <option value="">Select RouterBoard Device</option>
                                        <option value="ccr2004">CCR2004 (RouterOS 7.x)</option>
                                        <option value="ccr2216">CCR2216 (RouterOS 7.x)</option>
                                        <option value="ccr2116">CCR2116 (RouterOS 7.x)</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="tarana_routeros_version">RouterOS Version:</label>
                                    <select id="tarana_routeros_version">
                                        <option value="">Select RouterOS Version</option>
                                        <option value="7.11.2">7.11.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="7.16.2">7.16.2 (New Speed Syntax)</option>
                                        <option value="7.19.4">7.19.4 (New Speed Syntax)</option>
                                    </select>
                                </div>
                            </div>

                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px;">
                                <div>
                                    <label for="tarana_alphaPort">ALPHA Port:</label>
                                    <select id="tarana_alphaPort">
                                        <option value="">None</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="tarana_betaPort">BETA Port:</label>
                                    <select id="tarana_betaPort">
                                        <option value="">None</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="tarana_gammaPort">GAMMA Port:</label>
                                    <select id="tarana_gammaPort">
                                        <option value="">None</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="tarana_deltaPort">DELTA Port (optional):</label>
                                    <select id="tarana_deltaPort">
                                        <option value="">None</option>
                                    </select>
                                </div>
                            </div>

                            <div style="margin-top: 20px;">
                                <label for="tarana_mgmtSubnet">UNICORNMGMT Subnet (CIDR):</label>
                                <input type="text" id="tarana_mgmtSubnet" placeholder="e.g. 10.246.21.64/29">
                                <div class="hint">Router IP = first usable.</div>
                            </div>

                            <div style="margin-top: 20px; display: flex; gap: 10px;">
                                <button id="generateTarana" style="background: #FF9800;">Generate</button>
                                <button id="copyTarana" style="background: #6c757d;">Copy</button>
                            </div>

                            <div id="tarana_warn" style="margin-top: 15px;"></div>
                        </div>

                        <div class="section">
                            <h2>Generated Configuration (BNG1)</h2>
                            <textarea id="tarana_output"
                                style="width: 100%; min-height: 400px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: monospace; font-size: 13px; line-height: 1.5;"
                                placeholder="Your Tarana sector configuration will appear here..."></textarea>
                        </div>
                    </div>

                    <!-- BNG2 Configuration (new) -->
                    <div id="tarana-bng2-section" style="display: none;">
                        <div class="section">
                            <h2>Tarana Sector Configuration (BNG2)</h2>

                            <!-- RouterBoard Device Selection -->
                            <div
                                style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="tarana_bng2_device">RouterBoard Device:</label>
                                    <select id="tarana_bng2_device">
                                        <option value="">Select RouterBoard Device</option>
                                        <option value="ccr2004">CCR2004 (RouterOS 7.x)</option>
                                        <option value="ccr2216">CCR2216 (RouterOS 7.x)</option>
                                        <option value="ccr2116">CCR2116 (RouterOS 7.x)</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="tarana_bng2_routeros_version">RouterOS Version:</label>
                                    <select id="tarana_bng2_routeros_version">
                                        <option value="">Select RouterOS Version</option>
                                        <option value="7.11.2">7.11.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="7.16.2">7.16.2 (New Speed Syntax)</option>
                                        <option value="7.19.4">7.19.4 (New Speed Syntax)</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="tarana_bng2_sector_count">Number of Sectors:</label>
                                    <select id="tarana_bng2_sector_count">
                                        <option value="3">3 Sectors (Alpha, Beta, Gamma)</option>
                                        <option value="4">4 Sectors (Alpha, Beta, Gamma, Delta)</option>
                                    </select>
                                </div>
                            </div>

                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px;">
                                <div>
                                    <label for="tarana_bng2_alphaPort">ALPHA Port:</label>
                                    <select id="tarana_bng2_alphaPort">
                                        <option value="">Select Port (Choose Device First)</option>
                                    </select>
                                    <div class="hint">Ports will populate based on selected RouterBoard device</div>
                                </div>
                                <div>
                                    <label for="tarana_bng2_betaPort">BETA Port:</label>
                                    <select id="tarana_bng2_betaPort">
                                        <option value="">Select Port (Choose Device First)</option>
                                    </select>
                                    <div class="hint">Ports will populate based on selected RouterBoard device</div>
                                </div>
                                <div>
                                    <label for="tarana_bng2_gammaPort">GAMMA Port:</label>
                                    <select id="tarana_bng2_gammaPort">
                                        <option value="">Select Port (Choose Device First)</option>
                                    </select>
                                    <div class="hint">Ports will populate based on selected RouterBoard device</div>
                                </div>
                                <div id="tarana_bng2_delta_container" style="display: none;">
                                    <label for="tarana_bng2_deltaPort">DELTA Port:</label>
                                    <select id="tarana_bng2_deltaPort">
                                        <option value="">Select Port (Choose Device First)</option>
                                    </select>
                                    <div class="hint">Ports will populate based on selected RouterBoard device</div>
                                </div>
                            </div>

                            <div style="margin-top: 20px; display: flex; gap: 10px;">
                                <button id="generateTaranaBNG2" style="background: #2196F3; color: white;">Generate BNG2
                                    Config</button>
                                <button id="copyTaranaBNG2" style="background: #6c757d; color: white;">Copy</button>
                            </div>

                            <div id="tarana_bng2_warn" style="margin-top: 15px;"></div>
                        </div>

                        <div class="section">
                            <h2>Generated Configuration (BNG2)</h2>
                            <textarea id="tarana_bng2_output"
                                style="width: 100%; min-height: 400px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: monospace; font-size: 13px; line-height: 1.5;"
                                placeholder="Your BNG2 Tarana sector configuration will appear here..."></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <!-- ENTERPRISE FEEDING SIDE TAB -->
            <div class="content-pane" id="enterprise-feeding-pane">
                <div class="container">
                    <div class="testing-banner"> TESTING CONSISTENCY AND FUNCTIONALITY - Enterprise Feeding Side
                        Configuration</div>
                    <h1> Enterprise Feeding Side Configuration</h1>
                    <p style="text-align: center; color: var(--text-color);">Nextlink-compliant enterprise uplink
                        provisioning with standardized port assignments and commercial/enterprise configurations.</p>
                    <p
                        style="text-align: center; color: var(--text-color-secondary); font-size: 14px; margin-top: 10px;">
                         <a href="javascript:void(0);" onclick="togglePolicyReference();"
                            style="color: #FF9800; text-decoration: underline;">View Policy Reference</a> for port
                        assignments and configuration details.</p>

                    <!-- IN-STATE / OUT-OF-STATE Toggle -->
                    <div style="display: flex; gap: 10px; margin-bottom: 20px; justify-content: center;">
                        <button id="ent_feeding_instate_btn" class="sub-tab-btn active"
                            onclick="showEntFeedingStateTab('instate')"
                            style="flex: 1; padding: 15px; background: #4CAF50; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer;">
                            <span style="font-weight: bold;">IN-STATE</span>
                        </button>
                        <button id="ent_feeding_outstate_btn" class="sub-tab-btn"
                            onclick="showEntFeedingStateTab('outstate')"
                            style="flex: 1; padding: 15px; background: #6c757d; color: white; border: none; border-radius: 6px; font-size: 16px; font-weight: bold; cursor: pointer;">
                            <span style="font-weight: bold;">OUT-OF-STATE</span>
                        </button>
                    </div>

                    <!-- IN-STATE Configuration Section -->
                    <div id="ent-feeding-instate-section">
                        <div class="section">
                            <h2>Enterprise Feeding Configuration (In-State)</h2>

                            <!-- Device Selection -->
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="ent_feeding_device">RouterBoard Device:</label>
                                    <select id="ent_feeding_device">
                                        <option value="">Select RouterBoard Device</option>
                                        <option value="ccr2004">CCR2004-12G-4S (12 SFP+, 4 Ethernet) - Recommended
                                        </option>
                                        <option value="ccr1036">CCR1036-12G-4S (12 SFP+, 12 Ethernet) - Recommended
                                        </option>
                                        <option value="rb5009">RB5009 (Small sites)</option>
                                        <option value="rb1009">RB1009</option>
                                        <option value="rb2011">RB2011</option>
                                        <option value="ccr1072">CCR1072</option>
                                        <option value="ccr2216">CCR2216</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="ent_feeding_routeros">RouterOS Version:</label>
                                    <select id="ent_feeding_routeros">
                                        <option value="">Select RouterOS Version</option>
                                        <option value="6.45.2">6.45.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="6.49.2">6.49.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="7.11.2">7.11.2 (Pre-7.12 Speed Syntax)</option>
                                        <option value="7.16.2">7.16.2 (New Speed Syntax)</option>
                                        <option value="7.19.4">7.19.4 (New Speed Syntax)</option>
                                    </select>
                                </div>
                            </div>

                            <div style="display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 20px;">
                                <div>
                                    <label for="ent_feeding_label">Customer Label:</label>
                                    <input type="text" id="ent_feeding_label"
                                        placeholder="e.g. Jamie Mitchell | 125197077 or NX-12345">
                                </div>
                                <div>
                                    <label for="ent_feeding_port">Handoff Port:</label>
                                    <select id="ent_feeding_port">
                                        <option value="">Select Port (Choose Device First)</option>
                                    </select>
                                    <div class="hint">Ports will populate based on selected RouterBoard device</div>
                                </div>
                                <div>
                                    <label for="ent_feeding_speed">Port Speed:</label>
                                    <select id="ent_feeding_speed">
                                        <option value="auto">Auto Negotiation</option>
                                    </select>
                                    <div class="hint">Speed options update based on RouterOS version</div>
                                </div>
                            </div>

                            <div
                                style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-top: 15px;">
                                <div>
                                    <label for="ent_feeding_loop">Loopback /32 (10.x):</label>
                                    <input type="text" id="ent_feeding_loop" placeholder="e.g. 10.26.0.7/32">
                                </div>
                                <div>
                                    <label for="ent_feeding_uplink">Backhaul subnet (/29):</label>
                                    <input type="text" id="ent_feeding_uplink" placeholder="e.g. 10.25.26.52/29">
                                    <div class="hint">Enter network CIDR. For 2+0 backhaul: 1st usable=Tower Gateway
                                        (interface), 4th usable=Customer Gateway (routes)</div>
                                </div>
                                <div>
                                    <label for="ent_feeding_public">Public IP subnet (/30 or /29):</label>
                                    <input type="text" id="ent_feeding_public" placeholder="e.g. 142.234.21.52/30">
                                    <div class="hint">Optional - added to firewall address-list</div>
                                </div>
                            </div>

                            <div style="margin-top: 20px; display: flex; gap: 10px;">
                                <button id="generateEntFeeding" style="background: #FF9800;">Generate</button>
                                <button id="copyEntFeeding" style="background: #6c757d;">Copy</button>
                            </div>

                            <div id="ent_feeding_warn" style="margin-top: 15px;"></div>
                        </div>

                        <div class="section">
                            <h2>Generated Configuration</h2>
                            <textarea id="ent_feeding_output"
                                style="width: 100%; min-height: 400px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: monospace; font-size: 13px; line-height: 1.5;"
                                placeholder="Enterprise / Commercial config will appear here..."></textarea>
                        </div>
                    </div>

                    <!-- OUT-OF-STATE Configuration Section -->
                    <div id="ent-feeding-outstate-section" style="display: none;">
                        <div class="section">
                            <h2>Enterprise Feeding Configuration (Out-of-State)</h2>

                            <div
                                style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div>
                                    <label for="ent_feeding_outstate_state">State:</label>
                                    <select id="ent_feeding_outstate_state">
                                        <option value="">Select State</option>
                                        <option value="NE">Nebraska (NE)</option>
                                        <option value="IL">Illinois (IL)</option>
                                        <option value="IA">Iowa (IA)</option>
                                        <option value="KS">Kansas (KS)</option>
                                        <option value="IN">Indiana (IN)</option>
                                    </select>
                                </div>
                                <div>
                                    <label for="ent_feeding_outstate_loopback">Router Loopback /32 (10.x):</label>
                                    <input type="text" id="ent_feeding_outstate_loopback"
                                        placeholder="e.g. 10.247.72.34/32">
                                </div>
                                <div>
                                    <label for="ent_feeding_outstate_username">Username/Customer Code:</label>
                                    <input type="text" id="ent_feeding_outstate_username" placeholder="e.g. NX-537853">
                                </div>
                            </div>

                            <div style="margin-top: 20px; display: flex; gap: 10px;">
                                <button id="generateEntFeedingOutState" style="background: #FF9800;">Generate BNG
                                    Configs</button>
                                <button id="copyEntFeedingOutState" style="background: #6c757d;">Copy</button>
                            </div>

                            <div id="ent_feeding_outstate_warn" style="margin-top: 15px;"></div>
                        </div>

                        <div class="section">
                            <h2>Generated BNG Configuration</h2>
                            <textarea id="ent_feeding_outstate_output"
                                style="width: 100%; min-height: 400px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: monospace; font-size: 13px; line-height: 1.5;"
                                placeholder="BNG configs (MT and Nokia) will appear here..."></textarea>
                        </div>
                    </div>
                </div>
            </div>

            <!-- COMPLETED CONFIGS TAB -->
            <div class="content-pane" id="completed-configs-pane">
                <div class="container">
                    <h1> Completed Router Configurations</h1>
                    <p style="text-align: center; color: var(--text-color-secondary);">Search and view all generated
                        configurations, sorted by year. Includes port mappings and metadata.</p>

                    <!-- Search and Filter Section -->
                    <div class="section">
                        <h2>Search & Filter</h2>
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div>
                                <label for="configSearch">Search (Customer Code, Device, IP):</label>
                                <input type="text" id="configSearch"
                                    placeholder="e.g., NX-537853, CCR2004, 10.247.72.34"
                                    style="width: 100%; padding: 10px;">
                            </div>
                            <div>
                                <label for="configYearFilter">Filter by Year:</label>
                                <select id="configYearFilter" style="width: 100%; padding: 10px;">
                                    <option value="">All Years</option>
                                </select>
                            </div>
                            <div>
                                <label for="configTypeFilter">Filter by Type:</label>
                                <select id="configTypeFilter" style="width: 100%; padding: 10px;">
                                    <option value="">All Types</option>
                                    <option value="tower">Tower Config</option>
                                    <option value="enterprise">Non-MPLS Enterprise</option>
                                    <option value="mpls-enterprise">MPLS Enterprise</option>
                                </select>
                            </div>
                        </div>
                        <button onclick="searchCompletedConfigs()"
                            style="background: #2196F3; color: white; padding: 12px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">
                            Search</button>
                        <button onclick="loadCompletedConfigs()"
                            style="background: #4CAF50; color: white; padding: 12px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold; margin-left: 10px;">
                            Refresh</button>
                    </div>

                    <!-- Results Section -->
                    <div class="section">
                        <h2>Saved Configurations</h2>
                        <div id="completedConfigsList" style="min-height: 400px;">
                            <p style="text-align: center; color: var(--text-color-secondary); padding: 50px;">Loading
                                configurations...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- LOG HISTORY TAB -->
            <div class="content-pane" id="log-history-pane">
                <div class="container">
                    <h1> Activity Log History</h1>
                    <p style="text-align: center; color: var(--text-color-secondary);">Complete history of all user
                        activities, configurations, and migrations.</p>

                    <!-- Filter Section -->
                    <div class="section">
                        <h2>Filter Logs</h2>
                        <div
                            style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div>
                                <label for="logUserFilter">Filter by User:</label>
                                <input type="text" id="logUserFilter" placeholder="e.g., user"
                                    style="width: 100%; padding: 10px;">
                            </div>
                            <div>
                                <label for="logTypeFilter">Filter by Type:</label>
                                <select id="logTypeFilter" style="width: 100%; padding: 10px;">
                                    <option value="">All Types</option>
                                    <option value="new-config">New Config</option>
                                    <option value="migration">Migration</option>
                                    <option value="upgrade">Upgrade</option>
                                    <option value="aviat-upgrade">Aviat Backhaul Upgrade</option>
                                </select>
                            </div>
                            <div>
                                <label for="logDateFrom">From Date:</label>
                                <input type="date" id="logDateFrom" style="width: 100%; padding: 10px;">
                            </div>
                            <div>
                                <label for="logDateTo">To Date:</label>
                                <input type="date" id="logDateTo" style="width: 100%; padding: 10px;">
                            </div>
                        </div>
                        <button onclick="loadLogHistory()"
                            style="background: #4CAF50; color: white; padding: 12px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold;">
                            Refresh</button>
                        <button onclick="exportLogHistory()"
                            style="background: #2196F3; color: white; padding: 12px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; font-weight: bold; margin-left: 10px;">
                            Export CSV</button>
                    </div>

                    <!-- Monthly Overview -->
                    <div class="section">
                        <div class="section-header-row">
                            <h2 style="margin: 0;">Monthly Activity Overview</h2>
                            <div class="section-subtle">Updated <span id="logMonthlyUpdated"></span></div>
                        </div>
                        <div class="monthly-help">Click a month to auto-fill date filters.</div>
                        <div id="logMonthlySummary" class="monthly-help" style="margin-top: 6px;"></div>
                        <div id="logMonthlyTracker" class="monthly-tracker"></div>
                    </div>

                    <!-- Log History Table -->
                    <div class="section">
                        <h2>Activity Logs</h2>
                        <div style="overflow-x: auto;">
                            <table style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                                <thead>
                                    <tr style="background: var(--sidebar-bg); color: white;">
                                        <th
                                            style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">
                                            Timestamp</th>
                                        <th
                                            style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">
                                            User</th>
                                        <th
                                            style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">
                                            Activity</th>
                                        <th
                                            style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">
                                            Site/Device</th>
                                          <th
                                              style="padding: 12px; text-align: left; border-bottom: 2px solid var(--border-color);">
                                              Firmware</th>
                                        <th
                                            style="padding: 12px; text-align: center; border-bottom: 2px solid var(--border-color);">
                                            Status</th>
                                    </tr>
                                </thead>
                                <tbody id="logHistoryTableBody">
                                    <tr>
                                        <td colspan="6"
                                            style="text-align: center; padding: 50px; color: var(--text-color-secondary);">
                                            Loading log history...</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            </div>

            <!-- ADMIN PANEL TAB -->
            <div class="content-pane" id="admin-panel-pane">
                <div class="container">
                    <h1> Admin Panel - Feedback Management</h1>
                    <p style="text-align: center; color: var(--text-color-secondary);">View and manage user feedback,
                        bug reports, and feature requests.</p>

                    <!-- Filters and Actions -->
                    <div class="section">
                        <h2>Filters & Actions</h2>
                        <div
                            style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px; margin-bottom: 15px;">
                            <div>
                                <label for="adminFeedbackStatusFilter">Status:</label>
                                <select id="adminFeedbackStatusFilter" style="width: 100%; padding: 10px;">
                                    <option value="all">All Status</option>
                                    <option value="new">New</option>
                                    <option value="reviewed">Reviewed</option>
                                    <option value="resolved">Resolved</option>
                                    <option value="closed">Closed</option>
                                </select>
                            </div>
                            <div>
                                <label for="adminFeedbackTypeFilter">Type:</label>
                                <select id="adminFeedbackTypeFilter" style="width: 100%; padding: 10px;">
                                    <option value="all">All Types</option>
                                    <option value="feedback">Feedback</option>
                                    <option value="feature">Feature Request</option>
                                    <option value="bug">Bug Report</option>
                                </select>
                            </div>
                            <div>
                                <button onclick="loadAdminFeedback()"
                                    style="background: #4CAF50; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%;">
                                    Refresh</button>
                            </div>
                            <div>
                                <button onclick="exportAdminFeedback()"
                                    style="background: #2196F3; color: white; padding: 12px 20px; border: none; border-radius: 5px; cursor: pointer; font-size: 14px; font-weight: bold; width: 100%;">
                                    Export Excel</button>
                            </div>
                        </div>
                    </div>

                    <!-- Feedback List -->
                    <div class="section">
                        <h2>Feedback List</h2>
                        <div id="adminFeedbackList" style="min-height: 400px;">
                            <p style="text-align: center; color: var(--text-color-secondary); padding: 50px;">Loading
                                feedback...</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- NOKIA 7250 MAKER TAB -->
            <div class="content-pane" id="nokia7250-maker-pane">
                <div class="container">
                    <div
                        style="background: #ff6b35; color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 5px solid #ff4500;">
                        <strong> IN DEVELOPMENT - DO NOT USE IN PRODUCTION</strong>
                        <p style="margin: 10px 0 0 0; font-size: 14px;">This feature is currently under development and
                            testing. Do not use generated configurations in production environments without thorough
                            review.</p>
                    </div>
                    <h1 style="color: var(--text-color); margin-bottom: 30px;"> IN-STATE Nokia 7250 Configuration
                        Maker</h1>
                    <p style="color: var(--text-color-secondary); margin-bottom: 30px;">
                        Generate Nokia 7250 configurations for in-state sites. Fill in the required fields below. BGP
                        and VPLS settings are automatically configured for in-state deployments.
                    </p>

                    <div class="section"
                        style="background: var(--container-bg); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-color); margin-top: 0;">System Information</h2>
                        <div class="form-group">
                            <label for="nokia7250_systemName">System Name (e.g., RTR-NK7250-TX-BRADSTEST-CN-1):</label>
                            <input type="text" id="nokia7250_systemName" placeholder="RTR-NK7250-TX-BRADSTEST-CN-1"
                                style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                        </div>
                        <div class="form-group">
                            <label for="nokia7250_systemIP">System IP (e.g., 10.42.12.88/32):</label>
                            <input type="text" id="nokia7250_systemIP" placeholder="10.42.12.88/32"
                                style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                        </div>
                        <div class="form-group">
                            <label for="nokia7250_location">Location (Latitude, Longitude):</label>
                            <input type="text" id="nokia7250_location"
                                placeholder="36.06078758688842, -107.96171907927412"
                                style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                        </div>
                    </div>

                    <div class="section"
                        style="background: var(--container-bg); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-color); margin-top: 0;">Port Configuration</h2>
                        <div class="form-group">
                            <label for="nokia7250_port1_desc">Port 1/1/1 Description:</label>
                            <input type="text" id="nokia7250_port1_desc" placeholder="Switch"
                                style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                        </div>
                        <div class="form-group">
                            <label for="nokia7250_port2_desc">Port 1/1/2 Description:</label>
                            <input type="text" id="nokia7250_port2_desc" placeholder="Switch"
                                style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                        </div>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="nokia7250_port2_shutdown" style="margin-right: 8px;">
                                Shutdown Port 1/1/2
                            </label>
                        </div>

                        <!-- Backhauls (Required - Main Configuration) -->
                        <div style="margin-top: 25px; padding-top: 25px; border-top: 2px solid var(--border-color);">
                            <h3 style="color: var(--text-color); margin-top: 0; margin-bottom: 15px;">Backhauls</h3>
                            <p style="color: var(--text-color-secondary); font-size: 13px; margin-bottom: 15px;">
                                Configure backhaul connections. At least one backhaul is required.</p>
                            <div id="nokia7250_backhauls">
                                <div class="backhaul-entry"
                                    style="margin-bottom: 15px; padding: 15px; background: var(--card-bg); border-radius: 4px; border: 1px solid var(--accent-color);">
                                    <div class="form-group">
                                        <label>Backhaul Name:</label>
                                        <input type="text" class="backhaul-name" placeholder="TX-BRADSTEST-EA-1"
                                            style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                    </div>
                                    <div class="form-group">
                                        <label>Backhaul IP/Netmask:</label>
                                        <input type="text" class="backhaul-ip" placeholder="10.10.10.49/29"
                                            style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                    </div>
                                    <button type="button" onclick="removeBackhaul(this)"
                                        style="background: #dc3545; color: white; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Remove</button>
                                </div>
                            </div>
                            <button type="button" onclick="addBackhaul()"
                                style="background: var(--accent-color); color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">+
                                Add Backhaul</button>
                        </div>

                        <!-- Fiber Interface (Optional) -->
                        <div style="margin-top: 25px; padding-top: 25px; border-top: 1px dashed var(--border-color);">
                            <h3
                                style="color: var(--text-color-secondary); margin-top: 0; margin-bottom: 15px; font-size: 16px;">
                                Fiber Interface (Optional)</h3>
                            <div class="form-group">
                                <label>
                                    <input type="checkbox" id="nokia7250_enableFiber" style="margin-right: 8px;">
                                    Enable Fiber Interface
                                </label>
                            </div>
                            <div class="form-group" id="nokia7250_fiberGroup" style="display: none;">
                                <label for="nokia7250_fiber_interface">Fiber Interface Name:</label>
                                <input type="text" id="nokia7250_fiber_interface" placeholder="FIBERCOMM"
                                    style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                            </div>
                            <div class="form-group" id="nokia7250_fiberIPGroup" style="display: none;">
                                <label for="nokia7250_fiber_ip">Fiber Interface IP/Netmask:</label>
                                <input type="text" id="nokia7250_fiber_ip" placeholder="10.42.10.90/30"
                                    style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                            </div>
                        </div>
                    </div>

                    <div class="section"
                        style="background: var(--container-bg); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-color); margin-top: 0;">OSPF Configuration</h2>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="nokia7250_enableOSPF" checked style="margin-right: 8px;">
                                Enable OSPF
                            </label>
                        </div>
                    </div>

                    <div class="section"
                        style="background: var(--container-bg); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-color); margin-top: 0;">BGP Configuration</h2>
                        <div class="form-group">
                            <label>
                                <input type="checkbox" id="nokia7250_enableBGP" checked style="margin-right: 8px;">
                                Enable BGP
                            </label>
                        </div>
                        <div
                            style="background: #2a4a2a; padding: 12px; border-radius: 4px; margin-bottom: 15px; border-left: 3px solid #4CAF50;">
                            <p style="margin: 0; color: #90EE90; font-size: 13px;">
                                <strong> Auto-configured for IN-STATE:</strong> BGP Group "DALLAS-RR" with neighbors
                                10.2.0.107, 10.2.0.108
                            </p>
                        </div>
                    </div>

                    <div class="section"
                        style="background: var(--container-bg); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-color); margin-top: 0;">VPLS Services</h2>
                        <div
                            style="background: #2a4a2a; padding: 12px; border-radius: 4px; margin-bottom: 15px; border-left: 3px solid #4CAF50;">
                            <p style="margin: 0; color: #90EE90; font-size: 13px;">
                                <strong> Auto-configured for IN-STATE:</strong> VPLS Service IDs 1245, 2245, 3245,
                                4245. SDP 101 and SDP 102 are automatically configured in the backend.
                            </p>
                        </div>
                    </div>

                    <div style="margin-top: 30px;">
                        <button onclick="generateNokia7250Config()"
                            style="background: var(--accent-color); color: white; padding: 15px 40px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                             Generate Nokia 7250 Configuration
                        </button>
                    </div>

                    <div id="nokia7250_output" style="margin-top: 30px; display: none;">
                        <div class="section"
                            style="background: var(--container-bg); padding: 20px; border-radius: 8px; border: 2px solid var(--accent-color);">
                            <h3 style="color: var(--accent-color); margin-top: 0;">Generated Configuration</h3>
                            <div style="margin-bottom: 15px;">
                                <button onclick="copyNokia7250Config()"
                                    style="background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                                    Copy</button>
                                <button onclick="downloadNokia7250Config()"
                                    style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">
                                    Download</button>
                            </div>
                            <textarea id="nokia7250_config_output" readonly
                                style="width: 100%; min-height: 500px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; white-space: pre; overflow-x: auto;"></textarea>
                        </div>
                    </div>
                </div>
            </div>

            <!-- NOKIA MIGRATION TAB -->
            <div class="content-pane" id="mikrotik-to-nokia-pane">
                <div class="container">
                    <div
                        style="background: #ff6b35; color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 5px solid #ff4500;">
                        <strong> IN DEVELOPMENT - DO NOT USE IN PRODUCTION</strong>
                        <p style="margin: 10px 0 0 0; font-size: 14px;">This feature is currently under development and
                            testing. Do not use generated configurations in production environments without thorough
                            review.</p>
                    </div>
                    <h1 style="color: var(--text-color); margin-bottom: 30px;"> NOKIA MIGRATION</h1>
                    <p style="color: var(--text-color-secondary); margin-bottom: 30px;">
                        Convert MikroTik RouterOS configurations to Nokia SR OS syntax. Use SSH to fetch config directly
                        from device, or paste manually.
                    </p>

                    <div class="section"
                        style="background: var(--container-bg); padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                        <h2 style="color: var(--text-color); margin-top: 0;">Source Configuration</h2>

                        <!-- SSH Fetch Option (Primary) -->
                        <div
                            style="background: var(--card-bg); padding: 15px; border-radius: 6px; margin-bottom: 20px; border: 2px solid var(--accent-color);">
                            <h3 style="color: var(--accent-color); margin-top: 0; margin-bottom: 15px;"> SSH into
                                Device (Recommended)</h3>
                            <div class="form-group">
                                <label for="nokia_migration_device_ip">Device IP Address:</label>
                                <input type="text" id="nokia_migration_device_ip" placeholder="10.1.1.1"
                                    style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                            </div>
                            <div class="form-group">
                                <label for="nokia_migration_ros_version">RouterOS Version:</label>
                                <select id="nokia_migration_ros_version"
                                    style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                    <option value="7">RouterOS 7.x</option>
                                    <option value="6">RouterOS 6.x</option>
                                </select>
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 12px;">
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label for="nokia_ssh_username">SSH Username:</label>
                                    <input type="text" id="nokia_ssh_username" placeholder="e.g., admin"
                                        style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                </div>
                                <div class="form-group" style="margin-bottom: 0;">
                                    <label for="nokia_ssh_password">SSH Password:</label>
                                    <input type="password" id="nokia_ssh_password" placeholder="Enter password"
                                        style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                </div>
                            </div>
                            <div class="form-group" style="margin-bottom: 12px;">
                                <label for="nokia_ssh_ports">SSH Ports (optional):</label>
                                <input type="text" id="nokia_ssh_ports" placeholder="22,5022"
                                    style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
                                <div style="margin-top: 6px; font-size: 12px; color: var(--text-color-secondary);">
                                    Comma-separated. Default is <code>22</code>, then <code>5022</code>. You can add
                                    custom ports.
                                </div>
                            </div>
                            <button onclick="fetchMikrotikConfigForNokiaMigration()"
                                style="background: var(--accent-color); color: white; padding: 12px 24px; border: none; border-radius: 6px; cursor: pointer; font-weight: bold; width: 100%;">
                                 Fetch Config via SSH (Port 22, then 5022)
                            </button>
                            <div id="nokia_migration_ssh_status"
                                style="margin-top: 10px; padding: 10px; border-radius: 4px; display: none;"></div>
                        </div>

                        <!-- Manual Paste Option (Optional) -->
                        <div
                            style="background: var(--card-bg); padding: 15px; border-radius: 6px; border: 1px dashed var(--border-color);">
                            <h3
                                style="color: var(--text-color-secondary); margin-top: 0; margin-bottom: 15px; font-size: 14px;">
                                 Or Paste Manually (Optional)</h3>
                            <div class="form-group">
                                <label for="mikrotik_nokia_source">Paste MikroTik RouterOS Configuration:</label>
                                <textarea id="mikrotik_nokia_source"
                                    style="width: 100%; min-height: 200px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color); font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5;"
                                    placeholder="Paste your RouterOS configuration here (if not using SSH)..."></textarea>
                            </div>
                        </div>

                        <div class="form-group" style="margin-top: 15px;">
                            <label>
                                <input type="checkbox" id="mikrotik_nokia_preserve_ips" checked
                                    style="margin-right: 8px;">
                                Preserve all IP addresses and network settings
                            </label>
                        </div>
                    </div>

                    <div style="margin-top: 30px;">
                        <button onclick="convertMikrotikToNokia()"
                            style="background: var(--accent-color); color: white; padding: 15px 40px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                             Convert to Nokia Syntax
                        </button>
                        <p style="color: var(--text-color-secondary); font-size: 13px; margin-top: 10px;">
                            <strong>Note:</strong> Use SSH to fetch config automatically, or paste manually if needed.
                        </p>
                    </div>

                    <div id="mikrotik_nokia_output" style="margin-top: 30px; display: none;">
                        <div class="section"
                            style="background: var(--container-bg); padding: 20px; border-radius: 8px; border: 2px solid var(--accent-color);">
                            <h3 style="color: var(--accent-color); margin-top: 0;">Converted Nokia Configuration</h3>
                            <div style="margin-bottom: 15px;">
                                <button onclick="copyMikrotikNokiaConfig()"
                                    style="background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                                    Copy</button>
                                <button onclick="downloadMikrotikNokiaConfig()"
                                    style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">
                                    Download</button>
                            </div>
                            <textarea id="mikrotik_nokia_config_output" readonly
                                style="width: 100%; min-height: 500px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; white-space: pre; overflow-x: auto;"></textarea>
                        </div>
                    </div>
                </div>
            </div>

            <!-- FTTH BNG CONFIGURATION TAB --!>
            <div class="content-pane" id="ftth-pane">
                <div class="container">
                    <h1 style="text-align: center; margin-bottom: 10px;"> FTTH BNG Configuration Generator</h1>
                    <p style="text-align: center; color: var(--text-color-secondary); margin-bottom: 30px;">
                        Generate MikroTik CCR2216 configurations for FTTH OLT deployments
                    </p>

                    <!-- State Selection Tabs -->
            <div style="display: flex; gap: 10px; margin-bottom: 30px; justify-content: center;">
                <button id="ftth_instate_btn" onclick="showFtthStateTab('instate')"
                    style="padding: 12px 30px; background: #4CAF50; border: none; border-radius: 6px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;">
                     IN-STATE
                </button>
                <button id="ftth_outstate_btn" onclick="showFtthStateTab('outstate')"
                    style="padding: 12px 30px; background: #6c757d; border: none; border-radius: 6px; color: white; font-weight: bold; cursor: pointer; font-size: 14px;">
                     OUT-OF-STATE
                </button>
            </div>

            <!-- IN-STATE Configuration Section -->
            <div id="ftth-instate-section" style="display: block;">
                <div class="section">
                    <h2>Router Information</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label for="ftth_site_name_in">Site Name:</label>
                            <input type="text" id="ftth_site_name_in" placeholder="WALLYWEST"
                                oninput="updateFtthRouterIdentity('in')">
                            <small style="color: var(--text-color-secondary); font-size: 11px;">Router identity will be
                                auto-generated</small>
                        </div>
                        <div>
                            <label for="ftth_location_in">Location (GPS Coordinates):</label>
                            <input type="text" id="ftth_location_in" placeholder="32.900249,-97.534145">
                        </div>
                    </div>
                    <div style="margin-top: 10px;">
                        <label for="ftth_routeros_in">RouterOS Version:</label>
                        <select id="ftth_routeros_in">
                            <option value="7.19.4" selected>7.19.4 (Minimum)</option>
                            <option value="7.20.2">7.20.2</option>
                        </select>
                    </div>
                    <div style="margin-top: 10px;">
                        <label>Router Identity (Auto-generated):</label>
                        <input type="text" id="ftth_identity_in" readonly
                            style="background: var(--output-bg); cursor: not-allowed;"
                            placeholder="RTR-MT2216-AR1.WALLYWEST-FTTH-BNG">
                    </div>
                </div>

                <div class="section">
                    <h2>IP Allocations</h2>
                    <div style="background: #2a4a2a; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <strong>Required Subnets:</strong>
                        <ul style="margin: 5px 0; padding-left: 20px; font-size: 13px;">
                            <li>Loopback: /32 (e.g., 10.26.1.111/32)</li>
                            <li>CPE Network: /22 (e.g., 10.30.100.0/22)</li>
                            <li>CGNAT Private: /22 (e.g., 100.80.108.0/22)</li>
                            <li>CGNAT Public: /32 (e.g., 52.128.63.173/32)</li>
                            <li>UNAUTH Network: /22 (e.g., 10.130.100.0/22)</li>
                            <li>OLT Network 1: /29 (e.g., 10.246.46.88/29)</li>
                            <li>OLT Network 2: /29 (Optional, e.g., 10.25.251.24/29)</li>
                        </ul>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label for="ftth_loopback_in">Loopback IP (/32):</label>
                            <input type="text" id="ftth_loopback_in" placeholder="10.26.1.111/32">
                        </div>
                        <div>
                            <label for="ftth_cpe_in">CPE Network (/22):</label>
                            <input type="text" id="ftth_cpe_in" placeholder="10.30.100.0/22">
                        </div>
                        <div>
                            <label for="ftth_cgnat_private_in">CGNAT Private (/22):</label>
                            <input type="text" id="ftth_cgnat_private_in" placeholder="100.80.108.0/22">
                        </div>
                        <div>
                            <label for="ftth_cgnat_public_in">CGNAT Public IP (/32):</label>
                            <input type="text" id="ftth_cgnat_public_in" placeholder="52.128.63.173/32">
                        </div>
                        <div>
                            <label for="ftth_unauth_in">UNAUTH Network (/22):</label>
                            <input type="text" id="ftth_unauth_in" placeholder="10.130.100.0/22">
                        </div>
                        <div>
                            <label for="ftth_olt_network_in">OLT Network 1 (/29):</label>
                            <input type="text" id="ftth_olt_network_in" placeholder="10.246.46.88/29">
                        </div>
                        <div>
                            <label for="ftth_olt_network2_in">OLT Network 2 (/29, Optional):</label>
                            <input type="text" id="ftth_olt_network2_in" placeholder="10.25.251.24/29">
                        </div>
                        <div>
                            <label for="ftth_olt_lag1_in">OLT LAG Name 1 (Suffix):</label>
                            <input type="text" id="ftth_olt_lag1_in" placeholder="TX-LAB-MF2-23"
                                oninput="updateFtthOltLagName('in', 1)">
                        </div>
                        <div>
                            <label for="ftth_olt_lag2_in">OLT LAG Name 2 (Suffix, Optional):</label>
                            <input type="text" id="ftth_olt_lag2_in" placeholder="TX-LAB-MF2-23"
                                oninput="updateFtthOltLagName('in', 2)">
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2>Port & Uplink Configuration</h2>
                    <p style="margin-bottom: 15px; color: var(--text-color-secondary);">Configure ports with IP
                        addresses for OSPF routing, bridge assignment, or switch mode. The tool automatically handles
                        OSPF templates, IP addressing, and MPLS LDP configuration.</p>
                    <div id="ftth_uplink_rows_in">
                        <div class="ftth-uplink-row"
                            style="display: grid; grid-template-columns: repeat(9, minmax(0, 1fr)) 0.6fr; gap: 10px; margin-bottom: 10px; align-items: end;">
                            <div>
                                <label>Port:</label>
                                <select class="ftth-uplink-port">
                                    <option value="sfp28-1">sfp28-1</option>
                                    <option value="sfp28-2">sfp28-2</option>
                                    <option value="sfp28-3">sfp28-3</option>
                                    <option value="sfp28-4">sfp28-4</option>
                                    <option value="sfp28-5">sfp28-5</option>
                                    <option value="sfp28-6">sfp28-6</option>
                                    <option value="sfp28-7">sfp28-7</option>
                                    <option value="sfp28-8">sfp28-8</option>
                                    <option value="sfp28-9">sfp28-9</option>
                                    <option value="sfp28-10">sfp28-10</option>
                                    <option value="sfp28-11">sfp28-11</option>
                                    <option value="sfp28-12">sfp28-12</option>
                                </select>
                            </div>
                            <div>
                                <label>Type:</label>
                                <select class="ftth-uplink-type">
                                    <option value="routed">Routed (OSPF)</option>
                                    <option value="bridge">Bridge</option>
                                    <option value="switch">Switch</option>
                                </select>
                            </div>
                            <div>
                                <label>IP/Net (OSPF):</label>
                                <input type="text" class="ftth-uplink-ip" placeholder="10.1.255.186/30">
                            </div>
                            <div>
                                <label>Speed:</label>
                                <select class="ftth-uplink-speed">
                                    <option value="auto">Auto</option>
                                    <option value="10G-baseSR-LR">10G-baseSR-LR</option>
                                    <option value="25G-baseSR-LR">25G-baseSR-LR</option>
                                </select>
                            </div>
                            <div>
                                <label>Comment:</label>
                                <input type="text" class="ftth-uplink-comment" placeholder="to-CORE-ROUTER">
                            </div>
                            <div>
                                <label>OSPF Cost:</label>
                                <input type="number" class="ftth-uplink-cost" placeholder="10" value="10">
                            </div>
                            <div>
                                <label>MTU:</label>
                                <input type="number" class="ftth-uplink-mtu" value="9000">
                            </div>
                            <div>
                                <label>L2MTU:</label>
                                <input type="number" class="ftth-uplink-l2mtu" value="9212">
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <input type="checkbox" class="ftth-uplink-autoneg">
                                <label style="margin: 0;">Auto-Neg</label>
                            </div>
                            <button type="button" onclick="removeFtthUplinkRow(this)"
                                style="background: #6c757d; color: white; padding: 8px 10px; border: none; border-radius: 4px; cursor: pointer;">
                                Remove
                            </button>
                        </div>
                    </div>
                    <button type="button" onclick="addFtthUplinkRow('in')"
                        style="background: #2196F3; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
                        Add Uplink
                    </button>
                </div>

                <div class="section">
                    <h2>OLT LAG PORTS CONFIGURATION</h2>
                    <p style="margin-bottom: 15px; color: var(--text-color-secondary);">
                        Configure LAG ports for each OLT. Use LAG 1 for sfp28-3,4,5,6. LAG 2 is optional for sfp28-7,8,9,10.
                    </p>
                    <div id="ftth_olt_ports_in" style="margin-bottom: 15px;">
                        <!-- OLT ports will be added here dynamically -->
                    </div>
                    <button type="button" onclick="addFtthOltPorts('in', 1)"
                        style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                        Add OLT LAG 1 Ports
                    </button>
                    <button type="button" onclick="addFtthOltPorts('in', 2)"
                        style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                        Add OLT LAG 2 Ports
                    </button>
                    <button type="button" onclick="clearFtthOltPorts('in')"
                        style="background: #dc3545; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">
                        Clear All Ports
                    </button>
                </div>
            </div>

            <!-- OUT-OF-STATE Configuration Section -->
            <div id="ftth-outstate-section" style="display: none;">
                <div class="section">
                    <h2>Router Information</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label for="ftth_site_name_out">Site Name:</label>
                            <input type="text" id="ftth_site_name_out" placeholder="WALLYWEST"
                                oninput="updateFtthRouterIdentity('out')">
                            <small style="color: var(--text-color-secondary); font-size: 11px;">Router identity will be
                                auto-generated</small>
                        </div>
                        <div>
                            <label for="ftth_location_out">Location (GPS Coordinates):</label>
                            <input type="text" id="ftth_location_out" placeholder="32.900249,-97.534145">
                        </div>
                    </div>
                    <div style="margin-top: 10px;">
                        <label for="ftth_routeros_out">RouterOS Version:</label>
                        <select id="ftth_routeros_out">
                            <option value="7.19.4" selected>7.19.4 (Minimum)</option>
                            <option value="7.20.2">7.20.2</option>
                        </select>
                    </div>
                    <div style="margin-top: 10px;">
                        <label>Router Identity (Auto-generated):</label>
                        <input type="text" id="ftth_identity_out" readonly
                            style="background: var(--output-bg); cursor: not-allowed;"
                            placeholder="RTR-MT2216-AR1.WALLYWEST-FTTH-BNG">
                    </div>
                </div>

                <div class="section">
                    <h2>IP Allocations</h2>
                    <div style="background: #2a4a2a; padding: 15px; border-radius: 5px; margin-bottom: 15px;">
                        <strong>Required Subnets:</strong>
                        <ul style="margin: 5px 0; padding-left: 20px; font-size: 13px;">
                            <li>Loopback: /32 (e.g., 10.26.1.111/32)</li>
                            <li>CPE Network: /22 (e.g., 10.30.100.0/22)</li>
                            <li>CGNAT Private: /22 (e.g., 100.80.108.0/22)</li>
                            <li>CGNAT Public: /32 (e.g., 52.128.63.173/32)</li>
                            <li>UNAUTH Network: /22 (e.g., 10.130.100.0/22)</li>
                            <li>OLT Network 1: /29 (e.g., 10.246.46.88/29)</li>
                            <li>OLT Network 2: /29 (Optional, e.g., 10.25.251.24/29)</li>
                        </ul>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                        <div>
                            <label for="ftth_loopback_out">Loopback IP (/32):</label>
                            <input type="text" id="ftth_loopback_out" placeholder="10.26.1.111/32">
                        </div>
                        <div>
                            <label for="ftth_cpe_out">CPE Network (/22):</label>
                            <input type="text" id="ftth_cpe_out" placeholder="10.30.100.0/22">
                        </div>
                        <div>
                            <label for="ftth_cgnat_private_out">CGNAT Private (/22):</label>
                            <input type="text" id="ftth_cgnat_private_out" placeholder="100.80.108.0/22">
                        </div>
                        <div>
                            <label for="ftth_cgnat_public_out">CGNAT Public IP (/32):</label>
                            <input type="text" id="ftth_cgnat_public_out" placeholder="52.128.63.173/32">
                        </div>
                        <div>
                            <label for="ftth_unauth_out">UNAUTH Network (/22):</label>
                            <input type="text" id="ftth_unauth_out" placeholder="10.130.100.0/22">
                        </div>
                        <div>
                            <label for="ftth_olt_network_out">OLT Network 1 (/29):</label>
                            <input type="text" id="ftth_olt_network_out" placeholder="10.246.46.88/29">
                        </div>
                        <div>
                            <label for="ftth_olt_network2_out">OLT Network 2 (/29, Optional):</label>
                            <input type="text" id="ftth_olt_network2_out" placeholder="10.25.251.24/29">
                        </div>
                        <div>
                            <label for="ftth_olt_lag1_out">OLT LAG Name 1 (Suffix):</label>
                            <input type="text" id="ftth_olt_lag1_out" placeholder="TX-LAB-MF2-23"
                                oninput="updateFtthOltLagName('out', 1)">
                        </div>
                        <div>
                            <label for="ftth_olt_lag2_out">OLT LAG Name 2 (Suffix, Optional):</label>
                            <input type="text" id="ftth_olt_lag2_out" placeholder="TX-LAB-MF2-23"
                                oninput="updateFtthOltLagName('out', 2)">
                        </div>
                    </div>
                </div>

                <div class="section">
                    <h2>Port & Uplink Configuration</h2>
                    <p style="margin-bottom: 15px; color: var(--text-color-secondary);">Configure ports with IP
                        addresses for OSPF routing, bridge assignment, or switch mode. The tool automatically handles
                        OSPF templates, IP addressing, and MPLS LDP configuration.</p>
                    <div id="ftth_uplink_rows_out">
                        <div class="ftth-uplink-row"
                            style="display: grid; grid-template-columns: repeat(9, minmax(0, 1fr)) 0.6fr; gap: 10px; margin-bottom: 10px; align-items: end;">
                            <div>
                                <label>Port:</label>
                                <select class="ftth-uplink-port">
                                    <option value="sfp28-1">sfp28-1</option>
                                    <option value="sfp28-2">sfp28-2</option>
                                    <option value="sfp28-3">sfp28-3</option>
                                    <option value="sfp28-4">sfp28-4</option>
                                    <option value="sfp28-5">sfp28-5</option>
                                    <option value="sfp28-6">sfp28-6</option>
                                    <option value="sfp28-7">sfp28-7</option>
                                    <option value="sfp28-8">sfp28-8</option>
                                    <option value="sfp28-9">sfp28-9</option>
                                    <option value="sfp28-10">sfp28-10</option>
                                    <option value="sfp28-11">sfp28-11</option>
                                    <option value="sfp28-12">sfp28-12</option>
                                </select>
                            </div>
                            <div>
                                <label>Type:</label>
                                <select class="ftth-uplink-type">
                                    <option value="routed">Routed (OSPF)</option>
                                    <option value="bridge">Bridge</option>
                                    <option value="switch">Switch</option>
                                </select>
                            </div>
                            <div>
                                <label>IP/Net (OSPF):</label>
                                <input type="text" class="ftth-uplink-ip" placeholder="10.1.255.186/30">
                            </div>
                            <div>
                                <label>Speed:</label>
                                <select class="ftth-uplink-speed">
                                    <option value="auto">Auto</option>
                                    <option value="10G-baseSR-LR">10G-baseSR-LR</option>
                                    <option value="25G-baseSR-LR">25G-baseSR-LR</option>
                                </select>
                            </div>
                            <div>
                                <label>Comment:</label>
                                <input type="text" class="ftth-uplink-comment" placeholder="to-CORE-ROUTER">
                            </div>
                            <div>
                                <label>OSPF Cost:</label>
                                <input type="number" class="ftth-uplink-cost" placeholder="10" value="10">
                            </div>
                            <div>
                                <label>MTU:</label>
                                <input type="number" class="ftth-uplink-mtu" value="9000">
                            </div>
                            <div>
                                <label>L2MTU:</label>
                                <input type="number" class="ftth-uplink-l2mtu" value="9212">
                            </div>
                            <div style="display: flex; align-items: center; gap: 6px;">
                                <input type="checkbox" class="ftth-uplink-autoneg">
                                <label style="margin: 0;">Auto-Neg</label>
                            </div>
                            <button type="button" onclick="removeFtthUplinkRow(this)"
                                style="background: #6c757d; color: white; padding: 8px 10px; border: none; border-radius: 4px; cursor: pointer;">
                                Remove
                            </button>
                        </div>
                    </div>
                    <button type="button" onclick="addFtthUplinkRow('out')"
                        style="background: #2196F3; color: white; padding: 8px 16px; border: none; border-radius: 4px; cursor: pointer;">
                        Add Uplink
                    </button>
                </div>
                <div class="section">
                    <h2>OLT LAG PORTS CONFIGURATION</h2>
                    <p style="margin-bottom: 15px; color: var(--text-color-secondary);">
                        Configure LAG ports for each OLT. Use LAG 1 for sfp28-3,4,5,6. LAG 2 is optional for sfp28-7,8,9,10.
                    </p>
                    <div id="ftth_olt_ports_out" style="margin-bottom: 15px;">
                        <!-- OLT ports will be added here dynamically -->
                    </div>
                    <button type="button" onclick="addFtthOltPorts('out', 1)"
                        style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                        Add OLT LAG 1 Ports
                    </button>
                    <button type="button" onclick="addFtthOltPorts('out', 2)"
                        style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                        Add OLT LAG 2 Ports
                    </button>
                    <button type="button" onclick="clearFtthOltPorts('out')"
                        style="background: #dc3545; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">
                        Clear All Ports
                    </button>
                </div>
            </div>

            <!-- Error Display -->
            <div id="ftth_error"
                style="display: none; background: #dc3545; color: white; padding: 15px; border-radius: 5px; margin: 20px 0;">
                <!-- Error messages will be displayed here -->
            </div>

            <!-- Action Buttons -->
            <div class="button-group" style="margin-top: 30px;">
                <button onclick="generateFtthBngConfig()"
                    style="background: #4CAF50; color: white; padding: 12px 30px; border: none; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: bold;">
                     Generate Configuration
                </button>
                <button onclick="resetFtthForm()"
                    style="background: #6c757d; color: white; padding: 12px 30px; border: none; border-radius: 6px; cursor: pointer; font-size: 15px; font-weight: bold;">
                     Reset Form
                </button>
            </div>
            <div id="ftth_progress_anchor"></div>

            <!-- Generated Configuration Output -->
            <div id="ftth_output_section" style="display: none; margin-top: 30px;">
                <div class="section"
                    style="background: var(--container-bg); padding: 20px; border-radius: 8px; border: 2px solid #4CAF50;">
                    <h3 style="color: #4CAF50; margin-top: 0;"> Generated FTTH BNG Configuration</h3>
                    <div style="margin-bottom: 15px;">
                        <button onclick="copyFtthConfig()"
                            style="background: #2196F3; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; margin-right: 10px;">
                             Copy to Clipboard
                        </button>
                        <button onclick="downloadFtthConfig()"
                            style="background: #4CAF50; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer;">
                             Download Configuration
                        </button>
                    </div>
                    <textarea id="ftth_config_output" readonly
                        style="width: 100%; min-height: 500px; padding: 15px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--output-bg); color: var(--text-color); font-family: 'Courier New', monospace; font-size: 12px; line-height: 1.5; white-space: pre; overflow-x: auto;"></textarea>
                </div>
            </div>
        </div>
    </div>

    <!-- AVIAT BACKHAUL TAB -->
    <div class="content-pane" id="aviat-backhaul-pane">
        <div class="container aviat-tool">
            <div class="aviat-header">
                <h1>Aviat Backhaul Firmware Updater</h1>
                <p>Backhaul firmware upgrades, buffer policy, and SOP checks in one flow.</p>
            </div>

            <div id="maintenanceBanner" class="aviat-maintenance-banner aviat-maintenance-off">
                OUTSIDE MAINTENANCE WINDOW (2:00 AM - 6:00 AM) | Activation allowed 2:00 AM - 5:00 AM
            </div>

            <div class="aviat-grid">
                <div class="aviat-card">
                    <h2>Tasks to Execute</h2>
                    <label class="checkbox-item">
                        <input type="checkbox" id="taskFirmware" checked>
                        <div>
                            <div class="aviat-task-title">
                                <span class="aviat-task-name">Upload Firmware & Schedule Activation</span>
                                <span class="aviat-task-step">Step 0</span>
                            </div>
                            <div class="aviat-task-desc">Software  Load URI  Activation</div>
                        </div>
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="taskPassword" checked>
                        <div>
                            <div class="aviat-task-title">
                                <span class="aviat-task-name">Change Credentials</span>
                                <span class="aviat-task-step">Step 1</span>
                            </div>
                            <div class="aviat-task-desc">Admin  User Management</div>
                        </div>
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="taskSNMP" checked>
                        <div>
                            <div class="aviat-task-title">
                                <span class="aviat-task-name">Configure SNMP</span>
                                <span class="aviat-task-step">Step 2</span>
                            </div>
                            <div class="aviat-task-desc">System Configuration  SNMP</div>
                        </div>
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="taskBuffer" checked>
                        <div>
                            <div class="aviat-task-title">
                                <span class="aviat-task-name">Run Buffer Script</span>
                                <span class="aviat-task-step">Step 3</span>
                            </div>
                            <div class="aviat-task-desc">QoS  Default Policy  Buffer Size</div>
                        </div>
                    </label>
                    <label class="checkbox-item">
                        <input type="checkbox" id="taskSOP" checked>
                        <div>
                            <div class="aviat-task-title">
                                <span class="aviat-task-name">Recheck SOP / Spec</span>
                                <span class="aviat-task-step">Step 4</span>
                            </div>
                            <div class="aviat-task-desc">Verify firmware, SNMP, QoS</div>
                        </div>
                    </label>
                </div>

                <div class="aviat-card">
                    <h2>Add Radios</h2>
                    <textarea id="ipInput" placeholder="Enter IP addresses (comma or newline separated)&#10;e.g., 10.0.1.100, 10.0.1.101"></textarea>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button id="aviatAddBtn" class="aviat-btn">Add</button>
                        <button id="aviatReplaceBtn" class="aviat-btn secondary">Replace</button>
                    </div>

                    <div id="statsBar" class="aviat-stat-row" style="margin-top: 14px; display: none;">
                        <div>Total: <span id="statTotal">0</span></div>
                        <div>Pending: <span id="statPending">0</span></div>
                        <div>Running: <span id="statProcessing">0</span></div>
                        <div>Loading: <span id="statLoading">0</span></div>
                        <div>Scheduled: <span id="statScheduled">0</span></div>
                        <div>Done: <span id="statSuccess">0</span></div>
                        <div>Failed: <span id="statError">0</span></div>
                    </div>

                    <div id="statsActions" style="display: flex; flex-wrap: wrap; gap: 8px; margin-top: 10px;">
                        <button id="aviatClearDoneBtn" class="aviat-btn secondary">Clear Done</button>
                        <button id="aviatClearAllBtn" class="aviat-btn secondary">Clear All</button>
                        <button id="aviatRefreshBtn" class="aviat-btn secondary">Refresh</button>
                        <button id="aviatCheckStatusBtn" class="aviat-btn secondary">Check Status</button>
                        <button id="activateScheduledBtn" class="aviat-btn">Activate Scheduled</button>
                        <button id="abortBtn" class="aviat-btn danger" disabled>Abort</button>
                        <button id="runBtn" class="aviat-btn success">Run All</button>
                    </div>
                </div>
            </div>

            <div class="aviat-grid" style="margin-top: 16px;">
                <div class="aviat-card">
                    <h2>Firmware Window</h2>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div>
                            <label style="display: block; font-size: 12px; margin-bottom: 6px;">Activation Mode</label>
                            <select id="activationMode">
                                <option value="scheduled">Scheduled</option>
                                <option value="immediate">Activate Now</option>
                                <option value="manual">Manual (Download Only)</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; font-size: 12px; margin-bottom: 6px;">Activation Time</label>
                            <input type="time" id="activationTime" value="02:00">
                        </div>
                        <div style="grid-column: span 2;">
                            <label style="display: block; font-size: 12px; margin-bottom: 6px;">Firmware Target</label>
                            <select id="firmwareTarget">
                                <option value="final">Final (6.1.0)</option>
                                <option value="baseline">Baseline (2.11.11)</option>
                            </select>
                        </div>
                    </div>
                </div>

                <div class="aviat-card" id="radioListCard" style="display: none;">
                    <h2>Radio Queue</h2>
                    <div id="radioList" class="aviat-queue"></div>
                </div>
            </div>

            <div class="aviat-card" style="margin-top: 16px;">
                <div style="display: flex; align-items: center; justify-content: space-between; gap: 10px;">
                    <h2 style="margin: 0;">Activity Log</h2>
                    <div style="display: flex; gap: 6px; flex-wrap: wrap;">
                        <button id="aviatLogRefreshBtn" class="aviat-btn secondary">Refresh</button>
                        <button id="aviatLogStatusBtn" class="aviat-btn secondary">Check Status</button>
                        <button id="aviatReloadUiBtn" class="aviat-btn secondary">Reload UI</button>
                        <button id="aviatClearLogBtn" class="aviat-btn secondary">Clear</button>
                    </div>
                </div>
                <div id="logBox" class="aviat-log" style="margin-top: 10px;">
                    <div class="aviat-log-entry"><span class="aviat-log-time">[--:--:--]</span> Ready. Add radio IPs to begin.</div>
                </div>
            </div>
        </div>
    </div>

    <!-- CISCO CONFIG TAB (Coming Soon) -->
    <div class="content-pane" id="cisco-config-pane">
        <div class="container">
            <div style="text-align: center; padding: 100px 20px; max-width: 800px; margin: 0 auto;">
                <h1 style="color: var(--text-color); margin-bottom: 20px; font-size: 48px;">Cisco Configuration
                    Generator</h1>
                <p style="color: var(--text-color-secondary); font-size: 20px; margin-bottom: 40px; line-height: 1.6;">
                    Cisco router and switch configuration tools are coming soon!
                </p>
                <div
                    style="background: var(--card-bg); border: 2px solid var(--border-color); border-radius: 12px; padding: 40px; margin-top: 40px;">
                    <h2 style="color: var(--accent-color); margin-bottom: 20px; font-size: 28px;"> Under
                        Development</h2>
                    <p style="color: var(--text-color-secondary); font-size: 16px; line-height: 1.8;">
                        We're working hard to bring you comprehensive Cisco configuration generation tools.
                        This will include support for Cisco routers, switches, and network equipment
                        configuration.
                    </p>
                    <div style="margin-top: 30px; padding-top: 30px; border-top: 1px solid var(--border-color);">
                        <p style="color: var(--text-color-secondary); font-size: 14px;">
                            <strong>Expected Features:</strong><br>
                             Router configuration generation for new devices<br>
                             Scripts for adding devices<br>
                             Setting up ports interface<br>
                             Dynamically referencing Policy
                        </p>
                    </div>
                </div>
                <div style="margin-top: 40px;">
                    <button onclick="window.navigateToTab && window.navigateToTab('home')"
                        style="background: var(--accent-color); color: white; padding: 15px 40px; border: none; border-radius: 8px; cursor: pointer; font-size: 16px; font-weight: bold;">
                         Back to Home
                    </button>
                </div>
            </div>
        </div>
    </div>
    </div>
    </div>

    <!-- Policy Reference Section (Collapsible Footer) -->
    <div id="policyReferenceSection"
        style="position: fixed; bottom: 0; left: 0; right: 0; background: var(--bg-color); border-top: 2px solid var(--border-color); z-index: 1000; max-height: 70vh; overflow-y: auto; display: none; box-shadow: 0 -2px 10px rgba(0,0,0,0.2);">
        <div style="padding: 20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h2 style="margin: 0; color: var(--text-color);"> Nextlink Policy Reference</h2>
                <button onclick="togglePolicyReference()"
                    style="background: #dc3545; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; font-weight: bold;">
                    Close</button>
            </div>
            <div id="policyContent" style="color: var(--text-color); line-height: 1.6;">
                <p><strong>This tool automatically follows Nextlink Internet Policy for all generated
                        configurations.</strong></p>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-top: 20px;">
                    <!-- Tower Config Policy -->
                    <div style="background: #e8f5e9; border: 2px solid #4CAF50; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #2e7d32; margin-bottom: 10px; margin-top: 0;"> Tower Config Policy</h3>
                        <div style="font-size: 14px;">
                            <strong>Port Assignments:</strong><br>
                             ether1 = Management (ALWAYS)<br>
                             sfp-sfpplus1-2 = Switches<br>
                             sfp-sfpplus4+ = Backhaul links<br>
                             sfp-sfpplus6 = LTE gear (if present)<br>
                             sfp-sfpplus6-8 = Tarana gear (if present)<br><br>
                            <strong>Features:</strong><br>
                             v6  v7 migration<br>
                             CCR2004 & CCR1036 support<br>
                             MPLS/VPLS & Non-MPLS towers<br>
                             BGP/OSPF routing protocols<br>
                             Standardized security policies
                        </div>
                    </div>

                    <!-- Non-MPLS Enterprise Policy -->
                    <div style="background: #fff3e0; border: 2px solid #FF9800; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #E65100; margin-bottom: 10px; margin-top: 0;"> Non-MPLS Enterprise Policy
                        </h3>
                        <div style="font-size: 14px;">
                            <strong>Port Assignments:</strong><br>
                             ether1 = Management (ALWAYS)<br>
                             ether5-12 = Local services (RPC, switches)<br>
                             ether7-12 = Customer access<br>
                             sfp-sfpplus1-2 = Switches<br>
                             sfp-sfpplus4+ = Backhaul links<br><br>
                            <strong>Features:</strong><br>
                             Bridge-based customer access<br>
                             DHCP pools for customers<br>
                             NAT for internet access<br>
                             No MPLS/VPLS configuration<br>
                             Standard IP routing only
                        </div>
                    </div>

                    <!-- MPLS Enterprise Policy -->
                    <div style="background: #e8f5e9; border: 2px solid #4CAF50; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #2e7d32; margin-bottom: 10px; margin-top: 0;"> MPLS Enterprise Policy</h3>
                        <div style="font-size: 14px;">
                            <strong>Port Assignments:</strong><br>
                             ether1 = Management (ALWAYS)<br>
                             ether5-12 = Local services (RPC, switches)<br>
                             sfp-sfpplus1-2 = Switches<br>
                             sfp-sfpplus4+ = Backhaul links<br>
                             sfp-sfpplus6 = LTE gear (if present)<br><br>
                            <strong>Features:</strong><br>
                             OSPF/BGP routing protocols<br>
                             MPLS/LDP configuration<br>
                             VPLS tunnels for customers<br>
                             RouterOS v6/v7 compatibility<br>
                             Standardized security policies
                        </div>
                    </div>

                    <!-- FTTH BNG Policy -->
                    <div style="background: #e3f2fd; border: 2px solid #2196F3; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #1565C0; margin-bottom: 10px; margin-top: 0;"> FTTH BNG Policy</h3>
                        <div style="font-size: 14px;">
                            <strong>Port Assignments:</strong><br>
                             ether1 = Management (ALWAYS)<br>
                             sfp28-1 = Core uplink (routed/OSPF)<br>
                             sfp28-3/4/5/6 = OLT LAG 1<br>
                             sfp28-7/8/9/10 = OLT LAG 2 (optional)<br><br>
                            <strong>Features:</strong><br>
                             LAG-based OLT uplinks and VLAN bridges<br>
                             DHCP pools for CPE/UNAUTH/CGNAT<br>
                             BGP/OSPF/MPLS baseline templates<br>
                             Standardized firewall and logging
                        </div>
                    </div>

                    <!-- (Removed) Device-specific VLAN policy (will revisit later) -->
                    <!--
                    <div style="background: #e3f2fd; border: 2px solid #2196F3; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #1976D2; margin-bottom: 10px; margin-top: 0;"> VLAN Policy (removed)</h3>
                        <div style="font-size: 14px;">
                            <strong>Port Assignments:</strong><br>
                             ether1 = Management (ALWAYS)<br>
                             ether2-4 = Local services<br>
                             sfp-sfpplus1-2 = Switches<br>
                             sfp-sfpplus4+ = Backhaul links<br>
                             VLAN 3000/4000 = Customer access<br><br>
                            <strong>Features:</strong><br>
                             VLAN 3000 = Primary customer VLAN<br>
                             VLAN 4000 = Secondary customer VLAN<br>
                             DHCP pools for each VLAN<br>
                             OSPF interface templates<br>
                             Bridge-based customer access
                        </div>
                    </div>

                    -->
                    <!-- Tarana BNG1 Policy -->
                    <div style="background: #f3e5f5; border: 2px solid #9C27B0; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #7B1FA2; margin-bottom: 10px; margin-top: 0;"> Tarana Policy (BNG1)</h3>
                        <div style="font-size: 14px;">
                            <strong>Port Assignments:</strong><br>
                             ether1 = Management (ALWAYS)<br>
                             sfp-sfpplus6-8 = Tarana gear<br>
                             sfp-sfpplus1-2 = Switches<br>
                             sfp-sfpplus4+ = Backhaul links<br>
                             UNICORNMGMT = Bridge interface<br><br>
                            <strong>Sectors:</strong><br>
                             ALPHA = Primary sector<br>
                             BETA = Secondary sector<br>
                             GAMMA = Tertiary sector<br>
                             DELTA = Quaternary sector<br>
                             Bridge-based management
                        </div>
                    </div>

                    <!-- Tarana BNG2 Policy -->
                    <div style="background: #e3f2fd; border: 2px solid #2196F3; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #1565C0; margin-bottom: 10px; margin-top: 0;"> Tarana Policy (BNG2 - Out of
                            State)</h3>
                        <div style="font-size: 14px;">
                            <strong>Bridge Assignments:</strong><br>
                             bridge3000 = Management (VLAN 3000)<br>
                             bridge1000 = VLAN 1000<br>
                             bridge2000 = VLAN 2000<br>
                             VLANs: 1000, 2000, 3000 only<br><br>
                            <strong>Sectors:</strong><br>
                             ALPHA = Primary sector<br>
                             BETA = Secondary sector<br>
                             GAMMA = Tertiary sector<br>
                             DELTA = Quaternary sector (Optional - 4 sectors)
                        </div>
                    </div>

                    <!-- Enterprise Feeding Policy -->
                    <div
                        style="background: var(--container-bg); border: 2px solid #4CAF50; border-radius: 8px; padding: 15px;">
                        <h3 style="color: #4CAF50; margin-bottom: 10px; margin-top: 0;"> Enterprise Feeding Policy
                        </h3>
                        <div style="font-size: 14px;">
                            <strong>Port Assignments:</strong><br>
                             ether1 = Management (ALWAYS)<br>
                             ether5-12 = Local services<br>
                             sfp-sfpplus1-2 = Switches<br>
                             sfp-sfpplus4+ = Backhaul links<br>
                             Customer-facing ports = Uplinks<br><br>
                            <strong>Features:</strong><br>
                             Commercial uplink provisioning<br>
                             Enterprise customer access<br>
                             Standardized security policies<br>
                             RouterOS v6/v7 compatibility<br>
                             Bridge-based customer access
                        </div>
                    </div>
                </div>

                <div
                    style="margin-top: 30px; padding: 20px; background: var(--container-bg); border-radius: 8px; border-left: 4px solid #2196F3; border: 1px solid var(--border-color);">
                    <h3 style="color: var(--text-color); margin-top: 0;">General Policy Principles</h3>
                    <ul style="margin-bottom: 0;">
                        <li><strong>Device Port Assignments:</strong> Based on RouterBoard model and Nextlink standards
                        </li>
                        <li><strong>IP Address Management:</strong> Dynamic calculation following Nextlink conventions
                        </li>
                        <li><strong>OSPF/BGP Configuration:</strong> Compliant with Nextlink routing policies</li>
                        <li><strong>Firewall Rules:</strong> Standard Nextlink security baselines</li>
                        <li><strong>DHCP Pools:</strong> Calculated dynamically based on subnet size</li>
                        <li><strong>VLAN Assignments:</strong> Following Nextlink VLAN standards</li>
                        <li><strong>MPLS/VPLS:</strong> Configured per Nextlink enterprise policies</li>
                    </ul>
                </div>

                <p style="margin-top: 20px; font-size: 14px; color: var(--text-color-secondary);">
                    For detailed policy documentation, see: <code>NEXTLINK_INTERNET_POLICY.md</code>
                </p>
            </div>
        </div>
    </div>

    <!-- Policy Reference Toggle Button (Fixed Bottom Right) -->
    <button onclick="togglePolicyReference()" id="policyToggleBtn"
        style="position: fixed; bottom: 20px; right: 20px; background: #FF9800; color: white; border: none; padding: 12px 20px; border-radius: 50px; cursor: pointer; font-size: 14px; font-weight: bold; box-shadow: 0 4px 6px rgba(0,0,0,0.3); z-index: 999;">
         View Policy
    </button>

    <!-- Nextlink Constants - Inlined -->
    <script>
        // Nextlink Configuration Constants (Inlined from nextlink_constants.js)
        const NEXTLINK_INFRASTRUCTURE = {
            dnsServers: {
                primary: '142.147.112.3',
                secondary: '142.147.112.19',
                getList: function () { return `${this.primary},${this.secondary}`; }
            },
            syslogServer: '142.147.116.215',
            ntpServers: {
                default: ['52.128.59.240', '52.128.59.241'],
                custom: ''
            },
            radiusServers: { dhcp: [], login: [] },
            backup: { enabled: false, ftpHost: '', ftpUser: '', ftpPassword: '', ftpPath: 'backups' },
            emailAlerts: { enabled: false, recipient: '', from: '' },
            mpls: { vplsPeer: '10.254.247.3', vplsStaticId: 2245 },
            snmp: { community: 'CHANGE_ME', trapCommunity: 'CHANGE_ME', contact: 'netops@team.nxlink.com' },
            sharedKeys: { ospfBgpMd5: 'm8M5JwvdYM', default: 'CHANGE_ME' }
        };

        // Helper functions for constants access
        function getDnsServers() { return NEXTLINK_INFRASTRUCTURE.dnsServers; }
        function getSyslogServer() { return NEXTLINK_INFRASTRUCTURE.syslogServer; }
        function getNtpServers() { return NEXTLINK_INFRASTRUCTURE.ntpServers; }

        console.log('Nextlink constants loaded (inlined)');
    </script>
    <script>
        // ========================================
        // IMMEDIATE AUTHENTICATION CHECK (Runs before page loads)
        // ========================================
        (function () {
            // Check authentication IMMEDIATELY - before any content loads
            const token = localStorage.getItem('auth_token');
            const userInfo = localStorage.getItem('user_info');

            if (!token || !userInfo) {
                // Not authenticated, redirect to login IMMEDIATELY
                window.location.href = 'login.html';
                return;
            }

            // Verify token is still valid (async, but don't block page load if backend is down)
            // Use same API detection logic as main API_BASE
            const isFileProtocol = window.location.protocol === 'file:';
            const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
            const isLocalDev = isFileProtocol || isLocalhost;

            // IMPORTANT: If accessed via http://, nginx often redirects to https:// with a 301/302.
            // Browsers commonly convert POST -> GET on those redirects, leading to HTTP 405 on API calls.
            // For the Nxlink domain, force https:// to avoid redirect-method changes.
            const shouldForceHttps = !isLocalDev &&
                window.location.protocol === 'http:' &&
                window.location.hostname.endsWith('nxlink.com');
            if (shouldForceHttps) {
                const httpsUrl = `https://${window.location.host}${window.location.pathname}${window.location.search}${window.location.hash}`;
                window.location.replace(httpsUrl);
                return;
            }

            const isNginxRouted = !isFileProtocol && (window.location.pathname === '/' || window.location.pathname.startsWith('/app'));
            const API_BASE = (isLocalDev && !isNginxRouted) ? 'http://localhost:5000' : window.location.origin;

            console.log('[AUTH] API_BASE for authentication:', API_BASE, '(isLocalDev:', isLocalDev, ')');

            // Normalize URL so users don't see .html in the bar (only when not serving from /vm_deployment)
            if (window.location.pathname.match(/\.html$/) && !window.location.pathname.includes('/vm_deployment/')) {
                const targetPath = window.location.pathname.includes('login') ? '/' : '/app';
                window.history.replaceState({}, '', targetPath);
            }
            fetch(`${API_BASE}/api/auth/verify`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ token: token })
            })
                .then(response => response.json())
                .then(data => {
                    if (!data.success || !data.authenticated) {
                        // Token invalid, clear and redirect
                        localStorage.removeItem('auth_token');
                        localStorage.removeItem('user_info');
                        window.location.href = 'login.html';
                    } else {
                        // Update user info
                        localStorage.setItem('user_info', JSON.stringify(data.user));

                        // Check if password change is required
                        if (data.user.firstLogin) {
                            window.location.href = 'change-password.html?firstLogin=true';
                        }
                    }
                })
                .catch(error => {
                    // If backend is down, allow access but log warning
                    console.warn('[AUTH] Backend verification unavailable, continuing with cached token:', error);
                });
        })();

        // ========================================
        // CRITICAL: API BASE URL DETECTION
        // ========================================
        // Auto-detect API server based on current hostname
        // This allows network access: if accessed via IP/domain, API calls go to same origin
        // MUST be defined before any code that uses it

        const isFileProtocol = window.location.protocol === 'file:';
        const isLocalhost = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
        const isLocalDev = isFileProtocol || isLocalhost;
        // For local dev, we often use Live Server (port 8000/5500) while Flask is on 5000
        // If we're on localhost/local file but NOT on port 5000, we should point to port 5000
        let API_BASE;
        const isDockerFrontend = window.location.port === '8000';
        if (isLocalDev && window.location.port !== '5000') {
            if (isDockerFrontend) {
                // Docker dev: nginx proxies /api to backend, so use same-origin.
                API_BASE = window.location.origin;
                console.log('[API] DOCKER FRONTEND MODE - Using same-origin API proxy');
            } else {
                API_BASE = 'http://localhost:5000';
                console.log('[API] LOCAL DEVELOPMENT MODE - Redirecting API calls to localhost:5000');
            }
        } else {
            // PRODUCTION/VM MODE or explicitly on port 5000: Use the same origin
            const shouldForceHttps = window.location.protocol === 'http:' && window.location.hostname.endsWith('nxlink.com');
            API_BASE = shouldForceHttps ? `https://${window.location.host}` : window.location.origin;
            console.log('[API] ORIGIN MODE - Using:', API_BASE);
        }

        window.AI_API_BASE = `${API_BASE}/api`;
        const AI_API_BASE = window.AI_API_BASE; // Local alias for backward compatibility

        function resolveApiBase() {
            const raw = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
            let base = String(raw || '').trim();
            if (!base) return '/api';
            if (!/^https?:\/\//i.test(base) && base[0] !== '/') {
                base = `/${base}`;
            }
            base = base.replace(/\/+$/, '');
            if (!/\/api$/i.test(base)) {
                base = `${base}/api`;
            }
            return base;
        }

        // Comprehensive logging for debugging
        console.log('');
        console.log('[API]  API Configuration Detection:');
        console.log('[API]   Protocol:', window.location.protocol);
        console.log('[API]   Hostname:', window.location.hostname);
        console.log('[API]   Port:', window.location.port || '(default)');
        console.log('[API]   Origin:', window.location.origin);
        console.log('[API]   Full URL:', window.location.href);
        console.log('[API]   Is File Protocol?', isFileProtocol);
        console.log('[API]   Is Localhost?', isLocalhost);
        console.log('[API]   Is Local Dev?', isLocalDev);
        console.log('[API]    API_BASE:', API_BASE);
        console.log('[API]    AI_API_BASE:', window.AI_API_BASE);
        console.log('');

        // CRITICAL CHECK: If we're on the internet but API_BASE is localhost, something is wrong
        if (!isLocalDev && API_BASE.includes('localhost')) {
            console.error('[API]  CRITICAL ERROR: Detected internet access but API_BASE is localhost!');
            console.error('[API] This will cause backend connection failures!');
            console.error('[API] Please report this bug with the above configuration details.');
            alert(' Configuration Error: API is pointing to localhost but you are accessing from the internet. Please contact support.');
        }

        // Define navigateToTab early as a global function (stub, will be replaced later)
        window.navigateToTab = function (tabId) {
            console.warn('[NAV] navigateToTab called before initialization, tabId:', tabId);
            // Will be properly defined later in the initialization code
        };

        // Robust fetch wrapper with retry logic
        async function robustFetch(url, options = {}, retries = 3, delay = 1000) {
            for (let i = 0; i < retries; i++) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 10000); // 10 second timeout

                    const response = await fetch(url, {
                        ...options,
                        signal: controller.signal
                    });
                    clearTimeout(timeoutId);

                    return response;
                } catch (error) {
                    if (i === retries - 1) throw error; // Last retry, throw error
                    if (error.name === 'AbortError') {
                        console.warn(`[FETCH] Request timeout, retrying... (${i + 1}/${retries})`);
                    } else {
                        console.warn(`[FETCH] Request failed, retrying... (${i + 1}/${retries}):`, error.message);
                    }
                    await new Promise(resolve => setTimeout(resolve, delay * (i + 1))); // Exponential backoff
                }
            }
        }

        // Home status strip helpers (homepage "executive" strip)
        function setStatusPill(pillId, valueId, state, valueText) {
            const pill = document.getElementById(pillId);
            const valueEl = document.getElementById(valueId);
            if (pill) {
                pill.classList.remove('ok', 'warn', 'err');
                if (state) pill.classList.add(state);
            }
            if (valueEl && typeof valueText === 'string') valueEl.textContent = valueText;
        }

        function updateHomeStatusStrip(health, backendOnline) {
            const online = !!backendOnline;
            setStatusPill('homeStatusUpdated', 'homeStatusUpdatedValue', online ? '' : 'err', new Date().toLocaleString());

            const globalUpdatedAt = document.getElementById('globalUpdatedAt');
            if (globalUpdatedAt) globalUpdatedAt.textContent = new Date().toLocaleString();

            const globalPill = document.getElementById('globalUpdatedPill');
            if (globalPill) {
                globalPill.classList.remove('ok', 'err');
                globalPill.classList.add(online ? 'ok' : 'err');
            }
        }

        // Check backend health on page load with retries
        (async function checkBackendHealth() {
            let backendOnline = false;
            let lastHealth = null;
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    const response = await robustFetch(`${API_BASE}/api/health`, {
                        method: 'GET'
                    }, 1, 2000); // Single attempt per health check, but robustFetch handles timeout

                    if (response.ok) {
                        const data = await response.json();
                        lastHealth = data;
                        if (data.status === 'online') {
                            backendOnline = true;
                            console.log('[BACKEND]  Backend is online and responding');
                            // Remove warning if it exists
                            const warning = document.getElementById('backend-offline-warning');
                            if (warning) warning.remove();
                            break;
                        }
                    }
                } catch (error) {
                    if (attempt < 3) {
                        console.warn(`[BACKEND] Health check attempt ${attempt}/3 failed, retrying...`);
                        await new Promise(resolve => setTimeout(resolve, 2000));
                    } else {
                        console.error('[BACKEND]  Backend health check failed after 3 attempts:', error.message);
                        // Only show warning if all attempts failed
                        showBackendOfflineWarning();
                    }
                }
            }

            // Store backend status globally
            window.BACKEND_ONLINE = backendOnline;
            window.__LAST_BACKEND_HEALTH = lastHealth;
            updateHomeStatusStrip(lastHealth, backendOnline);
        })();

        function showBackendOfflineWarning() {
            // Don't show duplicate warnings
            if (document.getElementById('backend-offline-warning')) return;

            // Show a visible warning banner at the top of the page
            const warningBanner = document.createElement('div');
            warningBanner.id = 'backend-offline-warning';
            warningBanner.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                background: #dc3545;
                color: white;
                padding: 15px 20px;
                text-align: center;
                font-weight: bold;
                z-index: 10000;
                box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            `;
            warningBanner.innerHTML = `
                 Backend server is offline. The application may not function properly.
                <br><small>Please ensure NOC-ConfigMaker.exe is running and check the console window for errors.</small>
            `;
            document.body.insertBefore(warningBanner, document.body.firstChild);

            // Auto-hide after 10 seconds, but allow manual close
            setTimeout(() => {
                if (warningBanner.parentNode) {
                    warningBanner.style.transition = 'opacity 0.5s';
                    warningBanner.style.opacity = '0.7';
                }
            }, 10000);

            // Allow clicking to dismiss
            warningBanner.style.cursor = 'pointer';
            warningBanner.onclick = () => warningBanner.remove();
        }

        // Infrastructure Configuration Helpers
        // These functions provide safe access to infrastructure settings with fallbacks
        function getInfrastructureValue(path, fallback = '') {
            try {
                if (typeof NEXTLINK_INFRASTRUCTURE === 'undefined') return fallback;
                const keys = path.split('.');
                let value = NEXTLINK_INFRASTRUCTURE;
                for (const key of keys) {
                    if (value && typeof value === 'object' && key in value) {
                        value = value[key];
                    } else {
                        return fallback;
                    }
                }
                return value || fallback;
            } catch (e) {
                console.warn('[CONFIG] Error accessing infrastructure config:', path, e);
                return fallback;
            }
        }

        function getDNSList() {
            // Get DNS servers from NextLink infrastructure configuration (no fallbacks)
            const primary = getInfrastructureValue('dnsServers.primary', '');
            const secondary = getInfrastructureValue('dnsServers.secondary', '');
            if (!primary || !secondary) {
                console.warn('[CONFIG] DNS servers not configured in nextlink_constants.js');
                return ''; // Return empty - must be configured
            }
            return `${primary},${secondary}`;
        }

        function getSyslogServer() {
            return getInfrastructureValue('syslogServer', '');
        }

        function getNTPServer() {
            // Always return default NTP servers, plus custom if configured
            const defaults = ['52.128.59.240', '52.128.59.241'];
            const custom = getInfrastructureValue('ntpServers.custom', '');
            return { defaults: defaults, custom: custom };
        }

        // Get current time in CST/CDT (America/Chicago timezone) as ISO string
        function getCSTTimestamp() {
            const now = new Date();
            // Use toLocaleString with America/Chicago timezone to get correct CST/CDT time
            // Then convert back to ISO format
            const cstString = now.toLocaleString('en-US', {
                timeZone: 'America/Chicago',
                year: 'numeric',
                month: '2-digit',
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit',
                second: '2-digit',
                hour12: false
            });

            // Parse the formatted string and create ISO timestamp
            // Format: MM/DD/YYYY, HH:MM:SS
            const [datePart, timePart] = cstString.split(', ');
            const [month, day, year] = datePart.split('/');
            const [hour, minute, second] = timePart.split(':');

            // Create date object in CST/CDT
            const cstDate = new Date(`${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}T${hour.padStart(2, '0')}:${minute.padStart(2, '0')}:${second.padStart(2, '0')}`);

            // Return as ISO string (this will be in local time, but represents CST/CDT)
            return cstDate.toISOString();
        }

        // Format timestamp for display (CST/CDT)
        function formatCSTTimestamp(timestampString) {
            if (!timestampString) return 'N/A';
            try {
                // Backend already sends CST timestamps in format "YYYY-MM-DD HH:MM:SS"
                // Display them as-is without conversion to avoid double timezone conversion
                // Format: "12/10/2025, 06:46:48" (MM/DD/YYYY, HH:MM:SS)

                // If it's already in ISO format with timezone, parse it
                if (timestampString.includes('T') || timestampString.includes('Z') || timestampString.includes('+')) {
                    const date = new Date(timestampString);
                    return date.toLocaleString('en-US', {
                        timeZone: 'America/Chicago',
                        year: 'numeric',
                        month: '2-digit',
                        day: '2-digit',
                        hour: '2-digit',
                        minute: '2-digit',
                        second: '2-digit',
                        hour12: false
                    });
                }

                // Otherwise, it's a plain CST string from backend - just reformat it nicely
                // Input: "2025-12-10 06:46:48" -> Output: "12/10/2025, 06:46:48"
                const parts = timestampString.split(' ');
                if (parts.length === 2) {
                    const datePart = parts[0]; // "2025-12-10"
                    const timePart = parts[1]; // "06:46:48"
                    const [year, month, day] = datePart.split('-');
                    return `${month}/${day}/${year}, ${timePart}`;
                }

                // Fallback: return as-is
                return timestampString;
            } catch (e) {
                console.error('Error formatting timestamp:', e);
                return timestampString || 'N/A';
            }
        }

        function formatUsernameDisplay(raw) {
            if (!raw || typeof raw !== 'string') return 'unknown';
            const trimmed = raw.trim();
            const atIndex = trimmed.indexOf('@');
            return atIndex > 0 ? trimmed.slice(0, atIndex) : trimmed;
        }

        function sanitizeActivityText(text) {
            if (!text || typeof text !== 'string') return text || '';
            return text.replace(/[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Za-z]{2,}/g, (match) => {
                return formatUsernameDisplay(match);
            });
        }

        function getRADIUSDHCPServers() {
            const servers = getInfrastructureValue('radiusServers.dhcp', []);
            return Array.isArray(servers) ? servers : [];
        }

        function getRADIUSLoginServers() {
            const servers = getInfrastructureValue('radiusServers.login', []);
            return Array.isArray(servers) ? servers : [];
        }

        // Device-specific configurations
        const DEVICE_CONFIGS = {
            rb1009: {
                name: 'RB1009',
                ports: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10'],
                sfpPorts: [],
                maxUplinks: 2,
                features: ['basic-routing', 'dhcp', 'firewall'],
                routerOS: ['6.x', '7.x'],
                ospfSyntax: 'v6', // Uses /routing ospf interface and /routing ospf network
                bgpSyntax: 'v6'   // Uses /routing bgp instance and /routing bgp peer
            },
            rb2011: {
                name: 'RB2011',
                ports: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10'],
                sfpPorts: ['sfp1'],
                maxUplinks: 3,
                features: ['basic-routing', 'dhcp', 'firewall', 'mpls'],
                routerOS: ['6.x', '7.x'],
                ospfSyntax: 'v6', // Uses /routing ospf interface and /routing ospf network
                bgpSyntax: 'v6',   // Uses /routing bgp instance and /routing bgp peer
                mplsMtu: 1600
            },
            ccr1036: {
                name: 'CCR1036',
                ports: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10', 'ether11', 'ether12'], // 12 Gigabit ethernet ports
                sfpPorts: ['sfp1', 'sfp2', 'sfp3', 'sfp4'], // 4 SFP ports (not SFP+)
                maxUplinks: 4,
                features: ['advanced-routing', 'dhcp', 'firewall', 'mpls', 'bgp', 'ospf'],
                routerOS: ['6.x', '7.x'],
                ospfSyntax: 'v6', // Uses /routing ospf interface and /routing ospf network
                bgpSyntax: 'v6',   // Uses /routing bgp instance and /routing bgp peer
                mplsMtu: 1600
            },
            rb5009: {
                name: 'RB5009',
                // RB5009UG+S+ has 8 ethernet ports (7x 1G + 1x 2.5G) and 1 SFP+ port
                ports: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8'],
                sfpPorts: ['sfp-sfpplus1'], // Single SFP+ uplink port on RB5009
                maxUplinks: 2,
                features: ['advanced-routing', 'dhcp', 'firewall', 'mpls', 'bgp', 'ospf'],
                routerOS: ['7.x'],
                ospfSyntax: 'v7', // Uses /routing ospf interface-template
                bgpSyntax: 'v7',   // Uses /routing bgp template and /routing bgp connection
                mplsMtu: 1600
            },
            ccr2004: {
                name: 'CCR2004',
                // CCR2004-1G-12S+2XS: 1x copper, 12x SFP+, 2x SFP28
                ports: ['ether1'],
                sfpPorts: [
                    'sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4',
                    'sfp-sfpplus5', 'sfp-sfpplus6', 'sfp-sfpplus7', 'sfp-sfpplus8',
                    'sfp-sfpplus9', 'sfp-sfpplus10', 'sfp-sfpplus11', 'sfp-sfpplus12',
                    'sfp28-1', 'sfp28-2'
                ],
                maxUplinks: 4,
                features: ['advanced-routing', 'dhcp', 'firewall', 'mpls', 'bgp', 'ospf'],
                routerOS: ['7.x'],
                ospfSyntax: 'v7', // Uses /routing ospf interface-template
                bgpSyntax: 'v7',   // Uses /routing bgp template and /routing bgp connection
                mplsMtu: 1600
            },
            ccr2116: {
                name: 'CCR2116',
                ports: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10', 'ether11', 'ether12'],
                sfpPorts: ['sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4'],
                maxUplinks: 6,
                features: ['advanced-routing', 'dhcp', 'firewall', 'mpls', 'bgp', 'ospf'],
                routerOS: ['7.x'],
                ospfSyntax: 'v7', // Uses /routing ospf interface-template
                bgpSyntax: 'v7',   // Uses /routing bgp template and /routing bgp connection
                mplsMtu: 1600
            },
            ccr2216: {
                name: 'CCR2216',
                ports: ['ether1'], // CCR2216 has only 1 ethernet port
                sfpPorts: [
                    // QSFP28 ports (8 total)
                    'qsfp28-1-1', 'qsfp28-1-2', 'qsfp28-1-3', 'qsfp28-1-4',
                    'qsfp28-2-1', 'qsfp28-2-2', 'qsfp28-2-3', 'qsfp28-2-4',
                    // SFP28 ports (12 total)
                    'sfp28-1', 'sfp28-2', 'sfp28-3', 'sfp28-4', 'sfp28-5', 'sfp28-6',
                    'sfp28-7', 'sfp28-8', 'sfp28-9', 'sfp28-10', 'sfp28-11', 'sfp28-12'
                ],
                maxUplinks: 6,
                features: ['advanced-routing', 'dhcp', 'firewall', 'mpls', 'bgp', 'ospf'],
                routerOS: ['7.x'],
                ospfSyntax: 'v7', // Uses /routing ospf interface-template
                bgpSyntax: 'v7',   // Uses /routing bgp template and /routing bgp connection
                mplsMtu: 1600
            },
            ccr1072: {
                name: 'CCR1072',
                ports: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10', 'ether11', 'ether12'],
                sfpPorts: ['sfp1', 'sfp2', 'sfp3', 'sfp4'],
                maxUplinks: 4,
                features: ['advanced-routing', 'dhcp', 'firewall', 'mpls', 'bgp', 'ospf'],
                routerOS: ['6.x', '7.x'],
                ospfSyntax: 'v6', // Uses /routing ospf interface and /routing ospf network
                bgpSyntax: 'v6',   // Uses /routing bgp instance and /routing bgp peer
                mplsMtu: 1600
            }
        };

        // RouterOS Version Type Detection
        function getRouterOSVersionType(version) {
            const routerOSVersions = {
                '6.45.2': 'classic',
                '6.49.2': 'classic',
                '7.11.2': 'classic',
                '7.16.2': 'new',
                '7.19.4': 'new'
            };
            return routerOSVersions[version] || 'classic';
        }

        // Get Speed Syntax based on RouterOS version
        function getSpeedSyntax(routerOSVersion, port) {
            const versionType = getRouterOSVersionType(routerOSVersion);

            if (versionType === 'new') {
                // RouterOS 7.16.2+ syntax - Nextlink standard is 1G-baseT-full for 1G links
                // Use 1G-baseT-full for both copper and SFP+ 1G profiles unless user overrides
                return '1G-baseT-full';
            } else {
                // RouterOS classic syntax (7.11.2 and below)
                if (port.includes('sfp') || port.includes('qsfp')) {
                    return '1Gbps'; // SFP speed (no duplex parameter)
                } else {
                    return '1Gbps'; // Ethernet speed (no duplex parameter)
                }
            }
        }

        // Enterprise Feeding Device Selection Handler
        function handleEnterpriseFeedingDeviceChange() {
            const deviceSelect = document.getElementById('ent_feeding_device');
            const portSelect = document.getElementById('ent_feeding_port');

            if (!deviceSelect || !portSelect) return;

            const selectedDevice = deviceSelect.value || 'ccr2004';
            const deviceConfig = DEVICE_CONFIGS[selectedDevice];

            if (!deviceConfig) {
                portSelect.innerHTML = '<option value="">Select Port (Choose Device First)</option>';
                return;
            }

            // Clear existing options
            portSelect.innerHTML = '<option value="">Select Port</option>';

            // Add all available ports (ethernet + SFP)
            const allPorts = [...deviceConfig.ports, ...deviceConfig.sfpPorts];

            allPorts.forEach(port => {
                const option = document.createElement('option');
                option.value = port;
                option.textContent = `${port} (${deviceConfig.name})`;
                portSelect.appendChild(option);
            });
        }

        // Enterprise Feeding RouterOS Version Handler
        function handleEnterpriseFeedingRouterOSChange() {
            const routerOSSelect = document.getElementById('ent_feeding_routeros');
            const speedSelect = document.getElementById('ent_feeding_speed');
            if (!routerOSSelect || !speedSelect) return;

            const selectedVersion = routerOSSelect.value;
            if (!selectedVersion) {
                speedSelect.innerHTML = '<option value="auto">Auto Negotiation</option>';
                return;
            }

            const versionType = getRouterOSVersionType(selectedVersion);

            // Clear existing options
            speedSelect.innerHTML = '<option value="auto">Auto Negotiation</option>';

            if (versionType === 'new') {
                // RouterOS 7.16.1+ (New syntax: 7.16.2, 7.19.4)
                speedSelect.innerHTML += `
                    <option value="1G-baseT-full">1G-baseT-full</option>
                    <option value="1G-baseSX-full">1G-baseSX-full</option>
                    <option value="1G-baseLX-full">1G-baseLX-full</option>
                    <option value="10G-baseSR-full">10G-baseSR-full</option>
                    <option value="10G-baseLR-full">10G-baseLR-full</option>
                    <option value="10G-baseCR">10G-baseCR</option>
                    <option value="10G-baseT-full">10G-baseT-full</option>
                    <option value="25G-baseCR">25G-baseCR</option>
                `;
                console.log(`RouterOS ${selectedVersion} - Using new speed syntax (e.g., 1G-baseT-full)`);
            } else {
                // RouterOS 7.11.2 and below (classic syntax: 6.45.2, 6.49.2, 7.11.2)
                speedSelect.innerHTML += `
                    <option value="10Mbps">10Mbps</option>
                    <option value="100Mbps">100Mbps</option>
                    <option value="1Gbps">1Gbps</option>
                    <option value="10Gbps">10Gbps</option>
                `;
                console.log(`RouterOS ${selectedVersion} - Using classic speed syntax (e.g., 10Gbps)`);
            }
        }

        // Enterprise Config Device Selection Handler
        function handleEnterpriseDeviceChange() {
            const deviceSelect = document.getElementById('ent_routerboard_device');
            if (!deviceSelect) return;

            const selectedDevice = deviceSelect.value;
            const deviceConfig = DEVICE_CONFIGS[selectedDevice];

            if (!deviceConfig) {
                console.log('No device configuration found');
                return;
            }

            console.log(`Enterprise Config - Device selected: ${deviceConfig.name}`);
            console.log(`Available ports: ${[...deviceConfig.ports, ...deviceConfig.sfpPorts].join(', ')}`);
        }

        // Enterprise Config RouterOS Version Handler
        function handleEnterpriseRouterOSChange() {
            const routerOSSelect = document.getElementById('ent_routeros_version');
            if (!routerOSSelect) return;

            const selectedVersion = routerOSSelect.value;
            const versionType = getRouterOSVersionType(selectedVersion);

            if (versionType === 'new') {
                console.log(`Enterprise Config - RouterOS ${selectedVersion} - Using new speed syntax (e.g., 1G-baseT-full)`);
            } else {
                console.log(`Enterprise Config - RouterOS ${selectedVersion} - Using classic speed syntax (e.g., 1Gbps-duplex=full)`);
            }
        }
        // MPLS Enterprise Config Device Selection Handler
        function handleMplsEnterpriseDeviceChange() {
            const deviceSelect = document.getElementById('ent_mpls_routerboard_device');
            if (!deviceSelect) return;

            const selectedDevice = deviceSelect.value;
            const deviceConfig = DEVICE_CONFIGS[selectedDevice];

            if (!deviceConfig) {
                console.log('No device configuration found');
                return;
            }

            console.log(`MPLS Enterprise Config - Device selected: ${deviceConfig.name}`);
            console.log(`Available ports: ${[...deviceConfig.ports, ...deviceConfig.sfpPorts].join(', ')}`);
        }
        // MPLS Enterprise Config RouterOS Version Handler
        function handleMplsEnterpriseRouterOSChange() {
            const routerOSSelect = document.getElementById('ent_mpls_routeros_version');
            if (!routerOSSelect) return;

            const selectedVersion = routerOSSelect.value;
            const versionType = getRouterOSVersionType(selectedVersion);

            if (versionType === 'new') {
                console.log(`MPLS Enterprise Config - RouterOS ${selectedVersion} - Using new speed syntax (e.g., 1G-baseT-full)`);
            } else {
                console.log(`MPLS Enterprise Config - RouterOS ${selectedVersion} - Using classic speed syntax (e.g., 1Gbps-duplex=full)`);
            }
        }

        // 6GHz Switch Config - State Tab Toggle (make globally accessible)
        window.showGhzStateTab = function (tab) {
            const instateSection = document.getElementById('ghz-instate-section');
            const outstateSection = document.getElementById('ghz-outstate-section');
            const instateBtn = document.getElementById('ghz_instate_btn');
            const outstateBtn = document.getElementById('ghz_outstate_btn');

            if (tab === 'instate') {
                if (instateSection) instateSection.style.display = 'block';
                if (outstateSection) outstateSection.style.display = 'none';
                if (instateBtn) {
                    instateBtn.style.background = '#4CAF50';
                    instateBtn.classList.add('active');
                }
                if (outstateBtn) {
                    outstateBtn.style.background = '#6c757d';
                    outstateBtn.classList.remove('active');
                }
            } else if (tab === 'outstate') {
                if (instateSection) instateSection.style.display = 'none';
                if (outstateSection) outstateSection.style.display = 'block';
                if (instateBtn) {
                    instateBtn.style.background = '#6c757d';
                    instateBtn.classList.remove('active');
                }
                if (outstateBtn) {
                    outstateBtn.style.background = '#4CAF50';
                    outstateBtn.classList.add('active');
                }
            }
        }

        // MikroTik Switch Maker - State Tab Toggle
        window.showSwitchStateTab = function (tab) {
            const instateSection = document.getElementById('switch-instate-section');
            const outstateSection = document.getElementById('switch-outstate-section');
            const instateBtn = document.getElementById('switch_instate_btn');
            const outstateBtn = document.getElementById('switch_outstate_btn');

            if (tab === 'instate') {
                if (instateSection) instateSection.style.display = 'block';
                if (outstateSection) outstateSection.style.display = 'none';
                if (instateBtn) {
                    instateBtn.style.background = '#4CAF50';
                    instateBtn.classList.add('active');
                }
                if (outstateBtn) {
                    outstateBtn.style.background = '#6c757d';
                    outstateBtn.classList.remove('active');
                }
            } else if (tab === 'outstate') {
                if (instateSection) instateSection.style.display = 'none';
                if (outstateSection) outstateSection.style.display = 'block';
                if (instateBtn) {
                    instateBtn.style.background = '#6c757d';
                    instateBtn.classList.remove('active');
                }
                if (outstateBtn) {
                    outstateBtn.style.background = '#4CAF50';
                    outstateBtn.classList.add('active');
                }
            }
        }

        // Enterprise Feeding Side - State Tab Toggle
        window.showEntFeedingStateTab = function (tab) {
            const instateSection = document.getElementById('ent-feeding-instate-section');
            const outstateSection = document.getElementById('ent-feeding-outstate-section');
            const instateBtn = document.getElementById('ent_feeding_instate_btn');
            const outstateBtn = document.getElementById('ent_feeding_outstate_btn');

            if (tab === 'instate') {
                if (instateSection) instateSection.style.display = 'block';
                if (outstateSection) outstateSection.style.display = 'none';
                if (instateBtn) {
                    instateBtn.style.background = '#4CAF50';
                    instateBtn.classList.add('active');
                }
                if (outstateBtn) {
                    outstateBtn.style.background = '#6c757d';
                    outstateBtn.classList.remove('active');
                }
            } else if (tab === 'outstate') {
                if (instateSection) instateSection.style.display = 'none';
                if (outstateSection) outstateSection.style.display = 'block';
                if (instateBtn) {
                    instateBtn.style.background = '#6c757d';
                    instateBtn.classList.remove('active');
                }
                if (outstateBtn) {
                    outstateBtn.style.background = '#4CAF50';
                    outstateBtn.classList.add('active');
                }
            }
        }

        // Get available ports for switch type
        function getSwitchPorts(switchType) {
            const ports = {
                '309': {
                    ethernet: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10'],
                    sfp: ['sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4', 'sfp-sfpplus5', 'sfp-sfpplus6', 'sfp-sfpplus7', 'sfp-sfpplus8', 'sfp-sfpplus9', 'sfp-sfpplus10']
                },
                '326': {
                    ethernet: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10', 'ether11', 'ether12', 'ether13', 'ether14', 'ether15', 'ether16', 'ether17', 'ether18', 'ether19', 'ether20', 'ether21', 'ether22'],
                    sfp: ['sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4', 'sfp-sfpplus5', 'sfp-sfpplus6', 'sfp-sfpplus7', 'sfp-sfpplus8', 'sfp-sfpplus9', 'sfp-sfpplus10', 'sfp-sfpplus11', 'sfp-sfpplus12', 'sfp-sfpplus13', 'sfp-sfpplus14', 'sfp-sfpplus15', 'sfp-sfpplus16', 'sfp-sfpplus17', 'sfp-sfpplus18', 'sfp-sfpplus19', 'sfp-sfpplus20', 'sfp-sfpplus21', 'sfp-sfpplus22', 'sfp-sfpplus23', 'sfp-sfpplus24']
                },
                '2004': {
                    ethernet: ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10', 'ether11', 'ether12', 'ether13', 'ether14', 'ether15', 'ether16', 'ether17', 'ether18', 'ether19', 'ether20', 'ether21', 'ether22'],
                    sfp: ['sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4', 'sfp-sfpplus5', 'sfp-sfpplus6', 'sfp-sfpplus7', 'sfp-sfpplus8', 'sfp-sfpplus9', 'sfp-sfpplus10', 'sfp-sfpplus11', 'sfp-sfpplus12', 'sfp-sfpplus13', 'sfp-sfpplus14', 'sfp-sfpplus15', 'sfp-sfpplus16', 'sfp-sfpplus17', 'sfp-sfpplus18', 'sfp-sfpplus19', 'sfp-sfpplus20', 'sfp-sfpplus21', 'sfp-sfpplus22', 'sfp-sfpplus23', 'sfp-sfpplus24']
                }
            };
            return ports[switchType] || { ethernet: [], sfp: [] };
        }

        // Update port dropdowns based on switch type
        window.updateSwitchPorts = function (state) {
            const switchType = state === 'instate'
                ? document.getElementById('switch_maker_type')?.value
                : document.getElementById('switch_outstate_type')?.value;

            if (!switchType) return;

            const ports = getSwitchPorts(switchType);
            const allPorts = [...ports.ethernet, ...ports.sfp];

            // Update uplink port dropdowns
            const uplink1Id = state === 'instate' ? 'switch_maker_uplink1' : 'switch_outstate_uplink1';
            const uplink2Id = state === 'instate' ? 'switch_maker_uplink2' : 'switch_outstate_uplink2';

            const uplink1Select = document.getElementById(uplink1Id);
            const uplink2Select = document.getElementById(uplink2Id);

            if (uplink1Select) {
                uplink1Select.innerHTML = '<option value="">Select Port</option>';
                allPorts.forEach(port => {
                    const option = document.createElement('option');
                    option.value = port;
                    option.textContent = port;
                    uplink1Select.appendChild(option);
                });
            }

            if (uplink2Select) {
                uplink2Select.innerHTML = '<option value="">Select Port</option>';
                allPorts.forEach(port => {
                    const option = document.createElement('option');
                    option.value = port;
                    option.textContent = port;
                    uplink2Select.appendChild(option);
                });
            }

            // Update any existing port dropdowns in the dynamic port list
            const containerId = state === 'instate' ? 'switch_ports_container' : 'switch_outstate_ports_container';
            const container = document.getElementById(containerId);
            if (container) {
                const portSelects = container.querySelectorAll('select[data-port-select]');
                portSelects.forEach(select => {
                    const currentValue = select.value;
                    select.innerHTML = '<option value="">Select Port</option>';
                    allPorts.forEach(port => {
                        const option = document.createElement('option');
                        option.value = port;
                        option.textContent = port;
                        if (port === currentValue) option.selected = true;
                        select.appendChild(option);
                    });
                });
            }
        }

        // Add a new port row
        window.addSwitchPort = function (state) {
            const containerId = state === 'instate' ? 'switch_ports_container' : 'switch_outstate_ports_container';
            const container = document.getElementById(containerId);
            if (!container) return;

            const switchType = state === 'instate'
                ? document.getElementById('switch_maker_type')?.value
                : document.getElementById('switch_outstate_type')?.value;

            if (!switchType) {
                alert('Please select a switch type first');
                return;
            }

            const ports = getSwitchPorts(switchType);
            const allPorts = [...ports.ethernet, ...ports.sfp];

            const portRow = document.createElement('div');
            portRow.className = 'port-row';
            portRow.style.cssText = 'display: grid; grid-template-columns: 2fr 3fr auto; gap: 10px; margin-bottom: 10px; align-items: center; padding: 10px; background: var(--card-bg); border-radius: 5px;';

            const portSelect = document.createElement('select');
            portSelect.setAttribute('data-port-select', 'true');
            portSelect.style.cssText = 'padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);';
            portSelect.innerHTML = '<option value="">Select Port</option>';
            allPorts.forEach(port => {
                const option = document.createElement('option');
                option.value = port;
                option.textContent = port;
                portSelect.appendChild(option);
            });

            const commentInput = document.createElement('input');
            commentInput.type = 'text';
            commentInput.placeholder = 'e.g., AP1 Cambium 6ghz';
            commentInput.style.cssText = 'padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);';

            const removeBtn = document.createElement('button');
            removeBtn.textContent = '';
            removeBtn.onclick = () => portRow.remove();
            removeBtn.style.cssText = 'background: #dc3545; color: white; border: none; border-radius: 4px; padding: 8px 12px; cursor: pointer;';

            portRow.appendChild(portSelect);
            portRow.appendChild(commentInput);
            portRow.appendChild(removeBtn);

            container.appendChild(portRow);
        }

        // Copy switch config to clipboard
        window.copySwitchConfig = function (state) {
            const output = document.getElementById('switch_maker_output');
            if (!output || !output.value) {
                alert('No configuration to copy');
                return;
            }
            output.select();
            document.execCommand('copy');
            alert('Configuration copied to clipboard!');
        }

        // Generate switch configuration
        window.generateSwitchConfig = async function (state) {
            try {
                // Show progress tracker
                window.showProgressTracker('MikroTik Switch Configuration Generation');
                window.updateProgressStep('Initializing switch configuration...');
                window.updateProgressPercent(5);
                await new Promise(resolve => setTimeout(resolve, 300));

                // Get form values
                const switchType = state === 'instate'
                    ? document.getElementById('switch_maker_type')?.value
                    : document.getElementById('switch_outstate_type')?.value;
                const routerOS = state === 'instate'
                    ? document.getElementById('switch_maker_routeros')?.value
                    : document.getElementById('switch_outstate_routeros')?.value;
                const switchName = state === 'instate'
                    ? document.getElementById('switch_maker_name')?.value.trim()
                    : document.getElementById('switch_outstate_name')?.value.trim();
                const gps = state === 'instate'
                    ? document.getElementById('switch_maker_gps')?.value.trim()
                    : document.getElementById('switch_outstate_gps')?.value.trim();
                const mgmtIP = state === 'instate'
                    ? document.getElementById('switch_maker_ip')?.value.trim()
                    : document.getElementById('switch_outstate_ip')?.value.trim();
                const gateway = state === 'instate'
                    ? document.getElementById('switch_maker_gateway')?.value.trim()
                    : document.getElementById('switch_outstate_gateway')?.value.trim();
                const uplink1 = state === 'instate'
                    ? document.getElementById('switch_maker_uplink1')?.value
                    : document.getElementById('switch_outstate_uplink1')?.value;
                const uplink2 = state === 'instate'
                    ? document.getElementById('switch_maker_uplink2')?.value
                    : document.getElementById('switch_outstate_uplink2')?.value;

                // Debug logging
                console.log('[SWITCH CONFIG] Form values:', {
                    switchType, routerOS, switchName, gps, mgmtIP, gateway, uplink1, uplink2
                });

                // Validate required fields with detailed error messages
                const missingFields = [];
                if (!switchType || switchType === '') missingFields.push('Switch Type');
                if (!routerOS || routerOS === '') missingFields.push('RouterOS Version');
                if (!switchName || switchName === '') missingFields.push('Switch Name');
                if (!gps || gps === '') missingFields.push('GPS Coordinates');
                if (!mgmtIP || mgmtIP === '') missingFields.push('Management IP (VLAN 3000)');
                if (!gateway || gateway === '') missingFields.push('Default Gateway');
                if (!uplink1 || uplink1 === '') missingFields.push('Router Uplink Port 1');
                if (!uplink2 || uplink2 === '') missingFields.push('Router Uplink Port 2');

                if (missingFields.length > 0) {
                    const errorMsg = `Please fill in the following required fields:\n\n${missingFields.join('\n')}`;
                    console.warn('[SWITCH CONFIG] Validation failed. Missing fields:', missingFields);
                    window.addProgressLog('error', `Missing required fields: ${missingFields.join(', ')}`);
                    window.completeProgressTracker(false);
                    alert(errorMsg);
                    return;
                }

                window.updateProgressStep('Collecting port configurations...');
                window.updateProgressPercent(10);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Collect dynamic ports
                const containerId = state === 'instate' ? 'switch_ports_container' : 'switch_outstate_ports_container';
                const container = document.getElementById(containerId);
                const ports = [];
                if (container) {
                    const portRows = container.querySelectorAll('.port-row');
                    portRows.forEach(row => {
                        const portSelect = row.querySelector('select[data-port-select]');
                        const commentInput = row.querySelector('input[type="text"]');
                        if (portSelect && portSelect.value && commentInput) {
                            ports.push({
                                port: portSelect.value,
                                comment: commentInput.value.trim() || ''
                            });
                        }
                    });
                }

                window.updateProgressStep('Generating base configuration...');
                window.updateProgressPercent(20);
                await new Promise(resolve => setTimeout(resolve, 300));

                // Extract IP and prefix from mgmtIP
                const ipParts = mgmtIP.split('/');
                const ipAddress = ipParts[0];
                const prefix = ipParts[1] || '27';

                // Determine if in-state or out-of-state (based on IP range)
                const isInState = state === 'instate';

                // Generate configuration
                let config = '';

                // Bridge configuration
                config += '/interface bridge add ingress-filtering=no name=lan-bridge protocol-mode=mstp region-name=MSTP region-revision=1 vlan-filtering=yes\n\n';

                window.updateProgressStep('Configuring interfaces...');
                window.updateProgressPercent(30);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Interface ethernet settings with comments
                ports.forEach(port => {
                    let line = `/interface ethernet set [ find default-name=${port.port} ]`;
                    if (port.comment) {
                        line += ` comment="${port.comment}"`;
                    }
                    // Special handling for sfp-sfpplus14 (FTTH site host)
                    if (port.port === 'sfp-sfpplus14' && port.comment && port.comment.toLowerCase().includes('ftth')) {
                        line += ` auto-negotiation=no speed=1G-baseX`;
                    }
                    // Special handling for uplink ports
                    if (port.port === uplink1 || port.port === uplink2) {
                        line += ` l2mtu=9212 loop-protect=off`;
                    }
                    config += line + '\n';
                });

                // Add uplink ports if not already in ports list
                if (uplink1 && !ports.find(p => p.port === uplink1)) {
                    config += `/interface ethernet set [ find default-name=${uplink1} ] comment="Router Uplink 1" l2mtu=9212 loop-protect=off\n`;
                }
                if (uplink2 && !ports.find(p => p.port === uplink2)) {
                    config += `/interface ethernet set [ find default-name=${uplink2} ] comment="Router Uplink 2" l2mtu=9212 loop-protect=off\n`;
                }

                config += '\n';

                window.updateProgressStep('Configuring VLANs and bonding...');
                window.updateProgressPercent(40);
                await new Promise(resolve => setTimeout(resolve, 200));

                // VLAN 3000
                config += `/interface vlan add interface=lan-bridge name=vlan3000 vlan-id=3000\n\n`;

                // Bonding
                config += `/interface bonding add lacp-user-key=1 mode=802.3ad name=bonding1 slaves=${uplink1},${uplink2} transmit-hash-policy=layer-2-and-3\n\n`;

                // Port configuration
                config += `/port set 0 name=serial0\n\n`;

                window.updateProgressStep('Configuring SNMP and logging...');
                window.updateProgressPercent(50);
                await new Promise(resolve => setTimeout(resolve, 200));

                // SNMP community
                config += `/snmp community set [ find default=yes ] read-access=no\n`;
                config += `/snmp community add name=FBZ1yYdphf addresses=::/0\n\n`;

                // System logging
                config += `/system logging action set 0 memory-lines=100\n`;
                config += `/system logging action set 1 disk-lines-per-file=10000\n`;
                config += `/system logging action add name=syslog remote=142.147.116.215 src-address=${ipAddress} target=remote\n\n`;

                window.updateProgressStep('Configuring user groups...');
                window.updateProgressPercent(60);
                await new Promise(resolve => setTimeout(resolve, 200));

                // User groups (from example)
                config += `/user group set read policy=local,telnet,read,test,winbox,sniff,!ssh,!ftp,!reboot,!write,!policy,!password,!web,!sensitive,!api,!romon,!rest-api\n`;
                config += `/user group add name=ENG policy=local,telnet,ssh,ftp,reboot,read,write,policy,test,winbox,password,web,sniff,sensitive,api,romon,rest-api\n`;
                config += `/user group add name=NOC policy=local,telnet,ssh,ftp,reboot,read,write,test,winbox,password,sniff,sensitive,!policy,!web,!api,!romon,!rest-api\n`;
                config += `/user group add name=LTE policy=local,telnet,ssh,reboot,read,write,test,winbox,password,sniff,sensitive,!ftp,!policy,!web,!api,!romon,!rest-api\n`;
                config += `/user group add name=DEVOPS policy=local,telnet,ssh,ftp,reboot,read,write,policy,test,winbox,password,web,sniff,sensitive,api,romon,rest-api\n`;
                config += `/user group add name=VOIP policy=local,telnet,ssh,read,test,winbox,sniff,!ftp,!reboot,!write,!policy,!password,!web,!sensitive,!api,!romon,!rest-api\n`;
                config += `/user group add name=STS policy=local,telnet,ssh,read,test,winbox,sniff,!ftp,!reboot,!write,!policy,!password,!web,!sensitive,!api,!romon,!rest-api\n`;
                config += `/user group add name=TECHSUPPORT policy=local,telnet,read,test,winbox,sniff,!ssh,!ftp,!reboot,!write,!policy,!password,!web,!sensitive,!api,!romon,!rest-api\n`;
                config += `/user group add name=INFRA policy=local,telnet,reboot,read,write,test,winbox,!ssh,!ftp,!policy,!password,!web,!sniff,!sensitive,!api,!romon,!rest-api\n`;
                config += `/user group add name=INSTALL policy=local,telnet,reboot,read,write,test,winbox,!ssh,!ftp,!policy,!password,!web,!sniff,!sensitive,!api,!romon,!rest-api\n`;
                config += `/user group add name=COMENG policy=local,telnet,ssh,reboot,read,write,test,winbox,sniff,!ftp,!policy,!password,!web,!sensitive,!api,!romon,!rest-api\n`;
                config += `/user group add name=INTEGRATIONS policy=local,telnet,ssh,ftp,reboot,read,write,policy,test,winbox,password,web,sniff,sensitive,api,romon,rest-api\n`;
                config += `/user group add name=IDO policy=local,telnet,ssh,reboot,read,write,test,winbox,password,sniff,sensitive,!ftp,!policy,!web,!api,!romon,!rest-api\n`;
                config += `/user group add name=CALLCENTER-WRITE policy=local,telnet,ssh,read,write,test,winbox,sniff,!ftp,!reboot,!policy,!password,!web,!sensitive,!api,!romon,!rest-api\n\n`;

                window.updateProgressStep('Configuring bridge MSTI and ports...');
                window.updateProgressPercent(70);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Bridge MSTI
                config += `/interface bridge msti add bridge=lan-bridge identifier=1 vlan-mapping=1000,2000,3000,4000,75,444\n\n`;

                // Bridge ports - collect all ports for PVID assignment
                const allPortsForBridge = [...ports.map(p => p.port), uplink1, uplink2].filter(Boolean);

                // Default PVID assignments based on port patterns
                allPortsForBridge.forEach(port => {
                    let pvid = 1000; // Default
                    if (port === 'ether1') pvid = 3000;
                    else if (port === 'sfp-sfpplus14') pvid = 2000;
                    else if (port === 'sfp-sfpplus15' || port === 'sfp-sfpplus16' || port === 'sfp-sfpplus17' || port === 'sfp-sfpplus18' || port === 'sfp-sfpplus19') pvid = 3000;
                    else if (port === uplink1 || port === uplink2) {
                        // Bonding ports don't have PVID
                        return;
                    }

                    if (port !== uplink1 && port !== uplink2) {
                        config += `/interface bridge port add bridge=lan-bridge interface=${port} pvid=${pvid}\n`;
                    }
                });

                // Add bonding interface to bridge
                config += `/interface bridge port add bridge=lan-bridge interface=bonding1\n\n`;

                window.updateProgressStep('Configuring bridge VLANs...');
                window.updateProgressPercent(80);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Bridge VLANs - collect tagged ports
                const taggedPorts1000 = allPortsForBridge.filter(p => p !== 'sfp-sfpplus14' && p !== 'ether1' && p !== uplink1 && p !== uplink2 && !['sfp-sfpplus15', 'sfp-sfpplus16', 'sfp-sfpplus17', 'sfp-sfpplus18', 'sfp-sfpplus19'].includes(p));
                const taggedPorts2000 = allPortsForBridge.filter(p => p === 'sfp-sfpplus14' || p === 'sfp-sfpplus1' || p === 'sfp-sfpplus2');
                const taggedPorts3000 = allPortsForBridge.filter(p => ['ether1', 'sfp-sfpplus15', 'sfp-sfpplus16', 'sfp-sfpplus17', 'sfp-sfpplus18', 'sfp-sfpplus19'].includes(p));

                // VLAN 4000
                config += `/interface bridge vlan add bridge=lan-bridge tagged=${taggedPorts1000.join(',')},bonding1,lan-bridge vlan-ids=4000\n`;
                // VLAN 75
                config += `/interface bridge vlan add bridge=lan-bridge tagged=sfp-sfpplus3,bonding1,lan-bridge vlan-ids=75\n`;
                // VLAN 444
                config += `/interface bridge vlan add bridge=lan-bridge tagged=sfp-sfpplus3,bonding1,lan-bridge vlan-ids=444\n`;
                // VLAN 1000
                config += `/interface bridge vlan add bridge=lan-bridge tagged=${taggedPorts1000.join(',')},bonding1,lan-bridge vlan-ids=1000\n`;
                // VLAN 2000
                config += `/interface bridge vlan add bridge=lan-bridge tagged=${taggedPorts1000.join(',')},bonding1,lan-bridge vlan-ids=2000\n`;
                // VLAN 3000
                config += `/interface bridge vlan add bridge=lan-bridge tagged=lan-bridge,bonding1,${taggedPorts3000.join(',')} vlan-ids=3000\n\n`;

                window.updateProgressStep('Configuring IP address and DNS...');
                window.updateProgressPercent(85);
                await new Promise(resolve => setTimeout(resolve, 200));

                // IP address
                config += `/ip address add address=${mgmtIP} interface=vlan3000\n\n`;

                // DNS
                config += `/ip dns set max-udp-packet-size=512 servers=142.147.112.3,142.147.112.19\n\n`;

                window.updateProgressStep('Configuring firewall rules...');
                window.updateProgressPercent(90);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Firewall address-lists (from example)
                const managerIPs = ['10.10.103.91', '192.168.128.0/21', '107.178.5.97', '198.100.53.0/25', '143.55.62.143', '142.147.127.2', '132.147.132.6', '67.219.122.201', '10.0.0.0/8', '208.93.124.0/22', '192.104.128.0/21', '199.180.120.0/21'];
                managerIPs.forEach(ip => {
                    config += `/ip firewall address-list add list=managerIP address=${ip}\n`;
                });

                const snmpIPs = ['143.55.35.47', '107.178.15.15', '107.178.15.162', '142.147.112.4', '142.147.124.26', '107.178.5.97', '67.219.126.240/28', '198.100.53.120', '143.55.62.143', '132.147.138.2', '132.147.138.0', '132.147.138.6', '132.147.138.23', '132.147.138.29', '132.147.138.30', '132.147.138.31', '143.55.37.40', '143.55.37.41', '132.147.132.24', '198.100.49.99', '132.147.132.26', '204.11.183.126', '173.215.67.124', '132.147.138.3', '132.147.138.7', '132.147.138.21', '132.147.138.26', '10.30.9.246'];
                snmpIPs.forEach(ip => {
                    config += `/ip firewall address-list add list=SNMP address=${ip}\n`;
                });

                const ntpIPs = ['52.128.59.240', '52.128.59.241', '52.128.59.242', '52.128.59.243', '132.163.4.101', '132.163.4.102'];
                ntpIPs.forEach(ip => {
                    config += `/ip firewall address-list add list=NTP address=${ip}\n`;
                });

                config += '\n';

                // Firewall filters
                config += `/ip firewall filter add action=accept chain=input comment="ALLOW EST REL" connection-state=established,related,untracked\n`;
                config += `/ip firewall filter add action=accept chain=input comment="ALLOW MT NEIGHBOR" dst-port=5678 protocol=udp\n`;
                config += `/ip firewall filter add action=accept chain=input comment="ALLOW MAC TELNET" dst-port=20561 protocol=udp\n`;
                config += `/ip firewall filter add action=accept chain=input comment="ALLOW IGMP" protocol=igmp\n`;
                config += `/ip firewall filter add action=accept chain=input comment="ALLOW ICMP" protocol=icmp\n`;
                config += `/ip firewall filter add action=accept chain=input comment="ALLOW MANAGER IP" src-address-list=managerIP\n`;
                config += `/ip firewall filter add action=accept chain=input comment="ALLOW SNMP" dst-port=161 protocol=udp src-address-list=SNMP\n`;
                config += `/ip firewall filter add action=drop chain=input comment="DROP INPUT"\n\n`;

                config += `/ip firewall service-port set sip disabled=yes\n\n`;

                // Route
                config += `/ip route add disabled=no distance=1 dst-address=0.0.0.0/0 gateway=${gateway} pref-src="" routing-table=main scope=30 suppress-hw-offload=no target-scope=10\n\n`;

                window.updateProgressStep('Configuring services and RADIUS...');
                window.updateProgressPercent(95);
                await new Promise(resolve => setTimeout(resolve, 200));

                // IP services
                config += `/ip service set telnet disabled=yes port=5023\n`;
                config += `/ip service set ftp disabled=yes port=5021\n`;
                config += `/ip service set www disabled=yes port=1234\n`;
                config += `/ip service set ssh port=5022\n`;
                config += `/ip service set www-ssl disabled=no\n`;
                config += `/ip service set api disabled=yes\n`;
                config += `/ip service set api-ssl disabled=yes\n\n`;

                // RADIUS
                config += `/radius add address=10.30.10.70 comment="userRAD 1" service=login src-address=${ipAddress}\n`;
                config += `/radius add address=10.2.10.74 comment="userRAD 2" service=login src-address=${ipAddress}\n\n`;

                // SNMP
                config += `/snmp set enabled=yes contact="Bradley Shaw" location="${gps}" src-address=${ipAddress} trap-community=FBZ1yYdphf\n\n`;

                // System settings
                config += `/system clock set time-zone-name=America/Chicago time-zone-autodetect=no\n`;
                config += `/system identity set name=${switchName}\n\n`;

                // System logging
                config += `/system logging add action=disk topics=critical\n`;
                config += `/system logging add action=disk topics=error\n`;
                config += `/system logging add action=disk topics=info\n`;
                config += `/system logging add action=disk topics=warning\n`;
                config += `/system logging add action=syslog topics=critical\n`;
                config += `/system logging add action=syslog topics=error\n`;
                config += `/system logging add action=syslog topics=info\n`;
                config += `/system logging add action=syslog topics=warning\n`;
                config += `/system logging add disabled=yes topics=debug\n`;
                config += `/system logging add action=disk topics=critical\n`;
                config += `/system logging add action=disk topics=error\n`;
                config += `/system logging add action=disk topics=info\n`;
                config += `/system logging add topics=warning\n\n`;

                config += `/system note set show-at-login=no\n`;
                config += `/system ntp client set enabled=yes\n`;
                config += `/system ntp client servers add address=52.128.59.240\n`;
                config += `/system ntp client servers add address=52.128.59.241\n`;
                config += `/system ntp client servers add address=52.128.59.242\n`;
                config += `/system ntp client servers add address=52.128.59.243\n`;
                config += `/system ntp client servers add address=132.163.4.101\n`;
                config += `/system ntp client servers add address=132.163.4.102\n\n`;

                config += `/system routerboard settings set boot-os=router-os enter-setup-on=delete-key\n`;
                config += `/system swos set address-acquisition-mode=static allow-from-ports=p1,p2,p3,p4,p5,p6,p7,p8,p9,p10,p11,p12,p13,p14,p15,p16,p17,p18,p19,p20,p21,p22,p23,p24,p25,p26,p27,p28,p29,p30,p31,p32 identity=SWT-CRS326-1.WAR static-ip-address=10.3.24.4\n\n`;

                config += `/tool sniffer set file-limit=10000KiB\n\n`;

                // Users (from example)
                config += `/user set [find name=admin] password="CHANGE_ME"\n`;
                config += `/user aaa set use-radius=yes\n`;
                config += `/user add name="root" password="CHANGE_ME" group=full\n`;
                config += `/user add name="deployment" password="CHANGE_ME" group=full\n`;
                config += `/user add name="infra" password="CHANGE_ME" group=full\n`;
                config += `/user add name="ido" password="CHANGE_ME" group=full\n`;
                config += `/user add name="sts" password="CHANGE_ME" group=full\n`;
                config += `/user add name="eng" password="CHANGE_ME" group=full\n`;
                config += `/user add name="noc" password="CHANGE_ME" group=full\n`;
                config += `/user add name="devops" password="CHANGE_ME" group=full\n`;
                config += `/user add name="comeng" password="CHANGE_ME" group=full\n`;
                config += `/user add name="acq" password="CHANGE_ME" group=full\n`;
                config += `/user set [find name=admin] group=read\n`;

                window.updateProgressStep('Configuration generation complete!');
                window.updateProgressPercent(100);
                await new Promise(resolve => setTimeout(resolve, 300));

                // Display configuration
                const output = document.getElementById('switch_maker_output');
                if (output) {
                    output.value = config;
                }

                // Show success message
                const warnId = state === 'instate' ? 'switch_instate_warn' : 'switch_outstate_warn';
                const warnBox = document.getElementById(warnId);
                if (warnBox) {
                    warnBox.innerHTML = '<div style="background: #4CAF50; color: white; padding: 10px; border-radius: 5px;"> Configuration generated successfully!</div>';
                }

                window.completeProgressTracker(true);

                // --- FIX START: SAVE CONFIGURATION TO DATABASE ---
                const uInfo = JSON.parse(localStorage.getItem('user_info') || '{}');
                const uName = uInfo.email || 'unknown';

                // Save to Completed Configs Database (CONFIGS Tab)
                await saveCompletedConfig({
                    config_type: 'switch-config',
                    device_name: switchName,
                    device_type: `CRS${switchType}`,
                    customer_code: '',
                    loopback_ip: mgmtIP.split('/')[0],
                    routeros_version: routerOS,
                    config_content: config,
                    site_name: switchName,
                    created_by: uName,
                    metadata: {
                        state: state,
                        type: 'switch',
                        gateway: gateway
                    }
                });
                console.log('[SWITCH CONFIG] Saved to Completed Configs database');
                // --- FIX END ---

                // Save to activity log
                const userInfo = JSON.parse(localStorage.getItem('user_info') || '{}');
                const username = userInfo.email || 'unknown';

                await window.sendActivityToBackend({
                    type: 'new-config',
                    description: `Generated ${state === 'instate' ? 'IN-STATE' : 'OUT-OF-STATE'} MikroTik switch configuration: ${switchName}`,
                    device: `CRS${switchType}`,
                    routeros: routerOS,
                    site: switchName,
                    username: username
                });

                // Save config to history
                await window.saveConfigToHistory({
                    site: switchName,
                    device: `CRS${switchType}`,
                    routeros: routerOS,
                    config: config,
                    type: 'switch-config',
                    success: true
                });

            } catch (error) {
                console.error('Error generating switch config:', error);
                window.addProgressLog('error', `Error: ${error.message}`);
                window.completeProgressTracker(false);
                alert('Error generating configuration: ' + error.message);
            }
        }

        // 6GHz Switch Config Generator - Auto-generates full configuration (make globally accessible)
        window.generate6GhzConfig = async function () {
            try {
                // Show progress tracker
                window.showProgressTracker('6GHz Switch Configuration Generation');
                window.updateProgressStep('Initializing 6GHz switch configuration...');
                window.updateProgressPercent(5);
                window.addProgressLog('info', 'Starting 6GHz switch configuration generation');

                await new Promise(resolve => setTimeout(resolve, 300));

                const switchType = document.getElementById('ghz_switch_type').value;
                const routerOSVersion = document.getElementById('ghz_routeros_version').value;
                const vlan3000Subnet = document.getElementById('ghz_subnet3000').value.trim();
                const vlan4000Subnet = document.getElementById('ghz_subnet4000').value.trim();
                const poolOffset = parseInt(document.getElementById('ghz_poolOffset').value || '0', 10);

                window.updateProgressStep('Validating inputs...');
                window.updateProgressPercent(10);
                window.addProgressLog('info', 'Validating switch type, RouterOS version, and VLAN subnets');

                // Get DNS from user input or NextLink infrastructure (no fallbacks)
                let dnsServers = document.getElementById('ghz_dns').value.trim();
                if (!dnsServers) {
                    dnsServers = getDNSList();
                    if (!dnsServers) {
                        window.addProgressLog('error', 'DNS servers must be configured');
                        window.completeProgressTracker(false);
                        alert('DNS servers must be configured. Either enter DNS servers in the field above or configure them in nextlink_constants.js.');
                        return;
                    }
                }

                // Validation
                if (!switchType) {
                    window.addProgressLog('error', 'Switch type not selected');
                    window.completeProgressTracker(false);
                    alert('Please select a switch type.');
                    return;
                }
                if (!routerOSVersion) {
                    window.addProgressLog('error', 'RouterOS version not selected');
                    window.completeProgressTracker(false);
                    alert('Please select a RouterOS version.');
                    return;
                }
                if (!vlan3000Subnet || !vlan4000Subnet) {
                    window.addProgressLog('error', 'VLAN subnets missing');
                    window.completeProgressTracker(false);
                    alert('Please provide both VLAN 3000 and VLAN 4000 subnets.');
                    return;
                }

                window.addProgressLog('success', `Switch type: ${switchType}, RouterOS: ${routerOSVersion}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Determining port configuration...');
                window.updateProgressPercent(15);
                window.addProgressLog('info', 'Identifying switch ports based on switch type');

                // Determine port names based on switch type
                let port1, port2, switchComment;
                if (switchType === 'swt_mt326') {
                    port1 = 'sfp-sfpplus8';
                    port2 = 'sfp-sfpplus9';
                    switchComment = 'SWT-CRS326';
                } else if (switchType === 'swt_ccr2004') {
                    port1 = 'sfp-sfpplus8';
                    port2 = 'sfp-sfpplus9';
                    switchComment = 'SWT-CCR2004';
                } else if (switchType === 'swt_mt309') {
                    port1 = 'sfp-sfpplus8';
                    port2 = 'sfp-sfpplus9';
                    switchComment = 'SWT-MT309';
                } else {
                    window.addProgressLog('error', 'Invalid switch type selected');
                    window.completeProgressTracker(false);
                    alert('Invalid switch type selected.');
                    return;
                }

                window.addProgressLog('success', `Ports: ${port1}, ${port2} (${switchComment})`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Parsing VLAN subnets...');
                window.updateProgressPercent(20);
                window.addProgressLog('info', 'Parsing VLAN 3000 and VLAN 4000 subnets');

                // Parse VLAN subnets
                const parseSubnet = (subnetStr) => {
                    const parts = subnetStr.split('/');
                    if (parts.length !== 2) throw new Error('Invalid CIDR format');
                    const ip = parts[0].trim();
                    const prefix = parseInt(parts[1].trim(), 10);
                    if (isNaN(prefix) || prefix < 0 || prefix > 32) throw new Error('Invalid prefix');
                    return { ip, prefix, cidr: subnetStr };
                };

                const vlan3000 = parseSubnet(vlan3000Subnet);
                const vlan4000 = parseSubnet(vlan4000Subnet);

                window.addProgressLog('success', `VLAN 3000: ${vlan3000.cidr}, VLAN 4000: ${vlan4000.cidr}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Calculate network addresses and gateways
                const calculateNetwork = (ipStr, prefix) => {
                    const ipParts = ipStr.split('.').map(Number);
                    const ipInt = (ipParts[0] << 24) + (ipParts[1] << 16) + (ipParts[2] << 8) + ipParts[3];
                    const mask = (0xFFFFFFFF << (32 - prefix)) >>> 0;
                    const networkInt = (ipInt & mask) >>> 0;
                    return [
                        (networkInt >>> 24) & 255,
                        (networkInt >>> 16) & 255,
                        (networkInt >>> 8) & 255,
                        networkInt & 255
                    ].join('.');
                };

                const calculateGateway = (ipStr, prefix) => {
                    const network = calculateNetwork(ipStr, prefix);
                    const networkParts = network.split('.').map(Number);
                    networkParts[3] += 1; // First usable IP = gateway
                    return networkParts.join('.');
                };

                // Calculate network address from the user's input IP
                const vlan3000Network = calculateNetwork(vlan3000.ip, vlan3000.prefix);
                const vlan4000Network = calculateNetwork(vlan4000.ip, vlan4000.prefix);

                // Use the EXACT IP the user entered as the router/gateway IP
                // User input is the router IP, not just any IP in the subnet
                const vlan3000RouterIP = vlan3000.ip; // Use exact input as router IP
                const vlan4000GatewayIP = vlan4000.ip; // Use exact input as gateway IP

                // Calculate DHCP pool range (VLAN4000 only)
                // Pool starts at (user's gateway IP + offset), ends at broadcast - 1
                const calculatePoolRange = (gatewayIP, networkStr, prefix, offset) => {
                    // Convert gateway IP to integer
                    const gatewayParts = gatewayIP.split('.').map(Number);
                    const gatewayInt = (gatewayParts[0] << 24) + (gatewayParts[1] << 16) + (gatewayParts[2] << 8) + gatewayParts[3];

                    // Convert network to integer for broadcast calculation
                    const networkParts = networkStr.split('.').map(Number);
                    const networkInt = (networkParts[0] << 24) + (networkParts[1] << 16) + (networkParts[2] << 8) + networkParts[3];

                    const hostBits = 32 - prefix;
                    const totalIPs = Math.pow(2, hostBits);
                    const broadcastInt = networkInt + totalIPs - 1; // Broadcast address
                    const lastUsableInt = broadcastInt - 1; // Last usable IP

                    // Convert back to IP address
                    const intToIP = (ipInt) => {
                        return [
                            (ipInt >>> 24) & 255,
                            (ipInt >>> 16) & 255,
                            (ipInt >>> 8) & 255,
                            ipInt & 255
                        ].join('.');
                    };

                    // Calculate start IP (user's gateway IP + offset)
                    const startInt = gatewayInt + offset;
                    const startIP = intToIP(startInt);

                    // End IP is last usable IP
                    const endIP = intToIP(lastUsableInt);

                    return {
                        start: startIP,
                        end: endIP
                    };
                };

                window.updateProgressStep('Calculating network addresses and DHCP pools...');
                window.updateProgressPercent(30);
                window.addProgressLog('info', 'Calculating network addresses, gateways, and DHCP pool ranges');

                const poolRange = calculatePoolRange(vlan4000GatewayIP, vlan4000Network, vlan4000.prefix, poolOffset);

                window.addProgressLog('success', `DHCP pool: ${poolRange.start}-${poolRange.end}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Determining RouterOS syntax...');
                window.updateProgressPercent(35);
                window.addProgressLog('info', 'Checking RouterOS version for syntax compatibility');

                // Determine speed syntax based on RouterOS version
                const versionType = getRouterOSVersionType(routerOSVersion);
                const speedSyntax = versionType === 'new' ? '10G-baseSR-LR' : '10Gbps';

                // Get shared key from infrastructure or use placeholder
                const sharedKey = getInfrastructureValue('sharedKeys.ospfBgpMd5', 'CHANGE_ME');

                window.updateProgressStep('Generating 6GHz switch configuration...');
                window.updateProgressPercent(40);
                window.addProgressLog('info', 'Building configuration blocks');

                // Generate configuration
                let config = `###################################\n###    6GHz SWITCH CONFIG       ###\n###################################\n\n`;

                window.updateProgressStep('Configuring bridges...');
                window.updateProgressPercent(45);
                window.addProgressLog('info', 'Creating bridge interfaces (bridge2000, bridge3000, bridge4000)');

                // Interface Bridge
                config += `/interface bridge\n`;
                config += `add name=bridge2000 port-cost-mode=short\n`;
                config += `add name=bridge3000 port-cost-mode=short\n`;
                config += `add name=bridge4000 port-cost-mode=short\n\n`;

                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Configuring Ethernet ports and bonding...');
                window.updateProgressPercent(50);
                window.addProgressLog('info', `Setting up ${port1} and ${port2} for bonding`);

                // Interface Ethernet
                config += `/interface ethernet\n`;
                config += `set [ find default-name=${port1} ] comment="${switchComment} Uplink #1 - BONDED" speed=${speedSyntax}\n`;
                config += `set [ find default-name=${port2} ] comment="${switchComment} Uplink #2 - BONDED" speed=${speedSyntax}\n\n`;

                // Interface Bonding
                config += `/interface bonding\n`;
                config += `add lacp-user-key=1 mode=802.3ad name=bonding1 slaves=${port1},${port2} transmit-hash-policy=layer-2-and-3\n\n`;

                window.addProgressLog('success', 'Bonding interface created (802.3ad LACP)');
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Configuring VLANs...');
                window.updateProgressPercent(55);
                window.addProgressLog('info', 'Creating VLAN interfaces (1000, 2000, 3000, 4000)');

                // Interface VLAN
                config += `/interface vlan\n`;
                config += `add interface=bonding1 name=vlan1000-bonding1 vlan-id=1000\n`;
                config += `add interface=bonding1 name=vlan2000-bonding1 vlan-id=2000\n`;
                config += `add interface=bonding1 name=vlan3000-bonding1 vlan-id=3000\n`;
                config += `add interface=bonding1 name=vlan4000-bonding1 vlan-id=4000\n\n`;

                window.updateProgressStep('Assigning VLANs to bridges...');
                window.updateProgressPercent(60);
                window.addProgressLog('info', 'Mapping VLANs to bridge ports');

                // Interface Bridge Port
                config += `/interface bridge port\n`;
                config += `add bridge=bridge4000 ingress-filtering=no interface=vlan4000-bonding1 internal-path-cost=10 path-cost=10\n`;
                config += `add bridge=bridge3000 ingress-filtering=no interface=vlan3000-bonding1 internal-path-cost=10 path-cost=10\n`;
                config += `add bridge=lan-bridge ingress-filtering=no interface=vlan1000-bonding1 internal-path-cost=10 path-cost=10\n`;
                config += `add bridge=bridge2000 ingress-filtering=no interface=vlan2000-bonding1 internal-path-cost=10 path-cost=10\n\n`;

                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Configuring IP addresses...');
                window.updateProgressPercent(65);
                window.addProgressLog('info', 'Assigning IP addresses to bridges');

                // IP Address
                config += `/ip address\n`;
                // VLAN3000: Use the EXACT IP the user entered as router IP
                // Example: user enters 10.245.65.25/28  router IP = 10.245.65.25, network = 10.245.65.16
                config += `add address=${vlan3000RouterIP}/${vlan3000.prefix} comment=6GHZ interface=bridge3000 network=${vlan3000Network}\n`;
                // VLAN4000: Use the EXACT IP the user entered as gateway IP
                // Example: user enters 10.56.23.25/22  gateway = 10.56.23.25, network = 10.56.20.0
                config += `add address=${vlan4000GatewayIP}/${vlan4000.prefix} comment="6GHZ CPE" interface=bridge4000 network=${vlan4000Network}\n\n`;

                window.addProgressLog('success', `VLAN 3000: ${vlan3000RouterIP}/${vlan3000.prefix}, VLAN 4000: ${vlan4000GatewayIP}/${vlan4000.prefix}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Configuring DHCP server...');
                window.updateProgressPercent(70);
                window.addProgressLog('info', 'Setting up DHCP pool and server for VLAN 4000');

                // IP Pool
                config += `/ip pool\n`;
                config += `add name=vlan4000 ranges=${poolRange.start}-${poolRange.end}\n\n`;

                // DHCP Server
                config += `/ip dhcp-server\n`;
                config += `add address-pool=vlan4000 interface=bridge4000 lease-time=1h name=vlan4000\n\n`;

                // DHCP Server Network
                config += `/ip dhcp-server network\n`;
                config += `add address=${vlan4000Network}/${vlan4000.prefix} dns-server=${dnsServers} gateway=${vlan4000GatewayIP} netmask=${vlan4000.prefix}\n\n`;

                window.addProgressLog('success', `DHCP pool configured: ${poolRange.start}-${poolRange.end}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Configuring firewall and OSPF...');
                window.updateProgressPercent(80);
                window.addProgressLog('info', 'Adding firewall address-list and OSPF interface template');

                // Firewall Address List
                config += `/ip firewall address-list\n`;
                config += `add address=${vlan3000Network}/${vlan3000.prefix} comment=6ghz list=bgp-networks\n\n`;

                // OSPF Interface Template
                config += `/routing ospf interface-template\n`;
                config += `add area=backbone-v2 auth=md5 auth-id=1 auth-key=${sharedKey} comment="6GHZ CPE" disabled=no interfaces=bridge4000 networks=${vlan4000Network}/${vlan4000.prefix} passive priority=1\n\n`;

                window.addProgressLog('success', 'OSPF interface template configured');
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Finalizing configuration...');
                window.updateProgressPercent(90);
                window.addProgressLog('info', 'Configuration generation complete');

                // Display configuration
                const output = document.getElementById('ccr_output');
                if (output) {
                    output.value = config;
                }

                window.updateProgressPercent(100);
                window.updateProgressStep('Configuration generated successfully!');
                window.addProgressLog('success', `6GHz switch configuration generated (${config.length} characters)`);

                const warnBox = document.getElementById('ghz_warnBox');
                if (warnBox) {
                    warnBox.innerHTML = `<div style="color: #4CAF50; font-weight: bold;"> 6GHz Switch Configuration generated successfully!</div>`;
                }

                window.completeProgressTracker(true);

                // --- FIX START: SAVE CONFIGURATION TO DATABASE ---
                const ghzUserInfo = JSON.parse(localStorage.getItem('user_info') || '{}');
                const ghzUsername = ghzUserInfo.email || 'unknown';

                // Save to Completed Configs Database (CONFIGS Tab)
                await saveCompletedConfig({
                    config_type: '6ghz-switch-config',
                    device_name: `6GHz-Switch-${switchType}`,
                    device_type: switchType === 'swt_mt326' ? 'CRS326' : switchType === 'swt_ccr2004' ? 'CCR2004' : 'CRS309',
                    customer_code: '',
                    loopback_ip: vlan3000Subnet.split('/')[0],
                    routeros_version: routerOSVersion,
                    config_content: config,
                    site_name: '6GHz Switch Site',
                    created_by: ghzUsername,
                    metadata: {
                        type: '6ghz',
                        vlan3000: vlan3000Subnet
                    }
                });
                console.log('[6GHz CONFIG] Saved to Completed Configs database');
                // --- FIX END ---

                // Track activity for analytics (reuse variables from above - switchType, routerOSVersion, vlan3000Subnet, and vlan4000Subnet already declared)

                saveConfigToHistory({
                    type: '6ghz-switch-config',
                    device: switchType === 'swt_mt326' ? 'CRS326' : switchType === 'swt_ccr2004' ? 'CCR2004' : 'CRS309',
                    siteName: `6GHz Switch (VLAN3000: ${vlan3000Subnet}, VLAN4000: ${vlan4000Subnet})`,
                    routeros: routerOSVersion,
                    success: true
                });

            } catch (error) {
                window.addProgressLog('error', 'Configuration generation failed: ' + error.message);
                window.completeProgressTracker(false);

                // Track failure
                const switchType = document.getElementById('ghz_switch_type')?.value || 'Unknown';
                const routerOSVersion = document.getElementById('ghz_routeros_version')?.value || 'Unknown';
                saveConfigToHistory({
                    type: '6ghz-switch-config',
                    device: switchType,
                    siteName: '6GHz Switch Config',
                    routeros: routerOSVersion,
                    success: false
                });

                alert('Error generating 6GHz configuration: ' + error.message);
                console.error('6GHz Generation Error:', error);
                const warnBox = document.getElementById('ghz_warnBox');
                if (warnBox) {
                    warnBox.innerHTML = `<div style="color: #dc3545; font-weight: bold;"> Error: ${error.message}</div>`;
                }
            }
        }

        // Copy function for 6GHz config
        function copy6Ghz() {
            try {
                const config = document.getElementById('ccr_output').value;
                if (!config) {
                    alert('No configuration to copy!');
                    return;
                }
                navigator.clipboard.writeText(config).then(() => {
                    alert(' Configuration copied to clipboard!');
                }).catch(err => {
                    alert('Failed to copy: ' + err);
                });
            } catch (error) {
                alert('Error copying configuration: ' + error.message);
            }
        }

        // 6GHz Switch Config OUT-OF-STATE - Port Population Handler
        function handleGhzOutstateSwitchChange() {
            const switchSelect = document.getElementById('ghz_outstate_switch_type');
            const port1Select = document.getElementById('ghz_outstate_port1');
            const port2Select = document.getElementById('ghz_outstate_port2');
            const portSingleSelect = document.getElementById('ghz_outstate_port_single');
            const bondingPortsDiv = document.getElementById('ghz_outstate_bonding_ports');
            const singlePortDiv = document.getElementById('ghz_outstate_single_port');

            if (!switchSelect) return;

            const switchType = switchSelect.value;

            // Determine available ports based on switch type
            let availablePorts = [];
            if (switchType === 'swt_mt326') {
                // SWT MT326 uses bonding - show bonding UI
                if (bondingPortsDiv) bondingPortsDiv.style.display = 'grid';
                if (singlePortDiv) singlePortDiv.style.display = 'none';

                availablePorts = ['sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4',
                    'sfp-sfpplus5', 'sfp-sfpplus6', 'sfp-sfpplus7', 'sfp-sfpplus8',
                    'sfp-sfpplus9', 'sfp-sfpplus10', 'sfp-sfpplus11', 'sfp-sfpplus12'];

                // Clear and populate bonding port dropdowns
                if (port1Select && port2Select) {
                    port1Select.innerHTML = '<option value="">Select Port</option>';
                    port2Select.innerHTML = '<option value="">Select Port</option>';

                    availablePorts.forEach(port => {
                        const option1 = document.createElement('option');
                        option1.value = port;
                        option1.textContent = port;
                        port1Select.appendChild(option1);

                        const option2 = document.createElement('option');
                        option2.value = port;
                        option2.textContent = port;
                        port2Select.appendChild(option2);
                    });
                }
            } else if (switchType === 'swt_mt309' || switchType === 'swt_ccr2004') {
                // SWT MT309 and CCR2004 use single port - show single port UI
                if (bondingPortsDiv) bondingPortsDiv.style.display = 'none';
                if (singlePortDiv) singlePortDiv.style.display = 'block';

                availablePorts = ['sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4',
                    'sfp-sfpplus5', 'sfp-sfpplus6', 'sfp-sfpplus7', 'sfp-sfpplus8',
                    'sfp-sfpplus9', 'sfp-sfpplus10', 'sfp-sfpplus11', 'sfp-sfpplus12'];

                // Clear and populate single port dropdown
                if (portSingleSelect) {
                    portSingleSelect.innerHTML = '<option value="">Select Port</option>';

                    availablePorts.forEach(port => {
                        const option = document.createElement('option');
                        option.value = port;
                        option.textContent = port;
                        portSingleSelect.appendChild(option);
                    });
                }
            } else {
                // No switch selected - hide both
                if (bondingPortsDiv) bondingPortsDiv.style.display = 'none';
                if (singlePortDiv) singlePortDiv.style.display = 'none';
            }
        }

        // 6GHz Switch Config OUT-OF-STATE Generator - Simple bridge/VLAN setup
        function generate6GhzOutstateConfig() {
            try {
                const switchType = document.getElementById('ghz_outstate_switch_type').value;
                const routerOSVersion = document.getElementById('ghz_outstate_routeros_version').value;

                // Validation
                if (!switchType) {
                    alert('Please select a switch type.');
                    return;
                }
                if (!routerOSVersion) {
                    alert('Please select a RouterOS version.');
                    return;
                }

                // Determine switch comment based on type
                let switchComment;
                if (switchType === 'swt_mt326') {
                    switchComment = 'SWT-CRS326';
                } else if (switchType === 'swt_ccr2004') {
                    switchComment = 'SWT-MT2004';
                } else if (switchType === 'swt_mt309') {
                    switchComment = 'SWT-CRS309';
                } else {
                    alert('Invalid switch type selected.');
                    return;
                }

                let config = `###################################\n###  6GHz SWITCH CONFIG (OUT-OF-STATE)  ###\n###################################\n\n`;

                // Check if single port (MT309/CCR2004) or bonding (MT326)
                if (switchType === 'swt_mt309' || switchType === 'swt_ccr2004') {
                    // MT309 and CCR2004 Configuration - Single Port, No Bonding
                    const port = document.getElementById('ghz_outstate_port_single').value;

                    if (!port) {
                        alert('Please select a port.');
                        return;
                    }

                    // Determine speed syntax based on RouterOS version
                    const versionType = getRouterOSVersionType(routerOSVersion);
                    const speedSyntax = versionType === 'new' ? '10G-baseSR-LR' : '10Gbps';

                    // Interface Bridge (MT309/CCR2004 have no bridge1500)
                    config += `/interface bridge\n`;
                    config += `add comment=DYNAMIC name=bridge1000 port-cost-mode=short protocol-mode=none\n`;
                    config += `add comment=STATIC name=bridge2000 port-cost-mode=short protocol-mode=none\n`;
                    config += `add comment=INFRA name=bridge3000 port-cost-mode=short protocol-mode=none\n`;
                    config += `add comment=CPE name=bridge4000 port-cost-mode=short protocol-mode=none\n\n`;

                    // Interface Ethernet (MT309/CCR2004 have auto-negotiation=no and speed)
                    config += `/interface ethernet\n`;
                    config += `set [ find default-name=${port} ] auto-negotiation=no comment=${switchComment} speed=${speedSyntax}\n\n`;

                    // Interface VLAN (MT309/CCR2004 use different naming: vlan1000-B, etc., with comments)
                    config += `/interface vlan\n`;
                    config += `add comment=VLAN1000-DYNAMIC interface=${port} name=vlan1000-B vlan-id=1000\n`;
                    config += `add comment=VLAN2000-STATIC interface=${port} name=vlan2000-B vlan-id=2000\n`;
                    config += `add comment=VLAN3000-INFRA interface=${port} name=vlan3000-B vlan-id=3000\n`;
                    config += `add comment=VLAN4000-CPE interface=${port} name=vlan4000-B vlan-id=4000\n\n`;

                    // Interface Bridge Port
                    config += `/interface bridge port\n`;
                    config += `add bridge=bridge1000 interface=vlan1000-B internal-path-cost=10 path-cost=10\n`;
                    config += `add bridge=bridge2000 interface=vlan2000-B internal-path-cost=10 path-cost=10\n`;
                    config += `add bridge=bridge3000 interface=vlan3000-B internal-path-cost=10 path-cost=10\n`;
                    config += `add bridge=bridge4000 interface=vlan4000-B internal-path-cost=10 path-cost=10\n`;

                    // CCR2004 includes bridge9990, MT309 does not
                    if (switchType === 'swt_ccr2004') {
                        config += `add bridge=bridge9990 disabled=yes interface=${port} internal-path-cost=10 path-cost=10\n`;
                    }
                    config += `\n`;

                } else {
                    // MT326 Configuration - Bonding
                    const port1 = document.getElementById('ghz_outstate_port1').value;
                    const port2 = document.getElementById('ghz_outstate_port2').value;

                    if (!port1 || !port2) {
                        alert('Please select both bonding ports.');
                        return;
                    }
                    if (port1 === port2) {
                        alert('Please select two different ports for bonding.');
                        return;
                    }

                    // Interface Bridge (MT326 has bridge1500)
                    config += `/interface bridge\n`;
                    config += `add comment=DYNAMIC name=bridge1000 port-cost-mode=short protocol-mode=none\n`;
                    config += `add comment=DHCP name=bridge1500 port-cost-mode=short protocol-mode=none\n`;
                    config += `add comment=STATIC name=bridge2000 port-cost-mode=short protocol-mode=none\n`;
                    config += `add comment=INFRA name=bridge3000 port-cost-mode=short protocol-mode=none\n`;
                    config += `add comment=CPE name=bridge4000 port-cost-mode=short protocol-mode=none\n\n`;

                    // Interface Ethernet (no speed setting for bonding configs)
                    config += `/interface ethernet\n`;
                    config += `set [ find default-name=${port1} ] comment="${switchComment} Uplink #1 - BONDED"\n`;
                    config += `set [ find default-name=${port2} ] comment="${switchComment} Uplink #2 - BONDED"\n\n`;

                    // Interface Bonding
                    config += `/interface bonding\n`;
                    config += `add lacp-user-key=1 mode=802.3ad name=bonding1 slaves=${port1},${port2} transmit-hash-policy=layer-2-and-3\n\n`;

                    // Interface VLAN
                    config += `/interface vlan\n`;
                    config += `add interface=bonding1 name=vlan1000-bonding1 vlan-id=1000\n`;
                    config += `add interface=bonding1 name=vlan2000-bonding1 vlan-id=2000\n`;
                    config += `add interface=bonding1 name=vlan3000-bonding1 vlan-id=3000\n`;
                    config += `add interface=bonding1 name=vlan4000-bonding1 vlan-id=4000\n\n`;

                    // Interface Bridge Port
                    config += `/interface bridge port\n`;
                    config += `add bridge=bridge4000 ingress-filtering=no interface=vlan4000-bonding1 internal-path-cost=10 path-cost=10\n`;
                    config += `add bridge=bridge3000 ingress-filtering=no interface=vlan3000-bonding1 internal-path-cost=10 path-cost=10\n`;
                    config += `add bridge=bridge1000 ingress-filtering=no interface=vlan1000-bonding1 internal-path-cost=10 path-cost=10\n`;
                    config += `add bridge=bridge2000 ingress-filtering=no interface=vlan2000-bonding1 internal-path-cost=10 path-cost=10\n\n`;
                }

                // Display configuration
                const output = document.getElementById('ccr_output');
                if (output) {
                    output.value = config;
                }

                const warnBox = document.getElementById('ghz_outstate_warnBox');
                if (warnBox) {
                    warnBox.innerHTML = `<div style="color: #4CAF50; font-weight: bold;"> 6GHz Switch Configuration (OUT-OF-STATE) generated successfully!</div>`;
                }

            } catch (error) {
                alert('Error generating 6GHz OUT-OF-STATE configuration: ' + error.message);
                console.error('6GHz OUT-OF-STATE Generation Error:', error);
                const warnBox = document.getElementById('ghz_outstate_warnBox');
                if (warnBox) {
                    warnBox.innerHTML = `<div style="color: #dc3545; font-weight: bold;"> Error: ${error.message}</div>`;
                }
            }
        }

        // Copy function for 6GHz OUT-OF-STATE config
        function copy6GhzOutstate() {
            try {
                const config = document.getElementById('ccr_output').value;
                if (!config) {
                    alert('No configuration to copy!');
                    return;
                }
                navigator.clipboard.writeText(config).then(() => {
                    alert(' Configuration copied to clipboard!');
                }).catch(err => {
                    alert('Failed to copy: ' + err);
                });
            } catch (error) {
                alert('Error copying configuration: ' + error.message);
            }
        }

        // TARANA SECTORS BNG2 - Critical function - must always work
        // This function is isolated and protected with multiple fallbacks
        function handleTaranaBNG2DeviceChange() {
            console.log('[BNG2] handleTaranaBNG2DeviceChange called');
            const deviceSelect = document.getElementById('tarana_bng2_device');
            const portSelects = [
                document.getElementById('tarana_bng2_alphaPort'),
                document.getElementById('tarana_bng2_betaPort'),
                document.getElementById('tarana_bng2_gammaPort'),
                document.getElementById('tarana_bng2_deltaPort')
            ];

            if (!deviceSelect) {
                console.error('[BNG2] Device select element not found!');
                return;
            }

            const selectedDevice = deviceSelect.value;

            // If no device selected, clear all ports
            if (!selectedDevice) {
                portSelects.forEach(ps => {
                    if (ps) {
                        ps.innerHTML = '<option value="">Select Port (Choose Device First)</option>';
                    }
                });
                return;
            }

            // Get device config
            const deviceConfig = typeof DEVICE_CONFIGS !== 'undefined' ? DEVICE_CONFIGS[selectedDevice] : null;
            if (!deviceConfig) {
                console.error('[BNG2] No device configuration found for:', selectedDevice);
                portSelects.forEach(ps => {
                    if (ps) ps.innerHTML = '<option value="">Select Port (Choose Device First)</option>';
                });
                return;
            }

            // Get all available ports
            let allPorts = [];
            if (deviceConfig.ports && deviceConfig.sfpPorts) {
                allPorts = [...deviceConfig.ports, ...deviceConfig.sfpPorts];
            } else if (typeof getDevicePortOptions === 'function') {
                allPorts = getDevicePortOptions(selectedDevice) || [];
            } else {
                // Fallback: hardcoded ports for common devices
                if (selectedDevice === 'ccr2004') {
                    allPorts = ['sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4', 'sfp-sfpplus5', 'sfp-sfpplus6', 'sfp-sfpplus7', 'sfp-sfpplus8', 'sfp-sfpplus9', 'sfp-sfpplus10', 'sfp-sfpplus11', 'sfp-sfpplus12'];
                } else if (selectedDevice === 'ccr2216') {
                    allPorts = ['sfp28-1', 'sfp28-2', 'sfp28-3', 'sfp28-4', 'sfp28-5', 'sfp28-6', 'sfp28-7', 'sfp28-8', 'sfp28-9', 'sfp28-10', 'sfp28-11', 'sfp28-12'];
                } else if (selectedDevice === 'ccr2116') {
                    allPorts = ['ether1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6', 'ether7', 'ether8', 'ether9', 'ether10', 'ether11', 'ether12', 'sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4'];
                }
            }

            // Clear existing options and populate with available ports
            portSelects.forEach((portSelect, index) => {
                if (portSelect) {
                    portSelect.innerHTML = '<option value="">Select Port</option>';

                    // Add all available ports
                    allPorts.forEach(port => {
                        const option = document.createElement('option');
                        option.value = port;
                        option.textContent = `${port} (${deviceConfig.name})`;
                        portSelect.appendChild(option);
                    });

                    // Auto-select recommended ports for BNG2 (but allow user to change)
                    const recommendedPorts = selectedDevice === 'ccr2004' || selectedDevice === 'ccr2216'
                        ? (selectedDevice === 'ccr2216'
                            ? ['sfp28-8', 'sfp28-9', 'sfp28-10', 'sfp28-6']  // CCR2216 defaults
                            : ['sfp-sfpplus8', 'sfp-sfpplus9', 'sfp-sfpplus10', 'sfp-sfpplus6'])  // CCR2004 defaults
                        : [];

                    if (recommendedPorts[index] && allPorts.includes(recommendedPorts[index])) {
                        portSelect.value = recommendedPorts[index];
                    }
                }
            });

            console.log('[BNG2] Ports populated for device:', deviceConfig.name);
        }

        // MPLS Enterprise Device Name Updater
        window.updateMPLSDeviceName = function () {
            const customerCode = (document.getElementById('ent_mpls_customerCode') || {}).value.trim();
            const deviceSel = document.getElementById('ent_mpls_routerboard_device');
            const deviceNameField = document.getElementById('ent_mpls_deviceName');

            if (!deviceNameField) return;

            // For MPLS, identity is just the customer code (e.g., NX-537853)
            if (customerCode) {
                deviceNameField.value = customerCode;
            } else {
                deviceNameField.value = '';
            }

            // Also update deviceType field if it exists
            if (deviceSel && deviceSel.value) {
                const typeSel = document.getElementById('ent_mpls_deviceType');
                if (typeSel) {
                    const map = {
                        'ccr2004': 'CCR2004',
                        'ccr2216': 'CCR2216',
                        'ccr1036': 'CCR1036',
                        'rb5009': 'RB5009',
                        'ccr1072': 'CCR1072',
                        'rb2011': 'RB2011',
                        'rb1009': 'RB1009'
                    };
                    typeSel.value = map[deviceSel.value] || '';
                }
            }
        }

        // MPLS Enterprise Interface Populator
        function updateMPLSEnterpriseInterfaces() {
            const deviceSel = document.getElementById('ent_mpls_routerboard_device');
            if (!deviceSel) return;

            const selectedDevice = deviceSel.value;
            if (!selectedDevice) {
                // Clear all interface dropdowns
                const handoffSel = document.getElementById('ent_mpls_customerHandoff');
                const uplinkSels = document.querySelectorAll('.ent_mpls_uplinkInterface');
                if (handoffSel) handoffSel.innerHTML = '<option value="">None (Auto-select based on device)</option>';
                uplinkSels.forEach(sel => {
                    sel.innerHTML = '<option value="">Select Interface (Choose Device First)</option>';
                });
                return;
            }

            // Get device config
            const deviceConfig = typeof DEVICE_CONFIGS !== 'undefined' && DEVICE_CONFIGS[selectedDevice]
                ? DEVICE_CONFIGS[selectedDevice]
                : null;

            if (!deviceConfig) {
                console.warn('[MPLS Enterprise] No device config found for:', selectedDevice);
                return;
            }

            // Get all available ports
            let allPorts = [];
            if (deviceConfig.ports && deviceConfig.sfpPorts) {
                allPorts = [...deviceConfig.ports, ...deviceConfig.sfpPorts];
            } else if (typeof getDevicePortOptions === 'function') {
                allPorts = getDevicePortOptions(selectedDevice) || [];
            }

            if (!allPorts || allPorts.length === 0) {
                console.warn('[MPLS Enterprise] No ports found for device:', selectedDevice);
                return;
            }

            // Populate customer handoff interface dropdown
            const handoffSel = document.getElementById('ent_mpls_customerHandoff');
            if (handoffSel) {
                handoffSel.innerHTML = '<option value="">None (Auto-select based on device)</option>';
                allPorts.forEach(port => {
                    const option = document.createElement('option');
                    option.value = port;
                    option.textContent = `${port} (${deviceConfig.name})`;
                    handoffSel.appendChild(option);
                });
            }

            // Populate uplink interface dropdowns
            const uplinkSels = document.querySelectorAll('.ent_mpls_uplinkInterface');
            uplinkSels.forEach(uplinkSel => {
                if (uplinkSel) {
                    uplinkSel.innerHTML = '<option value="">Select Interface</option>';
                    allPorts.forEach(port => {
                        const option = document.createElement('option');
                        option.value = port;
                        option.textContent = `${port} (${deviceConfig.name})`;
                        uplinkSel.appendChild(option);
                    });
                }
            });

            console.log('[MPLS Enterprise] Ports populated for device:', deviceConfig.name);
        }

        // Tarana Sectors Device Selection Handler
        function handleTaranaDeviceChange() {
            console.log('[TARANA] handleTaranaDeviceChange called');
            try {
                const deviceSelect = document.getElementById('tarana_routerboard_device');
                const portSelects = [
                    document.getElementById('tarana_alphaPort'),
                    document.getElementById('tarana_betaPort'),
                    document.getElementById('tarana_gammaPort'),
                    document.getElementById('tarana_deltaPort')
                ];

                console.log('[TARANA] deviceSelect:', deviceSelect);
                console.log('[TARANA] portSelects:', portSelects);
                console.log('[TARANA] DEVICE_CONFIGS available:', typeof DEVICE_CONFIGS !== 'undefined');

                if (!deviceSelect) {
                    console.error('[TARANA] Device select element not found!');
                    return;
                }

                // Check if port selects exist
                const missingPorts = portSelects.filter(ps => !ps);
                if (missingPorts.length > 0) {
                    console.error('[TARANA] Missing port select elements:', missingPorts.length);
                }

                const selectedDevice = deviceSelect.value;
                console.log('[TARANA] Selected device value:', selectedDevice);

                // If no device selected, clear all ports
                if (!selectedDevice) {
                    portSelects.forEach(ps => {
                        if (ps) {
                            ps.innerHTML = '<option value="">None</option>';
                        }
                    });
                    return;
                }

                // Hard restrict Tarana to CCR2004/CCR2216 only
                if (!['ccr2004', 'ccr2216'].includes(selectedDevice)) {
                    deviceSelect.value = '';
                    alert('Tarana sectors are supported only on CCR2004 and CCR2216.');
                    portSelects.forEach(ps => { if (ps) ps.innerHTML = '<option value="">None</option>'; });
                    return;
                }

                // Get device config or use fallback
                let allPorts = [];
                let deviceConfig = null;

                // Try DEVICE_CONFIGS first
                if (typeof DEVICE_CONFIGS !== 'undefined' && DEVICE_CONFIGS[selectedDevice]) {
                    deviceConfig = DEVICE_CONFIGS[selectedDevice];
                    console.log('[TARANA] Found device config:', deviceConfig);
                    if (deviceConfig.ports && deviceConfig.sfpPorts) {
                        allPorts = [...deviceConfig.ports, ...deviceConfig.sfpPorts];
                        console.log('[TARANA] Ports from DEVICE_CONFIGS:', allPorts.length);
                    }
                } else {
                    console.warn('[TARANA] DEVICE_CONFIGS not available or device not found, using fallback');
                }

                // Fallback: use getDevicePortOptions if DEVICE_CONFIGS structure is missing or incomplete
                if (!allPorts || allPorts.length === 0) {
                    if (typeof getDevicePortOptions !== 'undefined') {
                        allPorts = getDevicePortOptions(selectedDevice);
                        console.log('[TARANA] Ports from getDevicePortOptions:', allPorts ? allPorts.length : 0);
                    } else {
                        // Hardcoded fallback for CCR2004 and CCR2216
                        if (selectedDevice === 'ccr2004') {
                            allPorts = ['sfp-sfpplus1', 'sfp-sfpplus2', 'sfp-sfpplus3', 'sfp-sfpplus4', 'sfp-sfpplus5', 'sfp-sfpplus6', 'sfp-sfpplus7', 'sfp-sfpplus8', 'sfp-sfpplus9', 'sfp-sfpplus10', 'sfp-sfpplus11', 'sfp-sfpplus12', 'ether1'];
                            console.log('[TARANA] Using hardcoded fallback for ccr2004');
                        } else if (selectedDevice === 'ccr2216') {
                            allPorts = ['sfp28-1', 'sfp28-2', 'sfp28-3', 'sfp28-4', 'sfp28-5', 'sfp28-6', 'sfp28-7', 'sfp28-8', 'sfp28-9', 'sfp28-10', 'sfp28-11', 'sfp28-12', 'ether1'];
                            console.log('[TARANA] Using hardcoded fallback for ccr2216');
                        }
                    }
                }

                if (!allPorts || allPorts.length === 0) {
                    console.error('[TARANA] No ports found for device:', selectedDevice);
                    portSelects.forEach(portSelect => {
                        if (portSelect) {
                            portSelect.innerHTML = '<option value="">None</option>';
                        }
                    });
                    return;
                }

                // Get deviceConfig if not already set
                if (!deviceConfig && typeof DEVICE_CONFIGS !== 'undefined') {
                    deviceConfig = DEVICE_CONFIGS[selectedDevice] || null;
                }

                // Clear existing options and populate with available ports
                console.log('[TARANA] Populating ports:', allPorts.length, 'ports found');
                portSelects.forEach((portSelect, index) => {
                    if (portSelect) {
                        console.log(`[TARANA] Populating ${portSelect.id} with ${allPorts.length} ports`);
                        portSelect.innerHTML = '<option value="">None</option>';

                        // Add all available ports
                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            const displayName = deviceConfig ? `${port} (${deviceConfig.name})` : port;
                            option.textContent = displayName;
                            portSelect.appendChild(option);
                        });

                        // Preselect recommended Tarana ports when device is CCR2004/CCR2216
                        if (selectedDevice === 'ccr2004') {
                            if (portSelect.id === 'tarana_alphaPort') {
                                portSelect.value = 'sfp-sfpplus8';
                                console.log('[TARANA] Auto-selected ALPHA:', 'sfp-sfpplus8');
                            }
                            if (portSelect.id === 'tarana_betaPort') {
                                portSelect.value = 'sfp-sfpplus9';
                                console.log('[TARANA] Auto-selected BETA:', 'sfp-sfpplus9');
                            }
                            if (portSelect.id === 'tarana_gammaPort') {
                                portSelect.value = 'sfp-sfpplus10';
                                console.log('[TARANA] Auto-selected GAMMA:', 'sfp-sfpplus10');
                            }
                        } else if (selectedDevice === 'ccr2216') {
                            if (portSelect.id === 'tarana_alphaPort') {
                                portSelect.value = 'sfp28-2';
                                console.log('[TARANA] Auto-selected ALPHA:', 'sfp28-2');
                            }
                            if (portSelect.id === 'tarana_betaPort') {
                                portSelect.value = 'sfp28-7';
                                console.log('[TARANA] Auto-selected BETA:', 'sfp28-7');
                            }
                            if (portSelect.id === 'tarana_gammaPort') {
                                portSelect.value = 'sfp28-8';
                                console.log('[TARANA] Auto-selected GAMMA:', 'sfp28-8');
                            }
                        }
                        console.log(`[TARANA] ${portSelect.id} now has ${portSelect.options.length} options, selected: ${portSelect.value}`);
                    } else {
                        console.error(`[TARANA] Port select ${index} is null!`);
                    }
                });

                const deviceName = deviceConfig ? deviceConfig.name : selectedDevice.toUpperCase();
                console.log(`[TARANA] Device selected: ${deviceName}`);
                console.log(`[TARANA] Ports updated:`, allPorts);
            } catch (error) {
                console.error('[TARANA] Error in handleTaranaDeviceChange:', error);
                alert('Error populating ports. Please check the browser console for details.');
            }
        }

        // Tarana Sectors RouterOS Version Handler
        function handleTaranaRouterOSChange() {
            const routerOSSelect = document.getElementById('tarana_routeros_version');
            if (!routerOSSelect) return;

            const selectedVersion = routerOSSelect.value;
            const versionType = getRouterOSVersionType(selectedVersion);
            // Force 7.x only for Tarana; reset if 6.x picked somehow
            if (selectedVersion && selectedVersion.startsWith('6.')) {
                routerOSSelect.value = '';
                alert('Tarana sectors require RouterOS 7.x.');
                return;
            }

            if (versionType === 'new') {
                console.log(`Tarana Sectors - RouterOS ${selectedVersion} - Using new speed syntax (e.g., 1G-baseT-full)`);
            } else {
                console.log(`Tarana Sectors - RouterOS ${selectedVersion} - Using classic speed syntax (e.g., 1Gbps-duplex=full)`);
            }
        }

        // Move all constants to the top level to avoid redeclaration
        const SNMP_ADDRESSES = [
            '143.55.35.47', '107.178.15.15', '107.178.15.162', '142.147.112.4',
            '142.147.124.26', '107.178.5.97', '67.219.126.240/28', '198.100.53.120',
            '143.55.62.143', '132.147.138.2', '132.147.138.0', '132.147.138.6',
            '132.147.138.23', '132.147.138.29', '132.147.138.30', '132.147.138.31',
            '143.55.37.40', '143.55.37.41', '132.147.132.24', '198.100.49.99',
            '132.147.132.26', '204.11.183.126', '173.215.67.124', '132.147.138.3',
            '132.147.138.7', '132.147.138.21', '132.147.138.26'
        ];

        // WALLED_GARDEN_ADDRESSES - Use infrastructure values or empty array
        // These should be configured via infrastructure configuration, not hardcoded
        const WALLED_GARDEN_ADDRESSES = [];

        const DENIED_PREFIXES = [
            '10.2.0.14/32', '10.2.0.21/32', '10.2.0.107/32', '10.2.0.108/32',
            '10.17.0.10/32', '10.17.0.11/32', '10.30.0.9/32', '10.240.0.3/32',
            '10.243.0.9/32', '10.248.0.220/32', '10.249.0.220/32', '10.0.0.87/32',
            '10.9.0.88/32', '10.254.247.9/32'
        ];

        const ALLOWED_PREFIXES = [
            '10.2.0.10/32', '10.0.0.0/24', '10.0.1.0/24', '10.1.0.0/24', '10.2.0.0/24',
            '10.3.0.0/24', '10.4.0.0/24', '10.4.3.0/24', '10.5.0.0/24', '10.6.0.0/24',
            '10.7.0.0/24', '10.7.250.0/24', '10.7.254.0/24', '10.8.0.0/24', '10.9.0.0/24',
            '10.9.1.0/24', '10.9.2.0/24', '10.10.0.0/24', '10.11.0.0/24', '10.12.0.0/24',
            '10.13.0.0/24', '10.14.0.0/24', '10.15.0.0/24', '10.16.0.0/24', '10.17.0.0/24',
            '10.17.16.0/24', '10.17.18.0/24', '10.17.31.0/24', '10.17.48.0/24',
            '10.18.0.0/24', '10.18.2.0/24', '10.19.0.0/24', '10.21.0.0/24', '10.22.0.0/24',
            '10.25.0.0/24', '10.26.0.0/24', '10.27.0.0/24', '10.30.0.0/24', '10.32.0.0/24',
            '10.33.0.0/24', '10.34.0.0/24', '10.35.0.0/24', '10.36.0.0/24', '10.37.0.0/24',
            '10.39.0.0/24', '10.45.252.0/24', '10.47.0.0/24', '10.53.252.0/22',
            '10.254.243.0/24', '10.243.0.0/24', '10.54.0.0/22', '10.250.0.0/24',
            '10.250.40.0/22', '10.241.0.0/24', '10.241.64.0/22', '10.254.245.0/24',
            '10.254.249.0/24', '10.249.0.0/24', '10.249.7.0/24', '10.249.180.0/22',
            '10.254.247.0/24', '10.247.0.0/24', '10.247.13.0/24', '10.247.72.0/24',
            '10.247.147.0/24', '10.247.187.0/24', '10.247.64.0/22', '10.254.248.0/24',
            '10.248.0.0/24', '10.248.32.0/24', '10.248.36.0/24', '10.248.86.0/24',
            '10.248.208.0/22'
        ];

        function calculateNetwork(ipCidr) {
            if (!ipCidr || !ipCidr.includes('/')) return ipCidr;

            const [ip, cidr] = ipCidr.split('/');
            const octets = ip.split('.').map(Number);
            const prefix = parseInt(cidr);

            // Calculate subnet mask
            const mask = (0xFFFFFFFF << (32 - prefix)) >>> 0;

            // Calculate network address
            const ipNum = (octets[0] << 24 | octets[1] << 16 | octets[2] << 8 | octets[3]) >>> 0;
            const networkNum = (ipNum & mask) >>> 0;

            // Convert back to dotted decimal
            const networkOctets = [
                (networkNum >>> 24) & 0xFF,
                (networkNum >>> 16) & 0xFF,
                (networkNum >>> 8) & 0xFF,
                networkNum & 0xFF
            ];

            return networkOctets.join('.');
        }

        function addDHCPConfiguration(config, enableDHCP, routerId, dnsServers, dhcpSecret) {
            if (!enableDHCP) return config;

            const cgnatRange = document.getElementById('cgnatRange').value.trim() || '100.64.112.0/22';
            const cpeRange = document.getElementById('cpeRange').value.trim();
            const unauthRange = document.getElementById('unauthRange').value.trim();
            const vlan4000Range = document.getElementById('vlan4000Range').value.trim();

            // DHCP Options
            config += `/ip dhcp-server option\n`;
            config += `add code=66 name=option66-ata value="'http://ndp1-dal.nxlink.com/cfg/\$MA.cfg'"\n`;
            config += `add code=43 name=opt43 value=0x011768747470733a2f2f7573732e6e786c696e6b2e636f6d2f\n`;
            config += `/ip dhcp-server option sets\n`;
            config += `add name=optset options=opt43\n`;

            // IP Pools
            config += `/ip pool\n`;
            if (cpeRange && cpeRange.includes('/')) {
                const [cpeNet] = cpeRange.split('/');
                const cpeOctets = cpeNet.split('.').map(Number);
                const cpeStart = `${cpeOctets[0]}.${cpeOctets[1]}.${cpeOctets[2]}.50`;
                const cpeEnd = `${cpeOctets[0]}.${cpeOctets[1]}.${cpeOctets[2] + 3}.254`;
                config += `add name=cpe ranges=${cpeStart}-${cpeEnd}\n`;
            }
            if (cgnatRange && cgnatRange.includes('/')) {
                const [cgnatNet] = cgnatRange.split('/');
                const cgnatOctets = cgnatNet.split('.').map(Number);
                const cgnatStart = `${cgnatOctets[0]}.${cgnatOctets[1]}.${cgnatOctets[2]}.3`;
                const cgnatEnd = `${cgnatOctets[0]}.${cgnatOctets[1]}.${cgnatOctets[2] + 3}.254`;
                config += `add name=cust ranges=${cgnatStart}-${cgnatEnd}\n`;
            }
            if (unauthRange && unauthRange.includes('/')) {
                const [unauthNet] = unauthRange.split('/');
                const unauthOctets = unauthNet.split('.').map(Number);
                const unauthStart = `${unauthOctets[0]}.${unauthOctets[1]}.${unauthOctets[2]}.2`;
                const unauthEnd = `${unauthOctets[0]}.${unauthOctets[1]}.${unauthOctets[2] + 3}.254`;
                config += `add name=unauth ranges=${unauthStart}-${unauthEnd}\n`;
            }
            if (document.getElementById('enableSWT').checked && vlan4000Range && vlan4000Range.includes('/')) {
                const [vlan4000Net] = vlan4000Range.split('/');
                const vlan4000Octets = vlan4000Net.split('.').map(Number);
                const vlan4000Start = `${vlan4000Octets[0]}.${vlan4000Octets[1]}.${vlan4000Octets[2]}.50`;
                const vlan4000End = `${vlan4000Octets[0]}.${vlan4000Octets[1]}.${vlan4000Octets[2] + 3}.254`;
                config += `add name=vlan4000 ranges=${vlan4000Start}-${vlan4000End}\n`;
            }

            // DHCP Servers
            config += `/ip dhcp-server\n`;
            config += `add address-pool=cust interface=lan-bridge lease-time=1h name=server1 use-radius=yes\n`;
            if (document.getElementById('enableSWT').checked && vlan4000Range) {
                config += `add address-pool=vlan4000 interface=bridge4000 lease-time=1h name=vlan4000\n`;
            }

            // DHCP Server Networks
            config += `/ip dhcp-server network\n`;
            if (cpeRange && cpeRange.includes('/')) {
                const [cpeNet, cpeCidr] = cpeRange.split('/');
                const cpeGateway = `${cpeNet.split('.')[0]}.${cpeNet.split('.')[1]}.${cpeNet.split('.')[2]}.1`;
                // Add dhcp-option-set=optset if address doesn't start with "10."
                const cpeDhcpOptset = cpeNet.startsWith('10.') ? '' : ' dhcp-option-set=optset';
                config += `add address=${cpeRange} dns-server=${dnsServers} gateway=${cpeGateway}${cpeDhcpOptset}\n`;
            }
            if (cgnatRange && cgnatRange.includes('/')) {
                const [cgnatNet, cgnatCidr] = cgnatRange.split('/');
                const cgnatGateway = `${cgnatNet.split('.')[0]}.${cgnatNet.split('.')[1]}.${cgnatNet.split('.')[2]}.1`;
                // Add dhcp-option-set=optset if address doesn't start with "10."
                const cgnatDhcpOptset = cgnatNet.startsWith('10.') ? '' : ' dhcp-option-set=optset';
                config += `add address=${cgnatRange} dns-server=${dnsServers} gateway=${cgnatGateway}${cgnatDhcpOptset}\n`;
            }
            if (unauthRange && unauthRange.includes('/')) {
                const [unauthNet, unauthCidr] = unauthRange.split('/');
                const unauthGateway = `${unauthNet.split('.')[0]}.${unauthNet.split('.')[1]}.${unauthNet.split('.')[2]}.1`;
                // Add dhcp-option-set=optset if address doesn't start with "10."
                const unauthDhcpOptset = unauthNet.startsWith('10.') ? '' : ' dhcp-option-set=optset';
                config += `add address=${unauthRange} dns-server=${dnsServers} gateway=${unauthGateway}${unauthDhcpOptset}\n`;
            }
            if (document.getElementById('enableSWT').checked && vlan4000Range && vlan4000Range.includes('/')) {
                const [vlan4000Net, vlan4000Cidr] = vlan4000Range.split('/');
                const vlan4000Gateway = `${vlan4000Net.split('.')[0]}.${vlan4000Net.split('.')[1]}.${vlan4000Net.split('.')[2]}.1`;
                // Add dhcp-option-set=optset if address doesn't start with "10."
                const vlan4000DhcpOptset = vlan4000Net.startsWith('10.') ? '' : ' dhcp-option-set=optset';
                config += `add address=${vlan4000Range} dns-server=${dnsServers} gateway=${vlan4000Gateway}${vlan4000DhcpOptset}\n`;
            }

            // RADIUS configuration - DHCP only (no login services)
            config += `/radius\n`;
            const radiusDHCPServers = getRADIUSDHCPServers();
            if (radiusDHCPServers.length > 0) {
                radiusDHCPServers.forEach(server => {
                    if (server.address && server.secret) {
                        config += `add address=${server.address} secret=${server.secret} service=dhcp src-address=${routerId} timeout=5s\n`;
                    }
                });
            } else {
                // No RADIUS servers configured - skip RADIUS config
                console.warn('[CONFIG] No RADIUS DHCP servers configured. Skipping RADIUS configuration.');
            }

            return config;
        }

        function addFirewallConfiguration(config, enableDHCP, enableMPLS, opts = {}) {
            const listsOnly = opts && opts.listsOnly === true;
            // IP Firewall Address List
            config += `/ip firewall address-list\n`;
            config += `add address=10.0.0.0/8 list=EOIP-ALLOW\n`;
            config += `add address=192.168.128.0/21 list=managerIP\n`;
            config += `add address=107.178.5.97 list=managerIP\n`;
            config += `add address=198.100.53.0/25 list=managerIP\n`;
            config += `add address=143.55.62.143 list=managerIP\n`;
            config += `add address=142.147.127.2 list=managerIP\n`;
            config += `add address=132.147.132.6 list=managerIP\n`;
            config += `add address=67.219.122.201 list=managerIP\n`;
            config += `add address=10.249.1.26 list=managerIP\n`;
            config += `add address=10.0.0.0/8 list=managerIP\n`;
            config += `add address=10.0.0.0/8 list=BGP-ALLOW\n`;

            if (enableDHCP) {
                const cgnatRange = document.getElementById('cgnatRange').value.trim();
                const unauthRange = document.getElementById('unauthRange').value.trim();
                if (cgnatRange) config += `add address=${cgnatRange} list=bgp-networks\n`;
                if (unauthRange) {
                    config += `add address=${unauthRange} list=bgp-networks\n`;
                    config += `add address=${unauthRange} list=unauth\n`;
                }
                WALLED_GARDEN_ADDRESSES.forEach(addr => {
                    config += `add address=${addr} list=WALLED-GARDEN\n`;
                });
            }

            SNMP_ADDRESSES.forEach(addr => {
                config += `add address=${addr} list=SNMP\n`;
            });

            // Add static customers to firewall address lists
            const staticCustomers = Array.from(document.querySelectorAll('#staticCustomers .customer-item:not(#customerTemplate)'))
                .map(item => ({
                    name: item.querySelector('input[name="customerName"]')?.value,
                    range: item.querySelector('input[name="customerRange"]')?.value,
                    comment: item.querySelector('input[name="customerComment"]')?.value
                }))
                .filter(customer => customer.name && customer.range);

            staticCustomers.forEach(customer => {
                config += `add address=${customer.range} comment="${customer.comment || customer.name}" list=static-customers\n`;
            });

            if (listsOnly) {
                config += `\n`;
                return config;
            }

            // IP Firewall Filter
            config += `/ip firewall filter\n`;
            config += `add action=accept chain=input comment="ALLOW EST REL" connection-state=established,related,untracked\n`;
            config += `add action=accept chain=input comment="ALLOW MT NEIGHBOR" dst-port=5678 protocol=udp\n`;
            config += `add action=accept chain=input comment="ALLOW MAC TELNET" dst-port=20561 protocol=udp\n`;
            config += `add action=accept chain=input comment="ALLOW IGMP" protocol=igmp\n`;
            config += `add action=accept chain=input comment="ALLOW ICMP" protocol=icmp\n`;
            config += `add action=accept chain=input comment="ALLOW DHCPv4" dst-port=67 protocol=udp\n`;
            config += `add action=accept chain=input comment="ALLOW DHCPv6" dst-port=547 protocol=udp\n`;
            config += `add action=accept chain=input comment="ALLOW OSPF" protocol=ospf\n`;
            if (enableMPLS) {
                config += `add action=accept chain=input comment="ALLOW LDP" dst-port=646 protocol=tcp\n`;
                config += `add action=accept chain=input comment="ALLOW LDP" dst-port=646 protocol=udp\n`;
            }
            config += `add action=accept chain=input comment="ALLOW MANAGER IP" src-address-list=managerIP\n`;
            config += `add action=accept chain=input comment="ALLOW BGP" dst-port=179 protocol=tcp src-address-list=BGP-ALLOW\n`;
            config += `add action=accept chain=input comment="ALLOW EOIP" protocol=gre src-address-list=EOIP-ALLOW\n`;
            config += `add action=accept chain=input comment="ALLOW SNMP" dst-port=161 protocol=udp src-address-list=SNMP\n`;
            config += `add action=drop chain=input comment="DROP INPUT"\n`;
            config += `add action=accept chain=forward comment="BGP Accept" dst-address=10.0.0.0/8 dst-port=179 protocol=tcp src-address=10.0.0.0/8\n`;
            config += `add action=accept chain=forward comment="GRE Accept" dst-address=10.0.0.0/8 protocol=gre src-address=10.0.0.0/8\n`;
            if (enableDHCP) {
                config += `add action=drop chain=forward comment="unauth drop rule" dst-address-list=!WALLED-GARDEN src-address-list=unauth\n`;
            }
            // Allow static customers full access
            if (staticCustomers.length > 0) {
                config += `add action=accept chain=forward comment="Allow static customers" src-address-list=static-customers\n`;
            }
            config += `add action=fasttrack-connection chain=forward connection-state=established,related,untracked hw-offload=yes\n`;
            config += `add action=accept chain=forward connection-state=established,related,untracked\n`;

            // IP Firewall NAT - Dynamic rules based on user configuration
            config += `/ip firewall nat\n`;

            // Dynamic src-nat rules based on user IP configuration
            const natPublicIP = document.getElementById('natPublicIP').value.trim();
            const lanBridgeIP = document.getElementById('lanBridgeIP').value.trim();

            if (natPublicIP && lanBridgeIP) {
                const natIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                const lanNetwork = calculateNetwork(lanBridgeIP);
                const lanCidr = lanBridgeIP.split('/')[1];

                // Source NAT for LAN traffic
                config += `add action=src-nat chain=srcnat comment="LAN to Internet NAT" out-interface=all src-address=${lanNetwork}/${lanCidr} to-addresses=${natIP}\n`;
            }

            if (enableDHCP) {
                config += `add action=dst-nat chain=dstnat comment="unauth proxy rule" dst-address-list=!WALLED-GARDEN dst-port=80 protocol=tcp src-address-list=unauth to-addresses=107.178.15.27 to-ports=3128\n`;

                // Dynamic src-nat rules for DHCP ranges
                const cgnatRange = document.getElementById('cgnatRange').value.trim();
                const unauthRange = document.getElementById('unauthRange').value.trim();

                if (cgnatRange && natPublicIP) {
                    const natIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                    config += `add action=src-nat chain=srcnat comment="CGNAT to Public" src-address=${cgnatRange} to-addresses=${natIP}\n`;
                }

                if (unauthRange && natPublicIP) {
                    const natIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                    config += `add action=src-nat chain=srcnat comment="Unauth to Public" src-address=${unauthRange} to-addresses=${natIP}\n`;
                }
            }

            // IP Firewall Raw
            config += `/ip firewall raw\nadd action=drop chain=prerouting comment="DROP BAD UDP" port=0 protocol=udp\n`;

            // IP Firewall Service-Port
            config += `/ip firewall service-port\nset sip disabled=yes\n`;

            return config;
        }
        function addMPLSConfiguration(config, enableMPLS, uplinkCount, deviceConfig) {
            // MPLS LDP Filters (always added for security)
            config += `/mpls ldp accept-filter\n`;
            DENIED_PREFIXES.forEach(prefix => {
                config += `add accept=no disabled=no prefix=${prefix}\n`;
            });
            ALLOWED_PREFIXES.forEach(prefix => {
                config += `add accept=yes disabled=no prefix=${prefix}\n`;
            });
            config += `add accept=no disabled=no prefix=0.0.0.0/0\n`;

            config += `/mpls ldp advertise-filter\n`;
            DENIED_PREFIXES.forEach(prefix => {
                config += `add advertise=no disabled=no prefix=${prefix}\n`;
            });
            ALLOWED_PREFIXES.forEach(prefix => {
                config += `add advertise=yes disabled=no prefix=${prefix}\n`;
            });
            config += `add advertise=no disabled=no prefix=0.0.0.0/0\n`;

            if (enableMPLS) {
                const mplsMtu = document.getElementById('mplsMtu').value || '9000';
                const ldpTransport = document.getElementById('ldpTransport').value || document.getElementById('routerId').value;

                config += `/mpls interface\nadd disabled=no interface=all mpls-mtu=${mplsMtu}\n`;
                config += `/mpls ldp\nadd afi=ip disabled=no distribute-for-default=no hop-limit=255 loop-detect=no lsr-id=${ldpTransport} path-vector-limit=255 transport-addresses=${ldpTransport} use-explicit-null=no vrf=main\n`;

                config += `/mpls ldp interface\n`;
                // Process all uplinks dynamically for MPLS LDP
                const allUplinkElements = document.querySelectorAll('#uplinks .uplink-item:not(#uplinkTemplate)');
                allUplinkElements.forEach((element, index) => {
                    const port = element.querySelector('select[id*="NewPort"]')?.value;
                    const comment = element.querySelector('input[id*="Comment"]')?.value || `Uplink-${index + 1}`;
                    if (port) {
                        config += `add comment="${comment}" disabled=no interface=${port}\n`;
                    }
                });
            }

            return config;
        }
        document.addEventListener('DOMContentLoaded', () => {
            // Initialize counters first
            let vlanCount = 0;
            let vplsCount = 0;
            let customerCount = 0;
            let uplinkCount = 1;
            let portCount = 0;

            // Dark mode toggle will be handled in initializeEventHandlers

            // DHCP toggle and other event handlers moved to initializeEventHandlers

            // Seed hidden defaults early so validation and generation don't produce blank keys/DNS/community.
            (function seedHiddenDefaults() {
                const setIfEmpty = (id, value) => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    const cur = (el.value || '').trim();
                    if (!cur && value) el.value = value;
                };
                const setIfDefault = (id, value) => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    const cur = (el.value || '').trim();
                    if (!value) return;
                    if (!cur || cur.toUpperCase() === 'CHANGE_ME') el.value = value;
                };

                setIfEmpty('sharedKey', getInfrastructureValue('sharedKeys.ospfBgpMd5', 'm8M5JwvdYM') || 'm8M5JwvdYM');
                setIfEmpty('dnsServers', (typeof getDNSList === 'function' ? getDNSList() : '142.147.112.3,142.147.112.19'));

                const snmpEl = document.getElementById('snmpCommunity');
                if (snmpEl) {
                    const cur = (snmpEl.value || '').trim();
                    if (!cur || cur.toUpperCase() === 'CHANGE_ME') {
                        const suffix = Math.random().toString(36).slice(2, 10);
                        snmpEl.value = `NX${suffix}`;
                    }
                }

                // Best-effort: fetch authoritative infra defaults from backend (requires auth).
                // This improves consistency (e.g., RADIUS secret) without forcing humans to type secrets into the UI.
                (async function loadInfraFromBackend() {
                    try {
                        const token = localStorage.getItem('auth_token');
                        if (!token) return;
                        const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                        const r = await fetch(`${apiBase}/infrastructure`, { headers: { 'Authorization': `Bearer ${token}` } });
                        if (!r.ok) return;
                        const data = await r.json();

                        const dns = data?.dns_servers;
                        if (dns?.primary && dns?.secondary) {
                            setIfDefault('dnsServers', `${dns.primary},${dns.secondary}`);
                        }
                        if (data?.shared_key) {
                            setIfDefault('sharedKey', data.shared_key);
                        }
                        if (data?.snmp?.contact) {
                            // Keep NEXTLINK_INFRASTRUCTURE in sync so other generators can read it.
                            if (typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' && NEXTLINK_INFRASTRUCTURE?.snmp) {
                                NEXTLINK_INFRASTRUCTURE.snmp.contact = data.snmp.contact;
                            }
                        }

                        const radiusSecret = data?.radius?.secret;
                        const dhcpServers = Array.isArray(data?.radius?.dhcp_servers) ? data.radius.dhcp_servers : [];
                        const loginServers = Array.isArray(data?.radius?.login_servers) ? data.radius.login_servers : [];
                        if (radiusSecret) {
                            setIfDefault('dhcpSecret', radiusSecret);
                            if (typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' && NEXTLINK_INFRASTRUCTURE?.radiusServers) {
                                NEXTLINK_INFRASTRUCTURE.radiusServers.dhcp = dhcpServers.map(a => ({ address: a, secret: radiusSecret }));
                                NEXTLINK_INFRASTRUCTURE.radiusServers.login = loginServers.map(a => ({ address: a, secret: radiusSecret, comment: 'RADIUS' }));
                            }
                        }
                    } catch (e) {
                        // Non-fatal: UI will fall back to local defaults.
                    }
                })();
            })();

            function calculateDHCPRanges() {
                const lanBridgeIP = document.getElementById('lanBridgeIP').value.trim();
                if (lanBridgeIP && lanBridgeIP.includes('/')) {
                    const [ip] = lanBridgeIP.split('/');
                    const octets = ip.split('.').map(Number);

                    // CPE Range - use the LAN bridge network directly
                    document.getElementById('cpeRange').value = calculateNetwork(lanBridgeIP) + '/' + lanBridgeIP.split('/')[1];

                    // Unauth Range - add 100 to the SECOND octet (10.45.x.x becomes 10.145.x.x)
                    if (octets[1] !== undefined) {
                        const unauthSecondOctet = octets[1] + 100;
                        const unauthRange = `${octets[0]}.${unauthSecondOctet}.${octets[2]}.0/${lanBridgeIP.split('/')[1]}`;
                        document.getElementById('unauthRange').value = unauthRange;
                    }
                }

                // VLAN 4000 range from VLAN 4000 subnet if provided
                const vlan4000Subnet = document.getElementById('vlan4000Subnet').value.trim();
                if (vlan4000Subnet && vlan4000Subnet.includes('/')) {
                    document.getElementById('vlan4000Range').value = calculateNetwork(vlan4000Subnet) + '/' + vlan4000Subnet.split('/')[1];
                }
            }

            // Refactored VLAN and VPLS functions with preset support
            function addVlan(preset = {}) {
                if (vlanCount >= 10) return null;
                const tpl = document.getElementById('vlanTemplate').cloneNode(true);
                tpl.style.display = 'block';
                const num = ++vlanCount;
                tpl.id = `vlan${num}`;

                // Safer element selection using name attributes
                const selParent = tpl.querySelector('select[name="vlanParent"]') || tpl.querySelector('select');
                const inpId = tpl.querySelector('input[name="vlanId"]');
                const inpComment = tpl.querySelector('input[name="vlanComment"]');
                const inpBridge = tpl.querySelector('input[name="vlanBridge"]');

                // Assign unique IDs
                if (selParent) selParent.id = `vlan${num}Parent`;
                if (inpId) inpId.id = `vlan${num}Id`;
                if (inpComment) inpComment.id = `vlan${num}Comment`;
                if (inpBridge) inpBridge.id = `vlan${num}Bridge`;

                // Populate port options for the new VLAN parent interface
                if (selParent) {
                    const targetDevice = document.getElementById('targetDevice').value;
                    const currentDevice = document.getElementById('currentDevice').value;
                    const selectedDevice = targetDevice || currentDevice;

                    if (selectedDevice && DEVICE_CONFIGS[selectedDevice]) {
                        const allPorts = [...DEVICE_CONFIGS[selectedDevice].ports, ...DEVICE_CONFIGS[selectedDevice].sfpPorts];
                        selParent.innerHTML = '';
                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            selParent.appendChild(option);
                        });
                    }
                }

                // Fill values with preset data
                if (selParent) selParent.value = preset.parent ?? (selParent.options[0] ? selParent.options[0].value : '');
                if (inpId) inpId.value = preset.vid ?? '';
                if (inpComment) inpComment.value = preset.comment ?? '';
                if (inpBridge) inpBridge.value = preset.bridge ?? '';

                // Remove handler
                const btn = tpl.querySelector('button');
                if (btn) btn.onclick = () => {
                    tpl.remove();
                    vlanCount--;
                    document.getElementById('addVlanBtn').disabled = vlanCount >= 10;
                };

                document.getElementById('vlanInterfaces').appendChild(tpl);
                if (vlanCount === 10) document.getElementById('addVlanBtn').disabled = true;
                return tpl;
            }

            function addVpls(preset = {}) {
                if (vplsCount >= 8) return null;
                const tpl = document.getElementById('vplsTemplate').cloneNode(true);
                tpl.style.display = 'block';
                const num = ++vplsCount;
                tpl.id = `vpls${num}`;

                // Safer element selection using name attributes
                const inpName = tpl.querySelector('input[name="vplsName"]');
                const inpBridge = tpl.querySelector('input[name="vplsBridge"]');
                const inpPeer = tpl.querySelector('input[name="vplsPeer"]');
                const inpStatic = tpl.querySelector('input[name="vplsStaticId"]');

                // Assign unique IDs
                if (inpName) inpName.id = `vpls${num}Name`;
                if (inpBridge) inpBridge.id = `vpls${num}Bridge`;
                if (inpPeer) inpPeer.id = `vpls${num}Peer`;
                if (inpStatic) inpStatic.id = `vpls${num}StaticId`;

                // Fill values with preset data
                if (inpName) inpName.value = preset.name ?? '';
                if (inpBridge) inpBridge.value = preset.bridge ?? '';
                if (inpPeer) inpPeer.value = preset.peer ?? '';
                if (inpStatic) inpStatic.value = preset.staticId ?? '';

                // Remove handler
                const btn = tpl.querySelector('button');
                if (btn) btn.onclick = () => {
                    tpl.remove();
                    vplsCount--;
                    document.getElementById('addVplsBtn').disabled = vplsCount >= 8;
                };

                document.getElementById('vplsInstances').appendChild(tpl);
                if (vplsCount === 8) document.getElementById('addVplsBtn').disabled = true;
                return tpl;
            }

            function updateVlanCount() {
                vlanCount = document.querySelectorAll('.vlan-item:not(#vlanTemplate)').length;
                document.getElementById('addVlanBtn').disabled = vlanCount >= 10;
            }

            function updateVplsCount() {
                vplsCount = document.querySelectorAll('.vpls-item:not(#vplsTemplate)').length;
                document.getElementById('addVplsBtn').disabled = vplsCount >= 8;
            }

            function vplsBaseForArea(area) {
                if (area === 'area243-v2') return 1000;   // use VID directly
                if (area === 'area249') return 1249;
                if (area === 'area248-v2') return 1248;
                if (area === 'area250') return 1250;
                if (area === 'area42-v2' || area === 'area42') return 1245;
                if (area === 'backbone-v2-IL') return 1247;
                return null;
            }

            function autoPopulateVpls(area, defaultPeer = '10.249.0.200') {
                const base = vplsBaseForArea(area);
                if (base == null) return;

                // Clear existing VPLS instances first
                document.querySelectorAll('.vpls-item:not(#vplsTemplate)').forEach(el => el.remove());
                vplsCount = 0;

                // Read VIDs from existing VLAN rows
                const vids = Array.from(document.querySelectorAll('#vlanInterfaces .vlan-item:not(#vlanTemplate) input[name="vlanId"]'))
                    .map(i => Number(i.value)).filter(Boolean);

                vids.forEach(vid => {
                    const staticId = base === 1000 ? vid : base + (vid - 1000);
                    addVpls({
                        name: `vpls${vid}-bng1`,
                        bridge: vid === 1000 ? 'bridge1000' : `bridge${vid}`,
                        peer: defaultPeer,
                        staticId: String(staticId)
                    });
                });

                updateVplsCount();
            }

            // OSPF Area management with automatic protocol selection
            const ospfAreaMap = {
                'backbone-v2': { id: '0.0.0.0', bgp: true, mpls: false, vplsBase: null },
                'backbone-v2-IL': { id: '0.0.0.243', bgp: false, mpls: true, vplsBase: 1247 },
                'area243-v2': { id: '0.0.0.243', bgp: false, mpls: true, vplsBase: 1000 },
                'area248-v2': { id: '0.0.0.248', bgp: false, mpls: true, vplsBase: 1248 },
                'area249': { id: '0.0.0.249', bgp: false, mpls: true, vplsBase: 1249 },
                'area250': { id: '0.0.0.250', bgp: false, mpls: true, vplsBase: 1250 },
                'area42-v2': { id: '0.0.0.42', bgp: false, mpls: true, vplsBase: 1245 },
                'area42': { id: '0.0.0.42', bgp: false, mpls: true, vplsBase: 1245 }
            };

            // Function to handle OSPF area changes
            function handleOspfAreaChange(selectedArea) {
                const customInput = document.getElementById('ospfAreaCustom');
                const areaIdInput = document.getElementById('ospfAreaId');
                const bgpSection = document.getElementById('bgpSection');
                const enableMPLS = document.getElementById('enableMPLS');
                const enableVPLS = document.getElementById('enableVPLS');
                const enableDHCP = document.getElementById('enableDHCP');
                const dhcpSection = document.getElementById('dhcpSection');

                if (selectedArea === 'custom') {
                    customInput.style.display = 'block';
                    areaIdInput.readOnly = false;
                    areaIdInput.value = '0.0.0.0';
                } else {
                    customInput.style.display = 'none';
                    areaIdInput.readOnly = true;

                    const areaConfig = ospfAreaMap[selectedArea];
                    if (areaConfig) {
                        areaIdInput.value = areaConfig.id;

                        // Auto-configure protocols based on area
                        if (areaConfig.bgp) {
                            bgpSection.style.display = 'block';
                            enableMPLS.checked = false;
                            enableVPLS.checked = false;
                            document.querySelector('.mpls-section').style.display = 'none';
                            document.querySelector('.vpls-section').style.display = 'none';
                            // Enable DHCP for backbone-v2 areas
                            enableDHCP.checked = true;
                            dhcpSection.style.display = 'block';
                            calculateDHCPRanges();
                        } else {
                            bgpSection.style.display = 'none';
                            // Disable DHCP for MPLS areas (they use BNGs)
                            enableDHCP.checked = false;
                            dhcpSection.style.display = 'none';
                            if (areaConfig.mpls) {
                                enableMPLS.checked = true;
                                enableVPLS.checked = true;
                                document.querySelector('.mpls-section').style.display = 'block';
                                document.querySelector('.vpls-section').style.display = 'block';
                                // Auto-populate VPLS profile and instances for non-BGP areas
                                if (!document.getElementById('enableTarana').checked && !document.getElementById('enableSWT').checked) {
                                    document.getElementById('vlanProfile').value = 'vpls';
                                    populateVlanProfile('vpls');
                                }
                                // Always populate VPLS instances for MPLS areas
                                setTimeout(() => autoPopulateVpls(selectedArea), 100); // Small delay to ensure VLANs are populated first
                            }
                        }
                    }
                }
            }

            document.getElementById('ospfArea').addEventListener('change', (e) => {
                handleOspfAreaChange(e.target.value);
            });

            // Initialize with default area selection (backbone-v2)
            handleOspfAreaChange('backbone-v2');

            // Initialize DHCP ranges on page load
            calculateDHCPRanges();

            // Tarana event listeners moved to initializeEventHandlers

            function populateTaranaVlans() {
                // Clear existing Tarana VLANs first
                document.querySelectorAll('.vlan-item:not(#vlanTemplate)').forEach(el => {
                    const portSelect = el.querySelector('select[name="vlanParent"]');
                    if (portSelect && ['sfp-sfpplus6', 'sfp-sfpplus8', 'sfp-sfpplus9', 'sfp-sfpplus10'].includes(portSelect.value)) {
                        el.remove();
                        vlanCount--;
                    }
                });

                const fourthSector = document.getElementById('enableTaranaFourthSector').checked;

                // Standard Tarana ports with Greek letter names: Alpha, Beta, Gamma, Delta
                const taranaPorts = [
                    { port: 'sfp-sfpplus8', name: 'Alpha' },
                    { port: 'sfp-sfpplus9', name: 'Beta' },
                    { port: 'sfp-sfpplus10', name: 'Gamma' }
                ];

                if (fourthSector) {
                    taranaPorts.push({ port: 'sfp-sfpplus6', name: 'Delta' });
                }

                // VLAN configuration: always tagged 1000, 2000, 3000 on each port
                const vlanConfigs = [
                    { vid: 1000, comment: 'Dynamic VLAN', bridge: 'lan-bridge' },
                    { vid: 2000, comment: 'Static VLAN', bridge: 'bridge2000' },
                    { vid: 3000, comment: 'Infra VLAN', bridge: 'bridge3000' }
                ];

                taranaPorts.forEach(({ port, name }) => {
                    // Create VLANs 1000, 2000, 3000 on each Tarana port
                    vlanConfigs.forEach(vlanConfig => {
                        addVlan({
                            parent: port,
                            vid: String(vlanConfig.vid),
                            comment: `${vlanConfig.comment} - Sector ${name}`,
                            bridge: vlanConfig.bridge
                        });
                    });
                });
            }

            document.getElementById('enableSWT').addEventListener('change', (e) => {
                if (e.target.checked) {
                    document.getElementById('enableTarana').checked = false;
                    document.getElementById('vlanProfile').value = 'nonvpls';
                    populateVlanProfile('nonvpls');
                }
                toggleVlanSection();
            });
            document.getElementById('enableVPLS').addEventListener('change', (e) => {
                document.querySelector('.vpls-section').style.display = e.target.checked ? 'block' : 'none';
                if (e.target.checked) {
                    // Auto-select VPLS profile and populate VLANs
                    document.getElementById('vlanProfile').value = 'vpls';
                    populateVlanProfile('vpls');
                }
            });

            // MPLS event listener moved to initializeEventHandlers

            function toggleVlanSection() {
                // VLANs shown only when SWT is enabled. Enabling Tarana does not expose VLAN subnet fields.
                document.getElementById('vlanSection').style.display = document.getElementById('enableSWT').checked ? 'grid' : 'none';
            }

            // VLAN Profile auto-population using refactored functions
            function populateVlanProfile(profile) {
                // Clear existing VLAN interfaces first
                document.querySelectorAll('.vlan-item:not(#vlanTemplate)').forEach(el => el.remove());
                vlanCount = 0;

                // For Non-VPLS (in-state switch): NO VLAN interfaces needed
                // Switch uplinks are configured directly as bridge ports via "Auto-populate Switch Uplinks"
                // The 2 switch ports are assigned to lan-bridge in the Port & Uplink Configuration section
                if (profile === 'nonvpls') {
                    updateVlanCount();
                    return; // Don't create any VLAN interfaces for in-state switch configs
                }

                // For VPLS: create VLAN interfaces as before
                if (profile === 'vpls') {
                    // Dynamically choose parent interface for VLANs based on selected RouterBoard
                    function getDefaultVlanParent() {
                        const targetDevice = document.getElementById('targetDevice')?.value || 'ccr2004';
                        const dev = DEVICE_CONFIGS[targetDevice] || DEVICE_CONFIGS.ccr2004;
                        if (!dev) return 'sfp-sfpplus1';
                        // Prefer SFP ports, excluding ether1 (mgmt only)
                        const sfp = (dev.sfpPorts || []).filter(p => p !== 'ether1');
                        if (sfp.length) return sfp[0];
                        const ports = (dev.ports || []).filter(p => p !== 'ether1');
                        return ports[0] || 'sfp-sfpplus1';
                    }

                    const vlanParent = getDefaultVlanParent();

                    const vplsVlans = [
                        { vid: '1000', parent: vlanParent, comment: 'VPLS Dynamic', bridge: 'bridge1000' },
                        { vid: '2000', parent: vlanParent, comment: 'VPLS Static', bridge: 'bridge2000' },
                        { vid: '3000', parent: vlanParent, comment: 'VPLS Infra', bridge: 'bridge3000' },
                        { vid: '4000', parent: vlanParent, comment: 'VPLS CPE', bridge: 'bridge4000' }
                    ];

                    // Add VPLS VLAN interfaces
                    vplsVlans.forEach(vlan => {
                        addVlan(vlan);
                    });
                }

                updateVlanCount();
            }

            // btnPopulateVlans event listener moved to initializeEventHandlers

            // VLAN interface management (starting with no default interfaces)

            // VPLS management (starting with no default instances)

            function addVpls() {
                const template = document.getElementById('vplsTemplate').cloneNode(true);
                template.style.display = 'block';
                const num = ++vplsCount;
                template.id = `vpls${num}`;

                // Update IDs
                template.querySelector('input[name="vplsName"]').id = `vpls${num}Name`;
                template.querySelector('input[name="vplsBridge"]').id = `vpls${num}Bridge`;
                template.querySelector('input[name="vplsPeer"]').id = `vpls${num}Peer`;
                template.querySelector('input[name="vplsStaticId"]').id = `vpls${num}StaticId`;

                // Update remove button
                template.querySelector('button').onclick = () => {
                    template.remove();
                    vplsCount--;
                };

                document.getElementById('vplsInstances').appendChild(template);
            }

            function updateVplsCount() {
                vplsCount = document.querySelectorAll('#vplsInstances .vpls-item:not(#vplsTemplate)').length;
            }

            // Port configuration management (variable already declared above)

            function addPort(preset = {}) {
                if (portCount >= 12) return null;
                const tpl = document.getElementById('portTemplate').cloneNode(true);
                tpl.style.display = 'block';
                const num = ++portCount;
                tpl.id = `port${num}`;

                // Assign unique IDs
                const selPort = tpl.querySelector('select[name="portName"]');
                const selSpeed = tpl.querySelector('select[name="portSpeed"]');
                const inpComment = tpl.querySelector('input[name="portComment"]');
                const selBridge = tpl.querySelector('select[name="portBridge"]');
                const inpMtu = tpl.querySelector('input[name="portMtu"]');
                const inpL2Mtu = tpl.querySelector('input[name="portL2Mtu"]');

                if (selPort) selPort.id = `port${num}Name`;
                if (selSpeed) selSpeed.id = `port${num}Speed`;
                if (inpComment) inpComment.id = `port${num}Comment`;
                if (selBridge) selBridge.id = `port${num}Bridge`;
                if (inpMtu) inpMtu.id = `port${num}Mtu`;
                if (inpL2Mtu) inpL2Mtu.id = `port${num}L2Mtu`;

                // Populate port options for the new port configuration
                if (selPort) {
                    const targetDevice = document.getElementById('targetDevice').value;
                    const currentDevice = document.getElementById('currentDevice').value;
                    const selectedDevice = targetDevice || currentDevice;

                    if (selectedDevice && DEVICE_CONFIGS[selectedDevice]) {
                        const allPorts = [...DEVICE_CONFIGS[selectedDevice].ports, ...DEVICE_CONFIGS[selectedDevice].sfpPorts];
                        selPort.innerHTML = '';
                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            selPort.appendChild(option);
                        });
                    }
                }

                // Fill values with preset data
                if (selPort) selPort.value = preset.port ?? (selPort.options[0] ? selPort.options[0].value : '');
                if (selSpeed) selSpeed.value = preset.speed ?? '1Gbps';
                if (inpComment) inpComment.value = preset.comment ?? '';
                if (selBridge) selBridge.value = preset.bridge ?? '';
                if (inpMtu) inpMtu.value = preset.mtu ?? '';
                if (inpL2Mtu) inpL2Mtu.value = preset.l2mtu ?? '';

                // Remove handler
                const btn = tpl.querySelector('button');
                if (btn) btn.onclick = () => {
                    tpl.remove();
                    portCount--;
                    document.getElementById('addPortBtn').disabled = portCount >= 12;
                };

                document.getElementById('portConfigs').appendChild(tpl);
                if (portCount === 12) document.getElementById('addPortBtn').disabled = true;
                return tpl;
            }


            function autoPopulateTaranaPorts() {
                // Clear existing Tarana ports first
                document.querySelectorAll('#portConfigs .uplink-item:not(#portTemplate)').forEach(el => {
                    const portSelect = el.querySelector('select[name="portName"]');
                    if (portSelect && ['sfp-sfpplus8', 'sfp-sfpplus9', 'sfp-sfpplus10'].includes(portSelect.value)) {
                        el.remove();
                        portCount--;
                    }
                });

                const taranaPorts = [
                    { port: 'sfp-sfpplus8', comment: 'Tarana Alpha' },
                    { port: 'sfp-sfpplus9', comment: 'Tarana Beta' },
                    { port: 'sfp-sfpplus10', comment: 'Tarana Gamma' }
                ];

                if (document.getElementById('enableTaranaFourthSector')?.checked) {
                    taranaPorts.push({ port: 'sfp-sfpplus6', comment: 'Tarana Sector Delta' });
                }

                taranaPorts.forEach(({ port, comment }) => {
                    addPort({
                        port: port,
                        speed: '10Gbps',
                        comment: comment,
                        mtu: '1500',
                        l2mtu: '1592'
                    });
                });
            }
            function autoPopulateNetonixPorts() {
                // Treat as generic switch uplinks (two ports bridged to lan-bridge), dynamic per device
                function getSwitchPortsForDevice() {
                    const targetDevice = document.getElementById('targetDevice')?.value || 'ccr2004';
                    const dev = DEVICE_CONFIGS[targetDevice] || DEVICE_CONFIGS.ccr2004;
                    if (!dev) return ['sfp-sfpplus1', 'sfp-sfpplus2'];
                    // Prefer first two SFP ports, excluding ether1
                    const sfp = (dev.sfpPorts || []).filter(p => p !== 'ether1');
                    if (sfp.length >= 2) return sfp.slice(0, 2);
                    const ports = (dev.ports || []).filter(p => p !== 'ether1');
                    const combined = [...sfp, ...ports];
                    if (combined.length >= 2) return combined.slice(0, 2);
                    if (combined.length === 1) return [combined[0]];
                    return ['sfp-sfpplus1', 'sfp-sfpplus2'];
                }

                const switchPorts = getSwitchPortsForDevice();

                // Remove any existing entries using these ports (old or new structures)
                document.querySelectorAll('#portConfigs .uplink-item:not(#portUplinkTemplate)').forEach(el => {
                    const newPortSel = el.querySelector('select[name="portUplinkPort"]');
                    const oldPortSel = el.querySelector('select[name="portName"]');
                    const portVal = (newPortSel || oldPortSel)?.value;
                    if (portVal && switchPorts.includes(portVal)) {
                        el.remove();
                    }
                });

                switchPorts.forEach((port, idx) => {
                    addPortUplink({
                        port,
                        type: 'switch',
                        bridge: 'lan-bridge',
                        speed: '1Gbps',
                        comment: `Switch Uplink #${idx + 1}`
                    });
                });
            }

            // Event handlers will be set up in DOMContentLoaded

            function addCustomer() {
                const template = document.getElementById('customerTemplate').cloneNode(true);
                template.style.display = 'block';
                const num = ++customerCount;
                template.id = `customer${num}`;

                // Update IDs
                template.querySelector('input[name="customerName"]').id = `customer${num}Name`;
                template.querySelector('input[name="customerRange"]').id = `customer${num}Range`;
                template.querySelector('input[name="customerComment"]').id = `customer${num}Comment`;

                // Update remove button
                template.querySelector('button').onclick = () => {
                    template.remove();
                    customerCount--;
                };

                document.getElementById('staticCustomers').appendChild(template);
            }

            function updateCustomerCount() {
                customerCount = document.querySelectorAll('#staticCustomers .customer-item:not(#customerTemplate)').length;
            }

            // Device selection functionality will be set up in DOMContentLoaded

            function updatePortLabels() {
                // Update uplink port labels based on selected device and port
                const targetDevice = document.getElementById('targetDevice').value;
                const deviceConfig = DEVICE_CONFIGS[targetDevice];
                const uplink1NewPort = document.getElementById('uplink1NewPort');
                const uplink1NewPortLabel = document.getElementById('uplink1NewPortLabel');

                if (uplink1NewPort && uplink1NewPortLabel && deviceConfig) {
                    const selectedPort = uplink1NewPort.value;
                    let portType = '';

                    if (selectedPort.includes('sfp-sfpplus')) {
                        portType = 'SFP+';
                    } else if (selectedPort.includes('sfp28')) {
                        portType = 'SFP28';
                    } else if (selectedPort.includes('qsfp28')) {
                        portType = 'QSFP28';
                    } else if (selectedPort.includes('ether')) {
                        portType = 'Ethernet';
                    } else if (selectedPort.includes('sfp')) {
                        portType = 'SFP';
                    }

                    uplink1NewPortLabel.textContent = `New Port (${deviceConfig.name}, ${portType}):`;
                }
            }

            function updateUplinksDescription() {
                const targetDevice = document.getElementById('targetDevice').value || 'ccr2004';
                const deviceConfig = DEVICE_CONFIGS[targetDevice] || DEVICE_CONFIGS.ccr2004;
                const descriptionElement = document.getElementById('uplinksDescription');

                if (descriptionElement) {
                    let portDescription = '';

                    // Get the appropriate port naming based on device
                    if (targetDevice === 'rb1009' || targetDevice === 'rb2011') {
                        portDescription = 'ether2 onwards';
                    } else if (targetDevice === 'ccr1036') {
                        portDescription = 'ether1 onwards';
                    } else if (targetDevice === 'rb5009') {
                        portDescription = 'ether2 onwards';
                    } else if (targetDevice === 'ccr2004') {
                        portDescription = 'sfp-sfpplus4 downwards';
                    } else if (targetDevice === 'ccr2216') {
                        portDescription = 'sfp28-1 onwards';
                    } else {
                        portDescription = 'available ports';
                    }

                    descriptionElement.textContent = `Up to 4; generates ethernet sets, /ip address, OSPF templates (ptp type). Uses ${portDescription}.`;
                }
            }

            function updateDevicePorts() {
                const targetDevice = document.getElementById('targetDevice').value;
                const currentDevice = document.getElementById('currentDevice').value;

                // Use target device if selected, otherwise use current device
                const selectedDevice = targetDevice || currentDevice;

                if (selectedDevice && DEVICE_CONFIGS[selectedDevice]) {
                    const deviceConfig = DEVICE_CONFIGS[selectedDevice];
                    const allPorts = [...deviceConfig.ports, ...deviceConfig.sfpPorts];

                    // Update uplink port options
                    const uplinkSelects = document.querySelectorAll('#uplinks select[id*="NewPort"]');
                    uplinkSelects.forEach(select => {
                        const currentValue = select.value;
                        select.innerHTML = '';

                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            select.appendChild(option);
                        });

                        // Restore previous value if it exists in new options
                        if (allPorts.includes(currentValue)) {
                            select.value = currentValue;
                        }
                    });

                    // Update uplink template
                    const templateSelect = document.getElementById('uplinkTemplate').querySelector('select');
                    templateSelect.innerHTML = '';
                    allPorts.forEach(port => {
                        const option = document.createElement('option');
                        option.value = port;
                        option.textContent = port;
                        templateSelect.appendChild(option);
                    });

                    // Update port configuration dropdowns
                    const portConfigSelects = document.querySelectorAll('#portConfigs select[name="portName"]');
                    portConfigSelects.forEach(select => {
                        const currentValue = select.value;
                        select.innerHTML = '';

                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            select.appendChild(option);
                        });

                        // Restore previous value if it exists in new options
                        if (allPorts.includes(currentValue)) {
                            select.value = currentValue;
                        }
                    });
                    // Populate Tarana port selects so all device ports are available
                    const taranaSelectIds = ['tower_tarana_alpha', 'tower_tarana_beta', 'tower_tarana_gamma', 'tower_tarana_delta'];
                    taranaSelectIds.forEach(id => {
                        const sel = document.getElementById(id);
                        if (!sel) return;
                        const prev = sel.value;
                        sel.innerHTML = '';
                        const noneOption = document.createElement('option');
                        if (id === 'tower_tarana_delta') {
                            noneOption.value = '';
                            noneOption.textContent = 'None';
                            sel.appendChild(noneOption);
                        }
                        allPorts.forEach(p => {
                            const opt = document.createElement('option');
                            opt.value = p;
                            opt.textContent = p;
                            sel.appendChild(opt);
                        });
                        if (allPorts.includes(prev)) sel.value = prev;
                    });

                    // Update port configuration template
                    const portTemplateSelect = document.getElementById('port2Name');
                    if (portTemplateSelect) {
                        portTemplateSelect.innerHTML = '';
                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            portTemplateSelect.appendChild(option);
                        });
                    }

                    // Update VLAN parent interface dropdowns
                    const vlanParentSelects = document.querySelectorAll('#vlanInterfaces select[name="vlanParent"]');
                    vlanParentSelects.forEach(select => {
                        const currentValue = select.value;
                        select.innerHTML = '';

                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            select.appendChild(option);
                        });

                        // Restore previous value if it exists in new options
                        if (allPorts.includes(currentValue)) {
                            select.value = currentValue;
                        }
                    });

                    // Update VLAN parent interface template
                    const vlanTemplateSelect = document.getElementById('vlan2Parent');
                    if (vlanTemplateSelect) {
                        vlanTemplateSelect.innerHTML = '';
                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            vlanTemplateSelect.appendChild(option);
                        });
                    }

                    // Update max uplinks
                    const maxUplinks = deviceConfig.maxUplinks;
                    document.getElementById('addUplinkBtn').disabled = uplinkCount >= maxUplinks;

                    // Update port labels
                    updatePortLabels();

                    // Update uplinks description
                    updateUplinksDescription();

                    // Update system identity if site name is already filled
                    const siteName = document.getElementById('siteName')?.value;
                    const systemName = document.getElementById('systemName');
                    if (siteName && systemName) {
                        systemName.value = `RTR-${deviceConfig.name}-1.${siteName}`;
                    }
                }
            }

            // Uplinks dynamic (variable already declared above)

            function addUplink() {
                const targetDevice = document.getElementById('targetDevice').value;
                const currentDevice = document.getElementById('currentDevice').value;
                const selectedDevice = targetDevice || currentDevice;
                const maxUplinks = selectedDevice && DEVICE_CONFIGS[selectedDevice] ? DEVICE_CONFIGS[selectedDevice].maxUplinks : 4;

                if (uplinkCount < maxUplinks) {
                    const template = document.getElementById('uplinkTemplate').cloneNode(true);
                    template.style.display = 'block';
                    const num = ++uplinkCount;
                    template.id = `uplink${num}`;
                    template.querySelector('select').id = `uplink${num}NewPort`;
                    template.querySelectorAll('input')[0].id = `uplink${num}Ip`;
                    template.querySelectorAll('input')[1].id = `uplink${num}Comment`;
                    template.querySelectorAll('input')[2].id = `uplink${num}Cost`;
                    template.querySelector('button').onclick = () => {
                        template.remove();
                        uplinkCount--;
                        document.getElementById('addUplinkBtn').disabled = uplinkCount >= maxUplinks;
                    };
                    document.getElementById('uplinks').appendChild(template);

                    // Populate port options for the new uplink
                    const newPortSelect = template.querySelector('select[id*="NewPort"]');
                    if (newPortSelect && selectedDevice && DEVICE_CONFIGS[selectedDevice]) {
                        const allPorts = [...DEVICE_CONFIGS[selectedDevice].ports, ...DEVICE_CONFIGS[selectedDevice].sfpPorts];
                        newPortSelect.innerHTML = '';
                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            newPortSelect.appendChild(option);
                        });
                    }

                    if (uplinkCount === maxUplinks) document.getElementById('addUplinkBtn').disabled = true;
                }
            }

            // Handle Configuration Type Change - Auto-show/hide sections
            function handleConfigTypeChange() {
                const configType = document.getElementById('configType').value;
                const vplsSection = document.querySelector('.vpls-section');
                const mplsSection = document.querySelector('.mpls-section');

                // Show/hide VPLS and MPLS sections based on config type
                if (configType === 'out-of-state') {
                    if (vplsSection) vplsSection.style.display = 'block';
                    if (mplsSection) mplsSection.style.display = 'block';
                } else {
                    if (vplsSection) vplsSection.style.display = 'none';
                    if (mplsSection) mplsSection.style.display = 'none';
                }
            }

            // Handle Port Type Change - Show/hide IP vs Bridge fields
            function handlePortTypeChange(selectElement) {
                const portItem = selectElement.closest('.uplink-item');
                if (!portItem) return;

                const portType = selectElement.value;
                const ipContainer = portItem.querySelector('.portUplinkIpContainer') || portItem.querySelector('[id*="IpContainer"]');
                const bridgeContainer = portItem.querySelector('.portUplinkBridgeContainer') || portItem.querySelector('[id*="BridgeContainer"]');
                const costContainer = portItem.querySelector('.portUplinkCostContainer') || portItem.querySelector('[id*="CostContainer"]');

                if (portType === 'routed') {
                    // Show IP and OSPF Cost, hide Bridge
                    if (ipContainer) ipContainer.style.display = 'block';
                    if (bridgeContainer) bridgeContainer.style.display = 'none';
                    if (costContainer) costContainer.style.display = 'block';
                } else if (portType === 'bridge') {
                    // Show Bridge, hide IP and OSPF Cost
                    if (ipContainer) ipContainer.style.display = 'none';
                    if (bridgeContainer) bridgeContainer.style.display = 'block';
                    if (costContainer) costContainer.style.display = 'none';
                } else if (portType === 'switch') {
                    // Hide all (switch ports don't need IP, bridge, or OSPF)
                    if (ipContainer) ipContainer.style.display = 'none';
                    if (bridgeContainer) bridgeContainer.style.display = 'none';
                    if (costContainer) costContainer.style.display = 'none';
                }
            }

            // Update Port/Uplink Count
            function updatePortUplinkCount() {
                const count = document.querySelectorAll('#portConfigs .uplink-item:not(#portUplinkTemplate)').length;
                console.log('Port/Uplink count:', count);
            }

            // Add Port/Uplink Button Handler
            function addPortUplink(preset = {}) {
                const template = document.getElementById('portUplinkTemplate');
                if (!template) return;

                const newItem = template.cloneNode(true);
                newItem.id = '';
                newItem.style.display = 'block';

                // Update select options based on device
                const portSelect = newItem.querySelector('select[name="portUplinkPort"]');
                if (portSelect) {
                    const targetDevice = document.getElementById('targetDevice').value;
                    if (targetDevice && DEVICE_CONFIGS[targetDevice]) {
                        const deviceConfig = DEVICE_CONFIGS[targetDevice];
                        const allPorts = [...deviceConfig.ports, ...deviceConfig.sfpPorts];
                        portSelect.innerHTML = '';
                        allPorts.forEach(port => {
                            const option = document.createElement('option');
                            option.value = port;
                            option.textContent = port;
                            portSelect.appendChild(option);
                        });
                        // Apply preset port if provided and valid
                        if (preset.port && allPorts.includes(preset.port)) {
                            portSelect.value = preset.port;
                        }
                    }
                }

                // Set up event handler for type change
                const typeSelect = newItem.querySelector('select[name="portUplinkType"]');
                if (typeSelect) {
                    // Apply preset type before wiring handler
                    if (preset.type) {
                        typeSelect.value = preset.type;
                    }
                    typeSelect.onchange = function () { handlePortTypeChange(this); };
                    // Ensure correct initial visibility
                    handlePortTypeChange(typeSelect);
                }

                // Apply other preset fields
                if (preset.comment) {
                    const commentInput = newItem.querySelector('input[name="portUplinkComment"]');
                    if (commentInput) commentInput.value = preset.comment;
                }
                if (preset.speed) {
                    const speedSelect = newItem.querySelector('select[name="portUplinkSpeed"]');
                    if (speedSelect) speedSelect.value = preset.speed;
                }
                if (preset.bridge) {
                    const bridgeSelect = newItem.querySelector('select[name="portUplinkBridge"]');
                    if (bridgeSelect) bridgeSelect.value = preset.bridge;
                }
                if (preset.ip) {
                    const ipInput = newItem.querySelector('input[name="portUplinkIp"]');
                    if (ipInput) ipInput.value = preset.ip;
                }

                document.getElementById('portConfigs').appendChild(newItem);
                updatePortUplinkCount();
            }

            function updateUplinkCount() {
                uplinkCount = document.querySelectorAll('.uplink-item:not(#uplinkTemplate)').length;
                document.getElementById('addUplinkBtn').disabled = uplinkCount >= 4;
            }

            // Navigation helper function (GLOBAL) - Define BEFORE initializeEventHandlers
            window.navigateToTab = async function (tabId) {
                const contentPanes = document.querySelectorAll('.content-pane');
                const navItems = document.querySelectorAll('.nav-item');
                const dropdownLinks = document.querySelectorAll('.dropdown-menu a');

                // Hide all panes
                contentPanes.forEach(p => p.classList.remove('active'));

                // Remove active class from all nav items
                navItems.forEach(item => item.classList.remove('active'));
                dropdownLinks.forEach(link => link.classList.remove('active'));

                // Special handling for admin panel - verify access first
                if (tabId === 'admin-panel') {
                    const isAdmin = await checkAdminAccess();
                    if (!isAdmin) {
                        alert('Admin access required. You do not have permission to access this panel.');
                        tabId = 'home';
                    }
                }

                // Show the target pane
                const targetPane = document.getElementById(tabId + '-pane');
                if (targetPane) {
                    targetPane.classList.add('active');
                }

                // Highlight the active nav item
                const activeNavItem = document.querySelector(`.nav-item[data-tab="${tabId}"]`);
                if (activeNavItem) {
                    activeNavItem.classList.add('active');
                } else {
                    // Check if it's in a dropdown
                    const activeDropdownLink = document.querySelector(`.dropdown-menu a[data-tab="${tabId}"]`);
                    if (activeDropdownLink) {
                        activeDropdownLink.classList.add('active');
                        // Highlight the dropdown button (Mikrotik Config) when a sub-tab is selected
                        const dropdownContainer = activeDropdownLink.closest('.nav-item.dropdown');
                        if (dropdownContainer) {
                            // Add active class to the dropdown button to show orange highlight
                            dropdownContainer.classList.add('active');
                        }
                    }
                }

                // Load data for specific tabs
                if (tabId === 'admin-panel') {
                    if (typeof loadAdminFeedback === 'function') {
                        setTimeout(() => loadAdminFeedback(), 100);
                    } else {
                        console.warn('[ADMIN] loadAdminFeedback function not found');
                    }
                } else if (tabId === 'completed-configs') {
                    if (typeof loadCompletedConfigs === 'function') {
                        loadCompletedConfigs();
                    }
                } else if (tabId === 'log-history') {
                    // Load log history when tab is opened
                    if (typeof window.loadLogHistory === 'function') {
                        setTimeout(() => window.loadLogHistory(), 100);
                    }
                } else if (tabId === 'home') {
                    if (typeof updateRecentActivity === 'function') {
                        updateRecentActivity();
                    }
                    if (typeof updateDashboardMetrics === 'function') {
                        updateDashboardMetrics();
                    }
                }
            }

            // Get or prompt for username
            function getUsername() {
                // Use authenticated user if available
                if (window.currentUser) {
                    if (window.currentUser.displayName) return window.currentUser.displayName;
                    const email = (typeof window.currentUser.email === 'string') ? window.currentUser.email : '';
                    if (email && email.includes('@')) return email.split('@')[0];
                    if (email) return email;
                    if (window.currentUser.username) return window.currentUser.username;
                    if (window.currentUser.name) return window.currentUser.name;
                    return 'Anonymous';
                }

                // Fallback to stored username
                let username = localStorage.getItem('nocUsername');
                if (!username) {
                    username = prompt('Enter your name for activity tracking:');
                    if (username && username.trim()) {
                        localStorage.setItem('nocUsername', username.trim());
                    } else {
                        username = 'Anonymous';
                    }
                }
                return username;
            }

            function getUserEmail() {
                // Use authenticated user email if available
                if (window.currentUser) {
                    return window.currentUser.email;
                }
                return null;
            }

            function getAuthToken() {
                return localStorage.getItem('auth_token');
            }

            // LocalStorage helper functions for config history
            window.saveConfigToHistory = function (configData) {
                const username = getUsername();
                let history = JSON.parse(localStorage.getItem('configHistory') || '[]');
                const entry = {
                    id: Date.now(),
                    timestamp: getCSTTimestamp(),
                    type: configData.type || 'unknown',
                    device: configData.device || 'N/A',
                    siteName: configData.siteName || 'N/A',
                    routeros: configData.routeros || 'N/A',
                    username: username,
                    success: configData.success !== false  // Support explicit success/failure tracking
                };
                history.unshift(entry); // Add to beginning
                if (history.length > 100) history = history.slice(0, 100); // Keep last 100
                localStorage.setItem('configHistory', JSON.stringify(history));
                console.log('[HISTORY] Saved to history:', entry);

                // Immediate metrics update
                setTimeout(() => {
                    updateDashboardMetrics();
                    updateRecentActivity();
                }, 100);

                // Send to backend for live activity tracking
                sendActivityToBackend(entry);
            };

            // FTTH BNG generator helper (quick UI flow)
            window.generateFtthBng = async function () {
                const loopback = prompt('Loopback IP (/32) - e.g., 10.13.100.5/32');
                const cpe = prompt('CPE network (/22) - e.g., 192.0.2.0/22');
                const cgnat = prompt('CGNAT network (/22) - e.g., 100.64.0.0/22');
                const olt = prompt('OLT network (/29) - e.g., 198.51.100.8/29');
                const olt_port = prompt('OLT port (default sfp-sfpplus1)', 'sfp-sfpplus1');
                const identity = prompt('System identity (optional)', 'RTR-FTTH-AUTO');
                if (!loopback || !cpe || !cgnat || !olt) {
                    alert('Loopback, CPE, CGNAT and OLT CIDRs are required');
                    return;
                }
                const payload = {
                    device: (document.getElementById('deviceSelect') || {}).value || 'ccr2004',
                    target_version: (document.getElementById('targetVersion') || {}).value || '7.19.4',
                    loopback_ip: loopback,
                    cpe_cidr: cpe,
                    cgnat_cidr: cgnat,
                    olt_cidr: olt,
                    olt_port: olt_port,
                    identity: identity
                };
                try {
                    const r = await fetch('/api/gen-ftth-bng', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
                    const data = await r.json();
                    if (!data.success) {
                        alert('FTTH generator error: ' + (data.error || 'unknown'));
                        return;
                    }
                    const cfg = data.config || '';
                    document.getElementById('upgradeOutput').value = cfg;
                    document.getElementById('upgradeOutputSection').style.display = 'block';
                    saveConfigToHistory({ type: 'ftth', device: payload.device, siteName: identity, routeros: payload.target_version, success: true });
                    alert('FTTH BNG configuration generated and placed in Upgrade Output');
                } catch (e) {
                    console.error('FTTH generation failed', e);
                    alert('FTTH generation failed: ' + e.message);
                }
            };

            // Deduplication for activity logging (prevent duplicates within 5 seconds)
            const recentActivityLogs = new Map();
            const ACTIVITY_DEDUP_WINDOW = 5000; // 5 seconds

            // Send activity to backend for live tracking
            window.sendActivityToBackend = function (activity) {
                // Create a unique key for this activity (without timestamp to catch true duplicates)
                const activityKey = `${activity.type}-${activity.device}-${activity.siteName}-${activity.routeros}`;
                const now = Date.now();

                // Check if we've logged this exact activity recently
                if (recentActivityLogs.has(activityKey)) {
                    const lastLogTime = recentActivityLogs.get(activityKey);
                    if (now - lastLogTime < ACTIVITY_DEDUP_WINDOW) {
                        console.log('[ACTIVITY]  Skipping duplicate activity log (logged', Math.round((now - lastLogTime) / 1000), 'seconds ago)');
                        return;
                    }
                }

                // Mark this activity as logged
                recentActivityLogs.set(activityKey, now);

                // Clean up old entries (keep only last 100)
                if (recentActivityLogs.size > 100) {
                    const oldestKey = recentActivityLogs.keys().next().value;
                    recentActivityLogs.delete(oldestKey);
                }

                console.log('[ACTIVITY] Sending activity to backend:', activity);

                const token = getAuthToken();
                const username = activity.username || getUsername();

                const payload = {
                    username: username,
                    type: activity.type || 'new-config',
                    device: activity.device || '',
                    siteName: activity.siteName || '',
                    routeros: activity.routeros || '',
                    success: activity.success !== false
                };

                // Include token if available for authenticated tracking
                if (token) {
                    payload.token = token;
                }

                // Use AI_API_BASE if defined, otherwise construct it
                const apiBase = resolveApiBase();

                fetch(`${apiBase}/log-activity`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                }).then(response => {
                    if (response.ok) {
                        console.log('[ACTIVITY]  Activity logged to backend successfully');
                        // Immediately refresh to show the new activity
                        setTimeout(() => {
                            updateDashboardMetrics();
                            updateRecentActivity();
                        }, 500); // Small delay to ensure DB write completes
                    } else {
                        console.log('[ACTIVITY]  Backend returned error:', response.status);
                    }
                }).catch(err => console.log('[ACTIVITY]  Backend unavailable:', err));
            }

            window.updateDashboardMetrics = async function () {
                try {
                    // Use AI_API_BASE if defined, otherwise construct it
                    const apiBase = resolveApiBase();

                    // Fetch ALL activities for metrics (not just last 24 hours)
                    const response = await fetch(`${apiBase}/get-activity?all=true&limit=10000`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.activities) {
                            const allActivities = data.activities;
                            window.__ALL_ACTIVITIES = allActivities;
                            window.__ALL_ACTIVITIES_FETCHED_AT = Date.now();
                            const now = new Date();
                            const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());

                            // Calculate TODAY's configs (since midnight) - resets every 24 hours
                            const todayCount = allActivities.filter(entry => {
                                const entryDate = new Date(entry.timestamp);
                                return entryDate >= todayStart;
                            }).length;

                            // Count ALL migrations ever (not just today)
                            const migrationCount = allActivities.filter(entry =>
                                entry.type === 'migration' || entry.type === 'upgrade'
                            ).length;

                            // Calculate ACTUAL success rate from ALL activities
                            const successCount = allActivities.filter(e => e.success === true || e.success === 1).length;
                            const failCount = allActivities.filter(e => e.success === false || e.success === 0).length;
                            const nonAviatActivities = allActivities.filter(entry => entry.type !== 'aviat-upgrade');
                            const totalCount = nonAviatActivities.length;
                            const successCountFiltered = nonAviatActivities.filter(e => e.success === true).length;
                            const successRate = totalCount > 0 ?
                                Math.round((successCountFiltered / totalCount) * 100) : 100;
                            const firmwareBaseline = 42;
                            const firmwareUpgradeCount = firmwareBaseline + allActivities.filter(entry =>
                                entry.type === 'aviat-upgrade' && (entry.success === true || entry.success === 1)
                            ).length;

                            // Update UI elements
                            const totalEl = document.getElementById('metricTotalConfigs');
                            const migrationsEl = document.getElementById('metricMigrations');
                            const firmwareEl = document.getElementById('metricFirmwareUpgrades');
                            const successEl = document.getElementById('metricSuccess');
                            const todayEl = document.getElementById('metricToday');

                            // Total configs = ALL configs ever generated (migrations + new configs) - NEVER RESETS
                            if (totalEl) totalEl.textContent = totalCount;
                            if (migrationsEl) migrationsEl.textContent = migrationCount;
                            if (firmwareEl) firmwareEl.textContent = firmwareUpgradeCount;
                            if (successEl) successEl.textContent = successRate + '%';
                            if (todayEl) todayEl.textContent = nonAviatActivities.filter(entry => {
                                const entryDate = new Date(entry.timestamp);
                                return entryDate >= todayStart;
                            }).length;

                            console.log(`[METRICS]  Backend: Total=${totalCount} (ALL TIME), Today=${nonAviatActivities.filter(entry => {
                                const entryDate = new Date(entry.timestamp);
                                return entryDate >= todayStart;
                            }).length}, Success=${successCountFiltered}/${totalCount} (${successRate}%), Migrations=${migrationCount}, FirmwareUpgrades=${firmwareUpgradeCount}`);
                            return;
                        } else {
                            console.log('[METRICS]  Backend returned invalid data format, falling back to localStorage');
                        }
                    } else {
                        console.log(`[METRICS]  Backend returned status ${response.status}, falling back to localStorage`);
                    }
                } catch (err) {
                    console.log('[METRICS]  Backend unavailable:', err.message, '- using localStorage');
                }

                // Fallback to localStorage if backend unavailable
                const history = JSON.parse(localStorage.getItem('configHistory') || '[]');
                window.__ALL_ACTIVITIES = history;
                window.__ALL_ACTIVITIES_FETCHED_AT = Date.now();
                const now = new Date();
                const todayStart = new Date(now.getFullYear(), now.getMonth(), now.getDate());

                // Calculate TODAY's configs (since midnight) - resets every 24 hours
                const nonAviatHistory = history.filter(entry => entry.type !== 'aviat-upgrade');
                const todayCount = nonAviatHistory.filter(entry => {
                    const entryDate = new Date(entry.timestamp);
                    return entryDate >= todayStart;
                }).length;

                // Count ALL migrations ever (not just today)
                const migrationCount = history.filter(entry =>
                    entry.type === 'migration' || entry.type === 'upgrade'
                ).length;

                // Calculate success rate from ALL activities
                const successCount = nonAviatHistory.filter(e => e.success === true).length;
                const totalCount = nonAviatHistory.length;
                const successRate = totalCount > 0 ?
                    Math.round((successCount / totalCount) * 100) : 100;
                const firmwareBaseline = 42;
                const firmwareUpgradeCount = firmwareBaseline + history.filter(entry =>
                    entry.type === 'aviat-upgrade' && entry.success === true
                ).length;

                // Update UI elements
                const totalEl = document.getElementById('metricTotalConfigs');
                const migrationsEl = document.getElementById('metricMigrations');
                const firmwareEl = document.getElementById('metricFirmwareUpgrades');
                const successEl = document.getElementById('metricSuccess');
                const todayEl = document.getElementById('metricToday');

                // Total configs = ALL configs ever generated (migrations + new configs) - NEVER RESETS
                if (totalEl) totalEl.textContent = totalCount;
                if (migrationsEl) migrationsEl.textContent = migrationCount;
                if (firmwareEl) firmwareEl.textContent = firmwareUpgradeCount;
                if (successEl) successEl.textContent = successRate + '%';
                if (todayEl) todayEl.textContent = todayCount;

                console.log(`[METRICS]  localStorage: Total=${totalCount} (ALL TIME), Today=${todayCount}, Success=${successCount}/${totalCount} (${successRate}%), Migrations=${migrationCount}, FirmwareUpgrades=${firmwareUpgradeCount}`);
            }

            // Navigate to activity details when clicking on recent activity items
            window.navigateToActivity = function (type, id) {
                console.log(`[NAV] Navigating to activity: type=${type}, id=${id}`);

                if (type === 'migration' || type === 'upgrade') {
                    // Navigate to Tower tab in "Upgrade Existing" mode
                    window.navigateToTab?.('tower');
                    setTimeout(() => { if (typeof switchMode === 'function') switchMode('upgrade'); }, 120);

                    // Try to fetch and display the migrated config from the activity log
                    fetch(`${resolveApiBase()}/get-activity`)
                        .then(response => response.json())
                        .then(data => {
                            if (data && data.activities) {
                                const activity = data.activities.find(a => a.id === id);
                                if (activity && activity.config_content) {
                                    // Display the migrated config in the upgrade output
                                    const outputSection = document.getElementById('upgradeOutputSection');
                                    const outputTextarea = document.getElementById('upgradeOutput');
                                    if (outputSection && outputTextarea) {
                                        outputTextarea.value = activity.config_content;
                                        outputSection.style.display = 'block';
                                        // Scroll to the output
                                        outputSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                                    }
                                }
                            }
                        })
                        .catch(err => {
                            console.error('[NAV] Error fetching migration config:', err);
                            // If backend is unavailable, just navigate to the tab
                            alert('Migration completed. Config may have been downloaded already.');
                        });
                } else if (type === 'aviat-upgrade') {
                    window.navigateToTab?.('aviat-backhaul');
                } else {
                    // Navigate to saved configs tab and display the config
                    window.navigateToTab?.('completed-configs');

                    // Fetch and display the config
                    if (id) {
                        viewCompletedConfig(id);
                    }
                }
            };

            window.updateRecentActivity = function () {
                // First try to fetch live activity from backend (last 24 hours from all tabs)
                fetchLiveActivity().then(liveActivities => {
                    const listElement = document.getElementById('recentActivityList');

                    // Get ongoing activities HTML first
                    const ongoingHTML = getOngoingActivitiesHTML();

                    if (liveActivities && liveActivities.length > 0) {
                        // Home monthly overview should use ALL history when available.
                        const allForMonthly = (Array.isArray(window.__ALL_ACTIVITIES) && window.__ALL_ACTIVITIES.length > 0)
                            ? window.__ALL_ACTIVITIES
                            : liveActivities;
                        renderHomeMonthlyTracker(allForMonthly);
                        // Show last 24 hours of activity from all tabs
                        const recentItems = liveActivities.slice(0, 10);
                        const completedHTML = recentItems.map(entry => {
                            const date = new Date(entry.timestamp);
                            const timeStr = formatCSTTimestamp(entry.timestamp);
                            const statusText = (entry.success === false) ? 'FAILED' : 'SUCCESS';
                            const statusColor = (entry.success === false) ? '#dc3545' : '#4CAF50';

                            // Determine icon based on activity type
                            let icon = '';
                            let activityLabel = 'Config Generated';
                            if (entry.type === 'migration' || entry.type === 'upgrade') {
                                icon = '';
                                activityLabel = 'Migration';
                            } else if (entry.type === 'switch-config') {
                                icon = '';
                                activityLabel = 'MikroTik Switch Config';
                            } else if (entry.type === '6ghz-switch-config') {
                                icon = '';
                                activityLabel = '6GHz Switch Config';
                            } else if (entry.type === 'tarana-config') {
                                icon = '';
                                activityLabel = 'Tarana Sectors Config';
                            } else if (entry.type === 'enterprise-feeding-config') {
                                icon = '';
                                activityLabel = 'Enterprise Feeding Config';
                            } else if (entry.type === 'enterprise-feeding-outstate-config') {
                                icon = '';
                                activityLabel = 'Enterprise Feeding Out-of-State Config';
                            } else if (entry.type === 'aviat-upgrade') {
                                icon = '';
                                activityLabel = 'Aviat Backhaul Upgrade';
                            } else if (entry.type === 'tower-config') {
                                icon = '';
                                activityLabel = 'Tower Config';
                            } else if (entry.type === 'enterprise-config' || entry.type === 'enterprise-Non-MPLS' || entry.type === 'enterprise-non-mpls') {
                                icon = '';
                                activityLabel = 'Enterprise Config';
                            } else if (entry.type === 'mpls-enterprise-config' || entry.type === 'new-config') {
                                // Check siteName to determine if it's MPLS Enterprise
                                if (entry.siteName && entry.siteName.includes('MPLS Enterprise')) {
                                    icon = '';
                                    activityLabel = 'MPLS Enterprise Config';
                                } else {
                                    icon = '';
                                    activityLabel = 'Config Generated';
                                }
                            }

                            const username = formatUsernameDisplay(entry.username || 'Unknown User');
                            return `
                                <div class="activity-item" style="cursor: pointer;" onclick="navigateToActivity('${entry.type}', ${entry.id})">
                                    <div class="title">${icon} ${activityLabel} - ${entry.siteName} <span style="margin-left: 10px; font-size: 11px; padding: 2px 8px; border-radius: 999px; background: rgba(255,255,255,0.06); color: ${statusColor}; border: 1px solid rgba(255,255,255,0.12);">${statusText}</span></div>
                                    <div class="details">
                                        <span class="user-info">${username}</span> | 
                                        Device: ${entry.device} | Firmware: ${entry.routeros}
                                    </div>
                                    <div class="time">${timeStr} <span style="color: #4CAF50; margin-left: 10px;"> Click to view</span></div>
                                </div>
                            `;
                        }).join('');
                        listElement.innerHTML = ongoingHTML + completedHTML;
                    } else {
                        // Fallback to local storage
                        const history = JSON.parse(localStorage.getItem('configHistory') || '[]');
                        renderHomeMonthlyTracker(history.map(h => ({ ...h, success: h?.success !== false })));
                        if (history.length === 0 && !ongoingHTML) {
                            listElement.innerHTML = `
                                <div class="empty-state">
                                    <div class="empty-state-icon"></div>
                                    <p>No recent activity yet. Generate your first config to get started!</p>
                                </div>
                            `;
                        } else {
                            const recentItems = history.slice(0, 10);
                            const completedHTML = recentItems.map(entry => {
                                const date = new Date(entry.timestamp);
                                const timeStr = formatCSTTimestamp(entry.timestamp);
                                const icon = entry.type === 'migration' ? '' : '';
                                const username = formatUsernameDisplay(entry.username || getUsername());
                                return `
                                    <div class="activity-item" style="cursor: pointer;" onclick="navigateToActivity('${entry.type}', ${entry.id})">
                                        <div class="title">${icon} ${entry.type === 'migration' ? 'Migration' : 'Config Generated'} - ${entry.siteName}</div>
                                        <div class="details">
                                            <span class="user-info">${username}</span> | 
                                            Device: ${entry.device} | Firmware: ${entry.routeros}
                                        </div>
                                        <div class="time">${timeStr} <span style="color: #4CAF50; margin-left: 10px;"> Click to view</span></div>
                                    </div>
                                `;
                            }).join('');
                            listElement.innerHTML = ongoingHTML + completedHTML;
                        }
                    }
                }).catch(err => {
                    console.log('Live activity unavailable, using local history');
                    // Fallback logic already in the promise above
                });
            }

            // Fetch live activity from backend (last 24 hours from all tabs)
            window.fetchLiveActivity = async function () {
                try {
                    // Use AI_API_BASE if defined, otherwise construct it
                    const apiBase = resolveApiBase();

                    // Fetch last 24 hours of activity (all=false means last 24 hours only)
                    const response = await fetch(`${apiBase}/get-activity?limit=50&all=false`);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.success && data.activities) {
                            console.log(`[ACTIVITY] Fetched ${data.activities.length} activities from last 24 hours`);
                            return data.activities;
                        }
                    }
                } catch (err) {
                    console.log('[ACTIVITY] Could not fetch from backend:', err);
                }
                return null;
            }

            // Ongoing activities tracker (key = unique ID, value = description)
            const ongoingActivities = {};

            window.showOngoingActivity = function (description, id) {
                ongoingActivities[id] = {
                    description: description,
                    timestamp: getCSTTimestamp(),
                    username: getUsername()
                };
                console.log('[ONGOING]', description);
                updateRecentActivity(); // Immediately update to show ongoing
            };

            window.clearOngoingActivity = function (id) {
                delete ongoingActivities[id];
                console.log('[ONGOING] Cleared:', id);
            };

            window.getOngoingActivitiesHTML = function () {
                const ongoing = Object.values(ongoingActivities);
                if (ongoing.length === 0) return '';

                return ongoing.map(activity => {
                    const time = formatCSTTimestamp(activity.timestamp);
                    return `
                        <div class="activity-item" style="background: #1a3a1a; border-left: 3px solid #4CAF50;">
                            <div class="title"> ONGOING: ${activity.description}</div>
                            <div class="details">
                                <span class="user-info">${formatUsernameDisplay(activity.username)}</span> | 
                                Started: ${time}
                            </div>
                        </div>
                    `;
                }).join('');
            }

            // Poll for live activity updates and metrics every 30 seconds
            setInterval(() => {
                const homePane = document.getElementById('home-pane');
                if (homePane && homePane.classList.contains('active')) {
                    console.log('[DASHBOARD] Auto-refreshing activity feed and metrics...');
                    updateRecentActivity();
                    updateDashboardMetrics();
                    // Keep the homepage "Updated" timestamp live
                    updateHomeStatusStrip(window.__LAST_BACKEND_HEALTH, window.BACKEND_ONLINE);
                }
            }, 30000); // 30 second refresh interval

            // ========================================
            // GLOBAL MODAL FUNCTIONS (Must be defined early)
            // ========================================

            // Settings Modal Functions
            window.openSettingsModal = function () {
                const modal = document.getElementById('settingsModal');
                modal.classList.add('show');

                // Load current settings
                const currentTheme = localStorage.getItem('theme') || 'dark';
                const currentFontSize = localStorage.getItem('fontSize') || 'comfortable';

                // Set theme + font size
                const themeSelect = document.getElementById('themeSelect');
                if (themeSelect) {
                    themeSelect.value = currentTheme;
                    if (themeSelect.value !== currentTheme) themeSelect.value = 'dark';
                }
                const fontRadio = document.querySelector(`input[name="fontSize"][value="${currentFontSize}"]`);
                if (fontRadio) fontRadio.checked = true;

                // Update visual selection
                updateSettingsSelection();

                // Load admin reset section (if admin)
                if (typeof loadAdminResetSection === 'function') {
                    loadAdminResetSection();
                }
            }

            window.closeSettingsModal = function () {
                document.getElementById('settingsModal').classList.remove('show');
            }

            window.updateSettingsSelection = function () {
                // Update font option styling
                document.querySelectorAll('.font-option').forEach(opt => {
                    const radio = opt.querySelector('input[type="radio"]');
                    if (radio.checked) {
                        opt.classList.add('selected');
                    } else {
                        opt.classList.remove('selected');
                    }
                });
            }

            window.saveSettings = function () {
                // Get selected values
                const theme = document.getElementById('themeSelect')?.value || 'dark';
                const fontSize = document.querySelector('input[name="fontSize"]:checked').value;

                // Save to localStorage
                localStorage.setItem('theme', theme);
                localStorage.setItem('fontSize', fontSize);
                if (theme !== 'light') localStorage.setItem('theme_last_nonlight', theme);

                // Apply theme
                document.documentElement.setAttribute('data-theme', theme);
                const darkToggle = document.getElementById('darkToggle');
                if (darkToggle) {
                    darkToggle.innerHTML = theme === 'light' ? ' Light' : ' Dark';
                }

                // Apply font size
                document.body.setAttribute('data-font-size', fontSize);

                // Show success and close
                alert('Settings saved successfully!');
                closeSettingsModal();
            }

            async function loadAdminResetSection() {
                const section = document.getElementById('adminResetSection');
                if (!section) return;

                const token = localStorage.getItem('auth_token');
                if (!token) {
                    section.style.display = 'none';
                    return;
                }

                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                try {
                    const response = await fetch(`${apiBase}/admin/feedback?limit=1`, {
                        headers: { 'Authorization': `Bearer ${token}` }
                    });
                    section.style.display = response.ok ? 'block' : 'none';
                } catch (error) {
                    console.warn('[ADMIN RESET] Admin check failed:', error);
                    section.style.display = 'none';
                }
            }

            window.adminResetUserPassword = async function () {
                const emailInput = document.getElementById('adminResetEmail');
                const tempPassInput = document.getElementById('adminResetTempPassword');
                const requireChangeInput = document.getElementById('adminRequirePasswordChange');
                const statusDiv = document.getElementById('adminResetStatus');

                if (!emailInput || !statusDiv) return;
                const email = (emailInput.value || '').trim().toLowerCase();
                const newPassword = (tempPassInput?.value || '').trim();
                const requirePasswordChange = !!requireChangeInput?.checked;

                if (!email) {
                    statusDiv.textContent = 'Enter a user email to reset.';
                    statusDiv.style.color = '#ff6b6b';
                    statusDiv.style.display = 'block';
                    return;
                }

                const token = localStorage.getItem('auth_token');
                if (!token) {
                    statusDiv.textContent = 'Not authenticated. Please log in again.';
                    statusDiv.style.color = '#ff6b6b';
                    statusDiv.style.display = 'block';
                    return;
                }

                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                statusDiv.textContent = 'Resetting password...';
                statusDiv.style.color = '#999';
                statusDiv.style.display = 'block';

                try {
                    const response = await fetch(`${apiBase}/admin/users/reset-password`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${token}`
                        },
                        body: JSON.stringify({
                            email,
                            newPassword: newPassword || null,
                            requirePasswordChange
                        })
                    });
                    const data = await response.json();
                    if (!response.ok || data.success === false) {
                        throw new Error(data.error || 'Failed to reset password');
                    }

                    let msg = 'Password reset successfully.';
                    if (data.temporaryPassword) {
                        msg += ` Temporary password: ${data.temporaryPassword}`;
                    }
                    statusDiv.textContent = msg;
                    statusDiv.style.color = '#4caf50';
                    emailInput.value = '';
                    if (tempPassInput) tempPassInput.value = '';
                } catch (error) {
                    statusDiv.textContent = error.message || 'Failed to reset password.';
                    statusDiv.style.color = '#ff6b6b';
                }
            }

            // Feedback Modal Functions
            window.openFeedbackModal = function () {
                document.getElementById('feedbackModal').classList.add('show');
            }

            window.closeFeedbackModal = function () {
                document.getElementById('feedbackModal').classList.remove('show');
                document.getElementById('feedbackSuccess').classList.remove('show');
                document.getElementById('feedbackForm').reset();
            }

            // Switch feedback tab function (GLOBAL)
            window.switchFeedbackTab = function (button) {
                // Remove active from all tabs
                document.querySelectorAll('.feedback-tab').forEach(tab => {
                    tab.classList.remove('active');
                });
                // Add active to clicked tab
                button.classList.add('active');
            }

            // Handle settings control changes
            document.addEventListener('DOMContentLoaded', function () {
                // Settings controls
                const themeSelect = document.getElementById('themeSelect');
                if (themeSelect) themeSelect.addEventListener('change', updateSettingsSelection);
                document.querySelectorAll('.font-option input').forEach(radio => {
                    radio.addEventListener('change', updateSettingsSelection);
                });

                // Load saved settings on page load
                const savedFontSize = localStorage.getItem('fontSize') || 'comfortable';
                document.body.setAttribute('data-font-size', savedFontSize);

                // Handle feedback form submission
                document.getElementById('feedbackForm').addEventListener('submit', async function (e) {
                    e.preventDefault();

                    const submitBtn = this.querySelector('.btn-submit');
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Sending...';

                    const activeTab = document.querySelector('.feedback-tab.active').dataset.type;
                    const formData = {
                        type: activeTab,
                        subject: document.getElementById('feedbackSubject').value,
                        category: document.getElementById('feedbackCategory').value,
                        experience: document.getElementById('feedbackExperience').value,
                        details: document.getElementById('feedbackDetails').value,
                        name: document.getElementById('feedbackName').value || 'Anonymous',
                        timestamp: getCSTTimestamp()
                    };

                    try {
                        const response = await fetch(`${AI_API_BASE}/feedback`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(formData)
                        });

                        if (response.ok) {
                            document.getElementById('feedbackSuccess').classList.add('show');
                            document.getElementById('feedbackForm').reset();
                            setTimeout(() => {
                                closeFeedbackModal();
                            }, 2000);
                        } else {
                            alert('Failed to submit feedback. Please try again.');
                        }
                    } catch (err) {
                        console.error('Feedback submission error:', err);
                        alert('Could not connect to server. Please check your connection.');
                    } finally {
                        submitBtn.disabled = false;
                        submitBtn.textContent = ' SUBMIT';
                    }
                });
            });

            function initializeEventHandlers() {
                // Header navigation - button clicks
                document.querySelectorAll('.nav-item[data-tab]').forEach(item => {
                    item.addEventListener('click', () => {
                        const tabId = item.getAttribute('data-tab');
                        navigateToTab(tabId);
                    });
                });

                // Dropdown menu navigation
                document.querySelectorAll('.dropdown-menu a[data-tab]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (!link.classList.contains('disabled')) {
                            const tabId = link.getAttribute('data-tab');
                            navigateToTab(tabId);
                        }
                    });
                });

                // FTTH menu item (inside Mikrotik dropdown) should open FTTH modal
                document.querySelectorAll('.dropdown-menu a[data-action="open-ftth"]').forEach(link => {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();
                        if (!link.classList.contains('disabled')) {
                            const modal = document.getElementById('ftthModal');
                            if (modal) {
                                modal.style.display = 'block';
                                const lb = document.getElementById('ftth_loopback');
                                if (lb) lb.focus();
                            }
                        }
                    });
                });

                // Event listeners for new tabs
                const generateCCRBtn = document.getElementById('generateCCR');
                const copyCCRBtn = document.getElementById('copyCCR');
                const generateTaranaBtn = document.getElementById('generateTarana');
                const copyTaranaBtn = document.getElementById('copyTarana');
                const generateEntFeedingBtn = document.getElementById('generateEntFeeding');
                const copyEntFeedingBtn = document.getElementById('copyEntFeeding');

                // Legacy CCR handlers removed - now using 6GHz config handlers above
                if (generateTaranaBtn) {
                    generateTaranaBtn.addEventListener('click', function () {
                        if (typeof genTarana === 'function') {
                            genTarana();
                        } else {
                            console.error('genTarana function not defined');
                            alert('Configuration generator not available. Please refresh the page.');
                        }
                    });
                }
                if (copyTaranaBtn) copyTaranaBtn.addEventListener('click', copyTarana);

                // BNG2 Tarana event listeners
                const generateTaranaBNG2Btn = document.getElementById('generateTaranaBNG2');
                const copyTaranaBNG2Btn = document.getElementById('copyTaranaBNG2');
                const taranaBNG2SectorCount = document.getElementById('tarana_bng2_sector_count');

                if (generateTaranaBNG2Btn) {
                    generateTaranaBNG2Btn.addEventListener('click', genTaranaBNG2);
                }
                if (copyTaranaBNG2Btn) {
                    copyTaranaBNG2Btn.addEventListener('click', copyTaranaBNG2);
                }
                if (taranaBNG2SectorCount) {
                    taranaBNG2SectorCount.addEventListener('change', function () {
                        const deltaContainer = document.getElementById('tarana_bng2_delta_container');
                        if (deltaContainer) {
                            deltaContainer.style.display = this.value === '4' ? 'block' : 'none';
                        }
                    });
                }

                // BNG2 Device selection handler - handled above in dedicated section (removed duplicate)

                if (generateEntFeedingBtn) generateEntFeedingBtn.addEventListener('click', genEntFeeding);
                if (copyEntFeedingBtn) copyEntFeedingBtn.addEventListener('click', copyEntFeeding);

                // Enterprise Feeding Out-of-State buttons
                const generateEntFeedingOutStateBtn = document.getElementById('generateEntFeedingOutState');
                const copyEntFeedingOutStateBtn = document.getElementById('copyEntFeedingOutState');
                if (generateEntFeedingOutStateBtn) generateEntFeedingOutStateBtn.addEventListener('click', genEntFeedingOutState);
                if (copyEntFeedingOutStateBtn) copyEntFeedingOutStateBtn.addEventListener('click', copyEntFeedingOutState);

                // Generate and Download buttons
                const generateBtn = document.getElementById('generateBtn');
                const downloadBtn = document.getElementById('downloadBtn');
                const output = document.getElementById('output');

                if (generateBtn) {
                    generateBtn.addEventListener('click', function () {
                        if (typeof generateConfig === 'function') {
                            generateConfig();
                        } else if (typeof window.generateConfig === 'function') {
                            window.generateConfig();
                        } else {
                            console.error('generateConfig function not defined');
                            alert('Configuration generator not available. Please refresh the page.');
                        }
                    });
                }
                if (downloadBtn) {
                    downloadBtn.addEventListener('click', function () {
                        if (typeof downloadConfig === 'function') {
                            downloadConfig();
                        } else {
                            console.error('downloadConfig function not defined');
                        }
                    });
                }

                // Configuration Type change handler
                const configTypeSelect = document.getElementById('configType');
                if (configTypeSelect) {
                    const handleConfigTypeChange = () => {
                        const configType = configTypeSelect.value;
                        const isSimpleMode = configType === 'simple-baseline';

                        // Show/hide sections based on configuration type
                        const mplsSection = document.querySelector('.mpls-section');
                        const vplsSection = document.querySelector('.vpls-section');
                        const bgpSection = document.getElementById('bgpPeers');
                        const ospfSection = document.getElementById('ospfArea');

                        if (mplsSection) mplsSection.style.display = isSimpleMode ? 'none' : 'block';
                        if (vplsSection) vplsSection.style.display = isSimpleMode ? 'none' : 'block';
                        const bgpGroup = bgpSection ? bgpSection.closest('.form-group') : null;
                        const ospfGroup = ospfSection ? ospfSection.closest('.form-group') : null;
                        if (bgpGroup) bgpGroup.style.display = isSimpleMode ? 'none' : 'block';
                        if (ospfGroup) ospfGroup.style.display = isSimpleMode ? 'none' : 'block';

                        // Update compliance status
                        if (typeof updateComplianceStatus === 'function') updateComplianceStatus();
                    };

                    configTypeSelect.addEventListener('change', handleConfigTypeChange);
                    // Apply initial state
                    handleConfigTypeChange();
                }

                // OSPF Area change handler
                const ospfAreaSelect = document.getElementById('ospfArea');
                if (ospfAreaSelect) {
                    ospfAreaSelect.addEventListener('change', function () {
                        const customInput = document.getElementById('ospfAreaCustom');
                        if (customInput) {
                            customInput.style.display = this.value === 'custom' ? 'block' : 'none';
                        }

                        // Hide LAN Bridge and NAT Public IP for MPLS/BNG areas
                        const lanBridgeSection = document.getElementById('lanBridgeSection');
                        const natPublicSection = document.getElementById('natPublicSection');
                        const isMPLSArea = this.value.includes('IL') || this.value.includes('243') ||
                            this.value.includes('248') || this.value.includes('249') ||
                            this.value.includes('250') || this.value.includes('42');

                        if (lanBridgeSection) {
                            lanBridgeSection.style.display = isMPLSArea ? 'none' : 'block';
                        }
                        if (natPublicSection) {
                            natPublicSection.style.display = isMPLSArea ? 'none' : 'block';
                        }
                    });
                }

                // Feature checkboxes
                const enableTarana = document.getElementById('enableTarana');
                const enableSWT = document.getElementById('enableSWT');
                const enableVPLS = document.getElementById('enableVPLS');
                const enableMPLS = document.getElementById('enableMPLS');
                const enableDHCP = document.getElementById('enableDHCP');

                if (enableTarana) enableTarana.addEventListener('change', toggleTaranaSection);
                if (enableSWT) enableSWT.addEventListener('change', toggleSWTSection);
                if (enableVPLS) enableVPLS.addEventListener('change', toggleVPLSSection);
                if (enableMPLS) enableMPLS.addEventListener('change', toggleMPLSSection);
                if (enableDHCP) enableDHCP.addEventListener('change', toggleDHCPSection);

                // Tarana sector configuration
                const enableTaranaAlpha = document.getElementById('enableTaranaAlpha');
                const enableTaranaBeta = document.getElementById('enableTaranaBeta');
                const enableTaranaGamma = document.getElementById('enableTaranaGamma');
                const enableTaranaDelta = document.getElementById('enableTaranaDelta');
                const btnAutoConfigTarana = document.getElementById('btnAutoConfigTarana');

                if (btnAutoConfigTarana) btnAutoConfigTarana.addEventListener('click', autoConfigureTaranaSectors);
                // Tarana mini-generator preview and copy buttons removed  Tarana block is included automatically in the full generated config

                // VLAN Profile handler
                const vlanProfile = document.getElementById('vlanProfile');
                if (vlanProfile) {
                    vlanProfile.addEventListener('change', function () {
                        if (this.value) {
                            populateVlanProfile(this.value);
                        }
                    });
                }

                // Auto-calculate ranges when LAN Bridge IP changes
                const lanBridgeIP = document.getElementById('lanBridgeIP');
                if (lanBridgeIP) {
                    lanBridgeIP.addEventListener('input', autoCalculateRanges);
                }

                // Auto-fill system name when site name changes with auto-capitalization
                const siteName = document.getElementById('siteName');
                const systemName = document.getElementById('systemName');
                if (siteName && systemName) {
                    siteName.addEventListener('input', function () {
                        // Auto-capitalize the site name
                        this.value = this.value.toUpperCase();

                        if (this.value) {
                            // Get the selected target device
                            const targetDevice = document.getElementById('targetDevice')?.value;
                            const deviceConfig = targetDevice && DEVICE_CONFIGS[targetDevice] ? DEVICE_CONFIGS[targetDevice] : DEVICE_CONFIGS.ccr2004;

                            // Auto-fill system identity with proper device name
                            systemName.value = `RTR-${deviceConfig.name}-1.${this.value}`;
                        }
                    });
                }

                // Router ID change handler
                const routerId = document.getElementById('routerId');
                if (routerId) {
                    routerId.addEventListener('input', function () {
                        const ldpTransport = document.getElementById('ldpTransport');
                        if (ldpTransport) {
                            ldpTransport.value = this.value;
                        }
                    });
                }

                // MPLS: Enable BGP toggle (hide/show BGP fields)
                const entMplsEnableBGP = document.getElementById('ent_mpls_enableBGP');
                if (entMplsEnableBGP) {
                    entMplsEnableBGP.addEventListener('change', function () {
                        const block = document.getElementById('ent_mpls_bgpBlock');
                        const peers = document.getElementById('ent_mpls_bgpPeersBlock');
                        if (block) block.style.display = this.checked ? 'block' : 'none';
                        if (peers) peers.style.display = this.checked ? 'block' : 'none';
                    });
                }

                // DHCP toggle (using existing enableDHCP variable)
                if (enableDHCP) {
                    enableDHCP.addEventListener('change', function () {
                        const dhcpSection = document.getElementById('dhcpSection');
                        if (dhcpSection) {
                            dhcpSection.style.display = this.checked ? 'block' : 'none';
                        }
                    });
                }

                // VLAN 4000 subnet change handler
                const vlan4000Subnet = document.getElementById('vlan4000Subnet');
                if (vlan4000Subnet) {
                    vlan4000Subnet.addEventListener('input', autoCalculateRanges);
                }
                // Dark mode toggle
                const darkToggle = document.getElementById('darkToggle');
                if (darkToggle) {
                    darkToggle.addEventListener('click', toggleDarkMode);
                }

                // Validation button
                const validateBtn = document.getElementById('validateConfigBtn');
                if (validateBtn) {
                    validateBtn.addEventListener('click', validateConfiguration);
                }

                // Setup live validation for all relevant input fields
                function setupLiveValidation() {
                    // Debounce function to avoid excessive validation calls
                    let validationTimeout;
                    const debouncedValidation = () => {
                        clearTimeout(validationTimeout);
                        validationTimeout = setTimeout(performLiveValidation, 300);
                    };

                    // Core IP/network fields
                    const validationFields = [
                        'siteName', 'routerId', 'lanBridgeIP', 'natPublicIP',
                        'ldpTransport', 'siteLatitude', 'siteLongitude',
                        'vlan3000Subnet', 'vlan4000Subnet', 'sharedKey',
                        'snmpCommunity', 'dhcpSecret'
                    ];

                    validationFields.forEach(fieldId => {
                        const field = document.getElementById(fieldId);
                        if (field) {
                            field.addEventListener('input', debouncedValidation);
                            field.addEventListener('change', debouncedValidation);
                        }
                    });

                    // Device selection
                    const targetDevice = document.getElementById('targetDevice');
                    if (targetDevice) {
                        targetDevice.addEventListener('change', debouncedValidation);
                    }

                    // DHCP toggle
                    const enableDHCP = document.getElementById('enableDHCP');
                    if (enableDHCP) {
                        enableDHCP.addEventListener('change', debouncedValidation);
                    }

                    // Use MutationObserver to catch dynamically added port/uplink fields
                    const portConfigsContainer = document.getElementById('portConfigs');
                    if (portConfigsContainer) {
                        const observer = new MutationObserver(() => {
                            // Re-attach validation to new port/uplink inputs
                            document.querySelectorAll('#portConfigs input[name="portUplinkIp"]').forEach(input => {
                                if (!input.dataset.validationAttached) {
                                    input.addEventListener('input', debouncedValidation);
                                    input.dataset.validationAttached = 'true';
                                }
                            });
                            document.querySelectorAll('#portConfigs select[name="portUplinkType"], #portConfigs select[name="portUplinkPort"], #portConfigs select[name="portName"]').forEach(select => {
                                if (!select.dataset.validationAttached) {
                                    select.addEventListener('change', debouncedValidation);
                                    select.dataset.validationAttached = 'true';
                                }
                            });
                        });
                        observer.observe(portConfigsContainer, { childList: true, subtree: true });
                    }

                    // Attach to existing port/uplink fields
                    document.querySelectorAll('#portConfigs input[name="portUplinkIp"]').forEach(input => {
                        input.addEventListener('input', debouncedValidation);
                        input.dataset.validationAttached = 'true';
                    });
                    document.querySelectorAll('#portConfigs select[name="portUplinkType"], #portConfigs select[name="portUplinkPort"], #portConfigs select[name="portName"]').forEach(select => {
                        select.addEventListener('change', debouncedValidation);
                        select.dataset.validationAttached = 'true';
                    });

                    // Attach to old uplink structure
                    const uplinksContainer = document.getElementById('uplinks');
                    if (uplinksContainer) {
                        const uplinkObserver = new MutationObserver(() => {
                            document.querySelectorAll('#uplinks input[id*="Ip"]').forEach(input => {
                                if (!input.dataset.validationAttached) {
                                    input.addEventListener('input', debouncedValidation);
                                    input.dataset.validationAttached = 'true';
                                }
                            });
                            document.querySelectorAll('#uplinks select[id*="NewPort"]').forEach(select => {
                                if (!select.dataset.validationAttached) {
                                    select.addEventListener('change', debouncedValidation);
                                    select.dataset.validationAttached = 'true';
                                }
                            });
                        });
                        uplinkObserver.observe(uplinksContainer, { childList: true, subtree: true });
                    }

                    // Attach to existing uplink fields
                    document.querySelectorAll('#uplinks input[id*="Ip"]').forEach(input => {
                        input.addEventListener('input', debouncedValidation);
                        input.dataset.validationAttached = 'true';
                    });
                    document.querySelectorAll('#uplinks select[id*="NewPort"]').forEach(select => {
                        select.addEventListener('change', debouncedValidation);
                        select.dataset.validationAttached = 'true';
                    });

                    // Attach to static customer ranges
                    const staticCustomersContainer = document.getElementById('staticCustomers');
                    if (staticCustomersContainer) {
                        const customerObserver = new MutationObserver(() => {
                            document.querySelectorAll('#staticCustomers input[name="customerRange"]').forEach(input => {
                                if (!input.dataset.validationAttached) {
                                    input.addEventListener('input', debouncedValidation);
                                    input.dataset.validationAttached = 'true';
                                }
                            });
                        });
                        customerObserver.observe(staticCustomersContainer, { childList: true, subtree: true });
                    }
                    document.querySelectorAll('#staticCustomers input[name="customerRange"]').forEach(input => {
                        input.addEventListener('input', debouncedValidation);
                        input.dataset.validationAttached = 'true';
                    });
                }

                // Initialize live validation
                setupLiveValidation();

                // SSH RouterOS version change handler
                const sshRouterOSVersion = document.getElementById('sshRouterOSVersion');
                if (sshRouterOSVersion) {
                    sshRouterOSVersion.addEventListener('change', updateSSHExportCommand);
                }

                // Auto-check compliance when configuration changes
                const complianceInputs = document.querySelectorAll('#complianceChecklist input[type="checkbox"]');
                complianceInputs.forEach(input => {
                    input.addEventListener('change', updateComplianceStatus);
                });
                // Add port/uplink configuration event handlers
                const addPortBtn = document.getElementById('addPortUplinkBtn');
                // Auto-populate Tarana button removed from Port Configuration to avoid duplication with Tarana optional feature
                const btnAutoPopulateTarana = null;
                const btnAutoPopulateNetonix = document.getElementById('btnAutoPopulateNetonix');

                // NOTE: addPortUplink is wired later as a single canonical listener to avoid duplicates.
                if (btnAutoPopulateNetonix) btnAutoPopulateNetonix.addEventListener('click', autoPopulateNetonixPorts);

                // Static customer management
                const addCustomerBtn = document.getElementById('addCustomerBtn');
                if (addCustomerBtn) addCustomerBtn.addEventListener('click', addCustomer);

                // Device selection functionality
                const targetDevice = document.getElementById('targetDevice');
                const currentDevice = document.getElementById('currentDevice');
                if (targetDevice) targetDevice.addEventListener('change', updateDevicePorts);
                if (currentDevice) currentDevice.addEventListener('change', updateDevicePorts);

                // Enterprise Feeding device selection functionality
                const entFeedingDevice = document.getElementById('ent_feeding_device');
                const entFeedingRouterOS = document.getElementById('ent_feeding_routeros');
                if (entFeedingDevice) entFeedingDevice.addEventListener('change', handleEnterpriseFeedingDeviceChange);
                if (entFeedingRouterOS) entFeedingRouterOS.addEventListener('change', handleEnterpriseFeedingRouterOSChange);

                // Enterprise Config device selection functionality
                const entRouterboardDevice = document.getElementById('ent_routerboard_device');
                const entRouterOSVersion = document.getElementById('ent_routeros_version');
                if (entRouterboardDevice) entRouterboardDevice.addEventListener('change', handleEnterpriseDeviceChange);
                if (entRouterOSVersion) entRouterOSVersion.addEventListener('change', handleEnterpriseRouterOSChange);

                // MPLS Enterprise Config device selection functionality
                const entMplsRouterboardDevice = document.getElementById('ent_mpls_routerboard_device');
                const entMplsRouterOSVersion = document.getElementById('ent_mpls_routeros_version');
                if (entMplsRouterboardDevice) entMplsRouterboardDevice.addEventListener('change', handleMplsEnterpriseDeviceChange);
                if (entMplsRouterOSVersion) entMplsRouterOSVersion.addEventListener('change', handleMplsEnterpriseRouterOSChange);

                // 6GHz Switch Config IN-STATE event listeners
                const generateGhzBtn = document.getElementById('generateGhz');
                const copyGhzBtn = document.getElementById('copyGhz');
                if (generateGhzBtn) {
                    generateGhzBtn.addEventListener('click', function () {
                        if (typeof generate6GhzConfig === 'function') {
                            generate6GhzConfig();
                        } else {
                            console.error('generate6GhzConfig function not defined');
                            alert('Configuration generator not available. Please refresh the page.');
                        }
                    });
                }
                if (copyGhzBtn) {
                    copyGhzBtn.addEventListener('click', copy6Ghz);
                }

                // 6GHz Switch Config OUT-OF-STATE event listeners
                const generateGhzOutstateBtn = document.getElementById('generateGhzOutstate');
                const copyGhzOutstateBtn = document.getElementById('copyGhzOutstate');
                const ghzOutstateSwitchType = document.getElementById('ghz_outstate_switch_type');

                if (ghzOutstateSwitchType) {
                    ghzOutstateSwitchType.addEventListener('change', handleGhzOutstateSwitchChange);
                }

                if (generateGhzOutstateBtn) {
                    generateGhzOutstateBtn.addEventListener('click', function () {
                        if (typeof generate6GhzOutstateConfig === 'function') {
                            generate6GhzOutstateConfig();
                        } else {
                            console.error('generate6GhzOutstateConfig function not defined');
                            alert('Configuration generator not available. Please refresh the page.');
                        }
                    });
                }
                if (copyGhzOutstateBtn) {
                    copyGhzOutstateBtn.addEventListener('click', copy6GhzOutstate);
                }

                // Tarana Sectors device selection functionality (BNG1)
                const taranaRouterboardDevice = document.getElementById('tarana_routerboard_device');
                const taranaRouterOSVersion = document.getElementById('tarana_routeros_version');
                if (taranaRouterboardDevice) {
                    console.log('[INIT] Attaching Tarana BNG1 device change handler');
                    // Ensure function exists before attaching
                    if (typeof handleTaranaDeviceChange === 'function') {
                        taranaRouterboardDevice.addEventListener('change', handleTaranaDeviceChange);
                        // Only populate ports if a device is already selected
                        if (taranaRouterboardDevice.value) {
                            console.log('[INIT] Device already selected, populating ports');
                            handleTaranaDeviceChange();
                        }
                        // Also trigger on click to ensure it works (fallback)
                        taranaRouterboardDevice.addEventListener('click', function () {
                            setTimeout(function () {
                                if (typeof handleTaranaDeviceChange === 'function') {
                                    handleTaranaDeviceChange();
                                }
                            }, 100);
                        });
                    } else {
                        console.error('[INIT] handleTaranaDeviceChange function not defined!');
                    }
                } else {
                    console.error('[INIT] tarana_routerboard_device element not found!');
                }
                if (taranaRouterOSVersion) {
                    if (typeof handleTaranaRouterOSChange === 'function') {
                        taranaRouterOSVersion.addEventListener('change', handleTaranaRouterOSChange);
                    }
                }

                // BNG2 Tarana device selection functionality
                const taranaBNG2Device = document.getElementById('tarana_bng2_device');
                if (taranaBNG2Device) {
                    console.log('[INIT] Attaching Tarana BNG2 device change handler');
                    if (typeof handleTaranaBNG2DeviceChange === 'function') {
                        taranaBNG2Device.addEventListener('change', handleTaranaBNG2DeviceChange);
                        // Populate ports if device already selected
                        if (taranaBNG2Device.value) {
                            console.log('[INIT] BNG2 Device already selected, populating ports');
                            handleTaranaBNG2DeviceChange();
                        }
                        // Click fallback for BNG2
                        taranaBNG2Device.addEventListener('click', function () {
                            setTimeout(function () {
                                if (typeof handleTaranaBNG2DeviceChange === 'function') {
                                    handleTaranaBNG2DeviceChange();
                                }
                            }, 100);
                        });
                    } else {
                        console.error('[INIT] handleTaranaBNG2DeviceChange function not defined!');
                    }
                } else {
                    console.warn('[INIT] tarana_bng2_device element not found (may not be on this tab)');
                }

                // Uplinks dynamic
                const addUplinkBtn = document.getElementById('addUplinkBtn');
                if (addUplinkBtn) addUplinkBtn.addEventListener('click', addUplink);

                // Combined Port/Uplink button handler
                const addPortUplinkBtn = document.getElementById('addPortUplinkBtn');
                if (addPortUplinkBtn) addPortUplinkBtn.addEventListener('click', addPortUplink);

                // Configuration Type change handler
                const configType = document.getElementById('configType');
                if (configType) {
                    configType.addEventListener('change', handleConfigTypeChange);
                    // Initialize on load
                    handleConfigTypeChange();
                }

                // Initialize uplink template
                const uplink1NewPort = document.getElementById('uplink1NewPort');
                const uplinkTemplate = document.getElementById('uplinkTemplate');
                if (uplink1NewPort && uplinkTemplate) {
                    const uplinkPortOptions = uplink1NewPort.innerHTML;
                    uplinkTemplate.querySelector('select').innerHTML = uplinkPortOptions;
                }

                // VLAN interface management
                const addVlanBtn = document.getElementById('addVlanBtn');
                if (addVlanBtn) addVlanBtn.addEventListener('click', () => addVlan());

                // VPLS management
                const addVplsBtn = document.getElementById('addVplsBtn');
                if (addVplsBtn) addVplsBtn.addEventListener('click', addVpls);

                // VLAN profile populate button
                const btnPopulateVlans = document.getElementById('btnPopulateVlans');
                if (btnPopulateVlans) {
                    btnPopulateVlans.addEventListener('click', () => {
                        const profile = document.getElementById('vlanProfile').value;
                        if (profile) populateVlanProfile(profile);
                    });
                }

                // Initialize port dropdowns based on default device selection
                updateDevicePorts();

                // Add port change listeners to update labels dynamically
                const uplink1NewPortElement = document.getElementById('uplink1NewPort');
                if (uplink1NewPortElement) {
                    uplink1NewPortElement.addEventListener('change', updatePortLabels);
                }

                // NOC Workflow Tools
                const btnPresetBackbone = document.getElementById('btnPresetBackbone');
                const btnPresetMPLS = document.getElementById('btnPresetMPLS');
                const btnPresetTarana = document.getElementById('btnPresetTarana');
                const btnValidateConfig = document.getElementById('btnValidateConfig');
                const btnCheckCompliance = document.getElementById('btnCheckCompliance');
                const btnExportTroubleshooting = document.getElementById('btnExportTroubleshooting');

                if (btnPresetBackbone) btnPresetBackbone.addEventListener('click', applyBackbonePreset);
                if (btnPresetMPLS) btnPresetMPLS.addEventListener('click', applyMPLSPreset);
                if (btnPresetTarana) btnPresetTarana.addEventListener('click', applyTaranaPreset);
                if (btnValidateConfig) btnValidateConfig.addEventListener('click', validateConfiguration);
                if (btnCheckCompliance) btnCheckCompliance.addEventListener('click', checkRFCCompliance);

            }

            // NOC Workflow Functions
            function applyBackbonePreset() {
                document.getElementById('ospfArea').value = 'backbone-v2';
                document.getElementById('enableDHCP').checked = true;
                document.getElementById('enableMPLS').checked = false;
                document.getElementById('enableVPLS').checked = false;
                document.getElementById('enableTarana').checked = false;
                document.getElementById('enableSWT').checked = false;

                // Trigger area change to update UI
                document.getElementById('ospfArea').dispatchEvent(new Event('change'));

                alert('Backbone-v2 preset applied! BGP/OSPF configuration with DHCP enabled.');
            }

            function applyMPLSPreset() {
                document.getElementById('ospfArea').value = 'backbone-v2-IL';
                document.getElementById('enableDHCP').checked = false;
                document.getElementById('enableMPLS').checked = true;
                document.getElementById('enableVPLS').checked = true;
                document.getElementById('enableTarana').checked = false;
                document.getElementById('enableSWT').checked = false;

                // Trigger area change to update UI
                document.getElementById('ospfArea').dispatchEvent(new Event('change'));

                alert('MPLS/VPLS preset applied! MPLS/LDP and VPLS tunnels enabled.');
            }

            function applyTaranaPreset() {
                document.getElementById('ospfArea').value = 'backbone-v2';
                document.getElementById('enableDHCP').checked = true;
                document.getElementById('enableMPLS').checked = false;
                document.getElementById('enableVPLS').checked = false;
                document.getElementById('enableTarana').checked = true;
                document.getElementById('enableSWT').checked = false;

                // Enable common Tarana sectors by default
                document.getElementById('enableTaranaAlpha').checked = true;
                document.getElementById('enableTaranaBeta').checked = true;
                document.getElementById('enableTaranaGamma').checked = true;
                document.getElementById('enableTaranaDelta').checked = false; // DELTA is rare

                // Trigger area change to update UI
                document.getElementById('ospfArea').dispatchEvent(new Event('change'));

                alert('Tarana preset applied! ALPHA, BETA, and GAMMA sectors enabled. Use "Auto-Configure Selected Sectors" to set up VLANs.');
            }

            async function autoConfigureTaranaSectors() {
                // Show progress tracker
                window.showProgressTracker('Tarana Sectors Configuration');
                window.updateProgressStep('Initializing Tarana sector configuration...');
                window.updateProgressPercent(5);
                window.addProgressLog('info', 'Starting Tarana sector auto-configuration');

                await new Promise(resolve => setTimeout(resolve, 300));

                window.updateProgressStep('Validating device selection...');
                window.updateProgressPercent(10);
                window.addProgressLog('info', 'Checking target device configuration');

                const targetDevice = document.getElementById('targetDevice').value;
                const deviceConfig = DEVICE_CONFIGS[targetDevice];

                if (!deviceConfig) {
                    window.addProgressLog('error', 'Target device not selected');
                    window.completeProgressTracker(false);
                    alert('Please select a target device first.');
                    return;
                }

                window.addProgressLog('success', `Device: ${deviceConfig.name}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Checking selected sectors...');
                window.updateProgressPercent(20);
                window.addProgressLog('info', 'Reading sector selection');

                // Get selected sectors
                const alphaSelected = document.getElementById('enableTaranaAlpha').checked;
                const betaSelected = document.getElementById('enableTaranaBeta').checked;
                const gammaSelected = document.getElementById('enableTaranaGamma').checked;
                const deltaSelected = document.getElementById('enableTaranaDelta').checked;

                if (!alphaSelected && !betaSelected && !gammaSelected && !deltaSelected) {
                    window.addProgressLog('error', 'No sectors selected');
                    window.completeProgressTracker(false);
                    alert('Please select at least one Tarana sector to configure.');
                    return;
                }

                const selectedSectors = [];
                if (alphaSelected) selectedSectors.push('ALPHA');
                if (betaSelected) selectedSectors.push('BETA');
                if (gammaSelected) selectedSectors.push('GAMMA');
                if (deltaSelected) selectedSectors.push('DELTA');

                window.addProgressLog('success', `Selected sectors: ${selectedSectors.join(', ')}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Determining port mappings...');
                window.updateProgressPercent(30);
                window.addProgressLog('info', 'Mapping sector ports based on device type');

                // Define sector port mappings based on device
                let sectorPorts = {};
                if (deviceConfig.name === 'CCR2004' || deviceConfig.name === 'CCR2216') {
                    // RouterOS v7 devices use sfp-sfpplus naming
                    sectorPorts = {
                        alpha: 'sfp-sfpplus8',
                        beta: 'sfp-sfpplus9',
                        gamma: 'sfp-sfpplus10',
                        delta: 'sfp-sfpplus11'
                    };
                } else if (deviceConfig.name === 'CCR1036') {
                    // CCR1036 uses sfp naming
                    sectorPorts = {
                        alpha: 'sfp1',
                        beta: 'sfp2',
                        gamma: 'sfp3',
                        delta: 'sfp4'
                    };
                } else {
                    // Default to sfp-sfpplus for other devices
                    sectorPorts = {
                        alpha: 'sfp-sfpplus8',
                        beta: 'sfp-sfpplus9',
                        gamma: 'sfp-sfpplus10',
                        delta: 'sfp-sfpplus11'
                    };
                }

                window.addProgressLog('success', `Port mappings determined for ${deviceConfig.name}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Configuring Tarana sectors...');
                window.updateProgressPercent(40);
                window.addProgressLog('info', 'Adding VLANs for each selected sector');

                // Configure selected sectors
                const configuredSectors = [];
                let sectorCount = 0;
                const totalSectors = selectedSectors.length;

                if (alphaSelected) {
                    window.updateProgressPercent(40 + Math.floor((sectorCount / totalSectors) * 40));
                    window.updateProgressStep(`Configuring ALPHA sector (${sectorCount + 1}/${totalSectors})...`);
                    window.addProgressLog('info', `Configuring ALPHA sector on port ${sectorPorts.alpha}`);
                    addTaranaVLANs('ALPHA', sectorPorts.alpha);
                    configuredSectors.push('ALPHA');
                    sectorCount++;
                    window.addProgressLog('success', 'ALPHA sector configured (VLANs 1000, 2000, 3000)');
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                if (betaSelected) {
                    window.updateProgressPercent(40 + Math.floor((sectorCount / totalSectors) * 40));
                    window.updateProgressStep(`Configuring BETA sector (${sectorCount + 1}/${totalSectors})...`);
                    window.addProgressLog('info', `Configuring BETA sector on port ${sectorPorts.beta}`);
                    addTaranaVLANs('BETA', sectorPorts.beta);
                    configuredSectors.push('BETA');
                    sectorCount++;
                    window.addProgressLog('success', 'BETA sector configured (VLANs 1000, 2000, 3000)');
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                if (gammaSelected) {
                    window.updateProgressPercent(40 + Math.floor((sectorCount / totalSectors) * 40));
                    window.updateProgressStep(`Configuring GAMMA sector (${sectorCount + 1}/${totalSectors})...`);
                    window.addProgressLog('info', `Configuring GAMMA sector on port ${sectorPorts.gamma}`);
                    addTaranaVLANs('GAMMA', sectorPorts.gamma);
                    configuredSectors.push('GAMMA');
                    sectorCount++;
                    window.addProgressLog('success', 'GAMMA sector configured (VLANs 1000, 2000, 3000)');
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                if (deltaSelected) {
                    window.updateProgressPercent(40 + Math.floor((sectorCount / totalSectors) * 40));
                    window.updateProgressStep(`Configuring DELTA sector (${sectorCount + 1}/${totalSectors})...`);
                    window.addProgressLog('info', `Configuring DELTA sector on port ${sectorPorts.delta}`);
                    addTaranaVLANs('DELTA', sectorPorts.delta);
                    configuredSectors.push('DELTA');
                    sectorCount++;
                    window.addProgressLog('success', 'DELTA sector configured (VLANs 1000, 2000, 3000)');
                    await new Promise(resolve => setTimeout(resolve, 300));
                }

                window.updateProgressPercent(100);
                window.updateProgressStep('Tarana sectors configured successfully!');
                window.addProgressLog('success', `All sectors configured: ${configuredSectors.join(', ')}`);
                window.completeProgressTracker(true);

                // Track activity for analytics (reuse targetDevice and deviceConfig from above - already declared earlier in function)
                saveConfigToHistory({
                    type: 'tarana-config',
                    device: deviceConfig ? deviceConfig.name : targetDevice,
                    siteName: `Tarana Sectors: ${configuredSectors.join(', ')}`,
                    routeros: '7.19.4', // Default RouterOS for Tarana
                    success: true
                });

                alert(`Tarana sectors configured successfully!\n\nConfigured sectors: ${configuredSectors.join(', ')}\n\nEach sector includes:\n- VLAN 1000  lan-bridge\n- VLAN 2000  bridge2000\n- VLAN 3000  UNICORNMGMT`);
            }

            function addTaranaVLANs(sectorName, portName) {
                // Add VLAN 1000
                addVlan({
                    parent: portName,
                    vid: 1000,
                    comment: `Tarana ${sectorName} - VLAN 1000`,
                    bridge: 'lan-bridge'
                });

                // Add VLAN 2000
                addVlan({
                    parent: portName,
                    vid: 2000,
                    comment: `Tarana ${sectorName} - VLAN 2000`,
                    bridge: 'bridge2000'
                });

                // Add VLAN 3000
                addVlan({
                    parent: portName,
                    vid: 3000,
                    comment: `Tarana ${sectorName} - VLAN 3000`,
                    bridge: 'bridge3000'
                });
            }

            function validateConfiguration() {
                const siteName = document.getElementById('siteName').value;
                const routerId = document.getElementById('routerId').value;
                const targetDevice = document.getElementById('targetDevice').value;

                let issues = [];

                if (!siteName) issues.push('Site Name is required');
                if (!routerId) issues.push('Router ID is required');
                if (!targetDevice) issues.push('Target Device must be selected');

                // Comprehensive IP validation
                const ipErrors = validateAllIPs();
                issues.push(...ipErrors);

                if (issues.length === 0) {
                    alert(' Configuration validation passed! All required fields are filled and IP addresses are valid.');
                } else {
                    alert(' Configuration Issues Found:\n\n' + issues.join('\n'));
                }
            }
            function checkRFCCompliance() {
                const complianceItems = document.querySelectorAll('#complianceChecklist input[type="checkbox"]');
                let checkedCount = 0;
                let totalCount = complianceItems.length;

                complianceItems.forEach(item => {
                    if (item.checked) checkedCount++;
                });

                const percentage = Math.round((checkedCount / totalCount) * 100);
                alert(`RFC Compliance Status: ${checkedCount}/${totalCount} items (${percentage}%)\n\nAll baseline RFC configurations are automatically applied to every generated config.`);
            }


            function toggleTaranaSection() {
                const taranaSection = document.getElementById('taranaSection');
                const vlanSection = document.getElementById('vlanSection');
                if (taranaSection) taranaSection.style.display = this.checked ? 'block' : 'none';
                if (vlanSection) vlanSection.style.display = (this.checked || document.getElementById('enableSWT').checked) ? 'grid' : 'none';
                // When enabling Tarana, apply defaults
                if (this.checked) applyTaranaDefaults();
            }

            // Apply Tarana defaults based on selected device
            function applyTaranaDefaults() {
                const target = document.getElementById('targetDevice')?.value || 'ccr2004';
                const cfg = DEVICE_CONFIGS[target] || DEVICE_CONFIGS.ccr2004;

                // Default mappings (per model family)
                const defaults = {
                    CCR2004: { alpha: 'sfp-sfpplus8', beta: 'sfp-sfpplus9', gamma: 'sfp-sfpplus10', delta: 'sfp-sfpplus11', speed: '10G-baseCR', mtu: 1500 },
                    CCR2216: { alpha: 'sfp28-1', beta: 'sfp28-2', gamma: 'sfp28-3', delta: 'sfp28-4', speed: '10G-baseCR', mtu: 1500 },
                    CCR1036: { alpha: 'sfp1', beta: 'sfp2', gamma: 'sfp3', delta: 'sfp4', speed: '1G-baseT-full', mtu: 1500 },
                    RB5009: { alpha: 'sfp-sfpplus6', beta: 'sfp-sfpplus7', gamma: 'sfp-sfpplus8', delta: '', speed: '10G-baseCR', mtu: 1500 },
                    RB1009: { alpha: 'sfp1', beta: 'sfp2', gamma: 'sfp3', delta: '', speed: '1G-baseT-full', mtu: 1500 }
                };

                let modelKey = 'CCR2004';
                if (cfg && cfg.name) {
                    if (cfg.name.includes('CCR2216')) modelKey = 'CCR2216';
                    else if (cfg.name.includes('CCR2004')) modelKey = 'CCR2004';
                    else if (cfg.name.includes('CCR1036')) modelKey = 'CCR1036';
                    else if (cfg.name.includes('RB5009')) modelKey = 'RB5009';
                    else if (cfg.name.includes('RB1009')) modelKey = 'RB1009';
                }

                const d = defaults[modelKey];
                if (d) {
                    // set port selects
                    const setIf = (id, val) => { const el = document.getElementById(id); if (el && val !== undefined) el.value = val; };
                    setIf('tower_tarana_alpha', d.alpha);
                    setIf('tower_tarana_beta', d.beta);
                    setIf('tower_tarana_gamma', d.gamma);
                    setIf('tower_tarana_delta', d.delta || '');

                    // set speed and mtu
                    setIf('tower_tarana_alpha_speed', d.speed);
                    setIf('tower_tarana_beta_speed', d.speed);
                    setIf('tower_tarana_gamma_speed', d.speed);
                    setIf('tower_tarana_delta_speed', d.speed);
                    setIf('tower_tarana_alpha_mtu', d.mtu);
                    setIf('tower_tarana_beta_mtu', d.mtu);
                    setIf('tower_tarana_gamma_mtu', d.mtu);
                    setIf('tower_tarana_delta_mtu', d.mtu);
                }
            }

            function toggleSWTSection() {
                const vlanSection = document.getElementById('vlanSection');
                if (vlanSection) vlanSection.style.display = (this.checked || document.getElementById('enableTarana').checked) ? 'grid' : 'none';
            }
            function toggleVPLSSection() {
                const vplsSection = document.querySelector('.vpls-section');
                if (vplsSection) vplsSection.style.display = this.checked ? 'block' : 'none';
                if (this.checked) {
                    document.getElementById('vlanProfile').value = 'vpls';
                    populateVlanProfile('vpls');
                }
            }
            function toggleMPLSSection() {
                const mplsSection = document.querySelector('.mpls-section');
                if (mplsSection) mplsSection.style.display = this.checked ? 'block' : 'none';
            }

            function toggleDHCPSection() {
                const dhcpSection = document.getElementById('dhcpSection');
                if (dhcpSection) dhcpSection.style.display = this.checked ? 'block' : 'none';
            }

            function autoCalculateRanges() {
                const lanBridgeIP = document.getElementById('lanBridgeIP').value;
                if (lanBridgeIP && lanBridgeIP.includes('/')) {
                    const [ip, cidr] = lanBridgeIP.split('/');
                    const octets = ip.split('.').map(Number);

                    // Calculate CPE range (same as LAN bridge)
                    const cpeRange = document.getElementById('cpeRange');
                    if (cpeRange) cpeRange.value = lanBridgeIP;

                    // Calculate unauth range (increment second octet by 100)
                    const unauthOctets = [...octets];
                    unauthOctets[1] += 100;
                    const unauthRange = document.getElementById('unauthRange');
                    if (unauthRange) unauthRange.value = `${unauthOctets.join('.')}/${cidr}`;
                }
            }

            function toggleDarkMode() {
                const html = document.documentElement;
                const currentTheme = html.getAttribute('data-theme') || 'dark';
                const lastNonLight = localStorage.getItem('theme_last_nonlight') || 'dark';
                let newTheme;
                if (currentTheme === 'light') {
                    newTheme = lastNonLight;
                } else {
                    localStorage.setItem('theme_last_nonlight', currentTheme);
                    newTheme = 'light';
                }
                html.setAttribute('data-theme', newTheme);
                const darkToggle = document.getElementById('darkToggle');
                if (darkToggle) {
                    darkToggle.innerHTML = newTheme === 'light' ? ' Light' : ' Dark';
                }
                // Save preference
                localStorage.setItem('theme', newTheme);
            }

            // === AI Chat Wiring ===
            (function initChat() {
                const log = document.getElementById('chatLog');
                const input = document.getElementById('chatInput');
                const send = document.getElementById('chatSendBtn');
                if (!log || !input || !send) return;
                function append(role, text) {
                    const tag = role === 'user' ? '' : '';
                    const div = document.createElement('div');
                    div.textContent = `${tag} ${text}`;
                    log.appendChild(div);
                    log.scrollTop = log.scrollHeight;
                }
                async function doSend() {
                    const q = input.value.trim();
                    if (!q) return;
                    append('user', q);
                    input.value = '';
                    try {
                        const r = await fetch(`${AI_API_BASE}/chat`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ message: q }) });
                        const j = await r.json();
                        if (!j.success) throw new Error(j.error || 'Chat failed');
                        append('assistant', j.reply);
                    } catch (e) { append('assistant', 'Error: ' + e.message); }
                }
                send.addEventListener('click', doSend);
                input.addEventListener('keydown', function (ev) { if (ev.key === 'Enter') doSend(); });
            })();

            // Copy upgrade output to clipboard
            function copyUpgradeOutput() {
                const ta = document.getElementById("upgradeOutput");
                const text = ta ? (ta.value || ta.textContent || "") : "";
                if (!text.trim()) { alert("No configuration to copy!"); return; }
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(text).then(() => alert("Configuration copied to clipboard")).catch(() => {
                        copyTextFallback(text);
                    });
                } else {
                    copyTextFallback(text);
                }
            }

            // Download upgrade output as .rsc file
            function downloadUpgradeOutput() {
                const ta = document.getElementById('upgradeOutput');
                if (!ta) return;
                const config = ta.value || '';
                if (!config) { alert('No translated configuration available!'); return; }
                const targetDevice = (document.getElementById('upgradeTargetDevice') || {}).value || 'device';
                const targetVersion = (document.getElementById('upgradeTargetVersion') || {}).value || '7.x';
                const ts = new Date().toISOString().split('T')[0];

                // Extract metadata from config for saving
                let deviceName = '';
                let loopbackIp = '';

                const extractSystemIdentity = (cfg) => {
                    const text = cfg || '';
                    const m = text.match(/\/system identity[\s\S]*?\n\s*set\s+name=("[^"]+"|[^\s\r\n]+)/i);
                    if (!m) return '';
                    return String(m[1] || '').trim().replace(/^"|"$/g, '');
                };
                const extractLoopback = (cfg) => {
                    const text = cfg || '';
                    const m = text.match(/^\s*add\s+address=([0-9.]+)(?:\/[0-9]+)?[^\n]*\binterface=loop0\b/m);
                    if (m) return m[1];
                    const rid = text.match(/\brouter-id=(\d+\.\d+\.\d+\.\d+)\b/m);
                    return rid ? rid[1] : '';
                };

                deviceName = extractSystemIdentity(config) || `upgraded-${targetDevice}`;
                loopbackIp = extractLoopback(config);

                // Get source device info if available (from uploaded file)
                const uploadedFileName = document.getElementById('fileName')?.textContent || '';
                let sourceDevice = 'unknown';
                if (uploadedFileName) {
                    // Try to extract device from filename
                    const deviceMatch = uploadedFileName.match(/(ccr\d+|rb\d+|mt\d+|mtrb\d+)/i);
                    if (deviceMatch) {
                        sourceDevice = deviceMatch[1].toLowerCase();
                    }
                }

                // Download the file
                const blob = new Blob([config.replace(/\r?\n/g, '\n')], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `upgraded-${targetDevice}-v${targetVersion}-${ts}.rsc`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 0);

                // Save to completed configs database
                if (typeof saveCompletedConfig === 'function') {
                    const configData = {
                        config_type: 'upgrade',
                        device_name: deviceName || `upgraded-${targetDevice}`,
                        device_type: targetDevice,
                        customer_code: '',
                        loopback_ip: loopbackIp,
                        routeros_version: targetVersion,
                        config_content: config,
                        created_by: 'user'
                    };

                    // Extract additional metadata
                    const metadata = {
                        source_device: sourceDevice,
                        target_device: targetDevice,
                        source_version: 'unknown', // Could extract from original config if available
                        target_version: targetVersion,
                        upgrade_timestamp: new Date().toISOString()
                    };
                    configData.metadata = metadata;

                    saveCompletedConfig(configData);
                } else {
                    console.warn('[UPGRADE] saveCompletedConfig function not available');
                }
            }

            function downloadConfig() {
                const config = document.getElementById('output').value;
                if (!config) {
                    alert('Please generate a configuration first!');
                    return;
                }

                const baseName = getTowerBaseFilename();

                const blob = new Blob([config], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${baseName}.rsc`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }

            function getTowerBaseFilename() {
                const siteName = (document.getElementById('siteName')?.value || 'mikrotik').trim() || 'mikrotik';
                const targetDevice = document.getElementById('targetDevice')?.value || 'ccr2004';
                const timestamp = new Date().toISOString().split('T')[0];
                return `${siteName}-${targetDevice}-${timestamp}`;
            }

            async function fetchPortMapFromConfig(configText) {
                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                const response = await fetch(`${apiBase}/extract-port-map`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ config_content: configText })
                });
                const data = await response.json();
                if (!response.ok) {
                    throw new Error(data.error || 'Failed to extract port map');
                }
                return data.port_map_text || '';
            }

            async function downloadPortMap() {
                const config = document.getElementById('output').value;
                if (!config) {
                    alert('Please generate a configuration first!');
                    return;
                }
                try {
                    const portMap = await fetchPortMapFromConfig(config);
                    const baseName = getTowerBaseFilename();
                    const blob = new Blob([portMap], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${baseName}-port-map.txt`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (err) {
                    alert(`Port map download failed: ${err.message}`);
                }
            }

            async function downloadConfigZip() {
                const config = document.getElementById('output').value;
                if (!config) {
                    alert('Please generate a configuration first!');
                    return;
                }
                if (!window.JSZip) {
                    alert('JSZip is not available. Please refresh and try again.');
                    return;
                }
                try {
                    const portMap = await fetchPortMapFromConfig(config);
                    const baseName = getTowerBaseFilename();
                    const zip = new JSZip();
                    zip.file(`${baseName}.rsc`, config);
                    zip.file(`${baseName}-port-map.txt`, portMap);
                    const blob = await zip.generateAsync({ type: 'blob' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${baseName}.zip`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                } catch (err) {
                    alert(`Zip download failed: ${err.message}`);
                }
            }

            function normalizeConfigOrder(config) {
                // Define the correct RouterOS configuration order based on the production config
                const sectionOrder = [
                    '/interface bridge',
                    '/interface ethernet',
                    '/interface vlan',
                    '/interface vpls',
                    '/interface lte apn',
                    '/interface wireless security-profiles',
                    '/ip dhcp-server option',
                    '/ip dhcp-server option sets',
                    '/ip pool',
                    '/ip dhcp-server',
                    '/port',
                    '/queue simple',
                    '/queue type',
                    '/queue tree',
                    '/routing bgp template',
                    '/routing ospf instance',
                    '/routing ospf area',
                    '/snmp community',
                    '/system logging action',
                    '/user group',
                    '/interface bridge port',
                    '/ip firewall connection tracking',
                    '/ip settings',
                    '/ipv6 settings',
                    '/interface ovpn-server server',
                    '/ip address',
                    '/ip dhcp-server lease',
                    '/ip dhcp-server network',
                    '/ip dns',
                    '/ip firewall address-list',
                    '/ip firewall filter',
                    '/ip firewall mangle',
                    '/ip firewall nat',
                    '/ip firewall raw',
                    '/ip firewall service-port',
                    '/ip route',
                    '/ip service',
                    '/mpls interface',
                    '/mpls ldp',
                    '/mpls ldp interface',
                    '/mpls ldp accept-filter',
                    '/mpls ldp advertise-filter',
                    '/radius',
                    '/routing bfd configuration',
                    '/routing bgp connection',
                    '/routing filter rule',
                    '/routing ospf interface-template',
                    '/snmp',
                    '/system clock',
                    '/system identity',
                    '/system logging',
                    '/system note',
                    '/system ntp client',
                    '/system ntp client servers',
                    '/system resource irq rps',
                    '/system routerboard settings',
                    '/system scheduler',
                    '/system script',
                    '/system watchdog',
                    '/user aaa'
                ];

                // Split config into sections
                const sections = {};
                const lines = config.split('\n');
                let currentSection = null;
                let currentContent = [];

                lines.forEach(line => {
                    if (line.startsWith('/')) {
                        // Save previous section
                        if (currentSection && currentContent.length > 0) {
                            sections[currentSection] = currentContent.join('\n');
                        }
                        // Start new section
                        currentSection = line.trim();
                        currentContent = [line];
                    } else if (currentSection) {
                        currentContent.push(line);
                    } else {
                        // Header comments before first section
                        if (!sections['_header']) sections['_header'] = [];
                        sections['_header'].push(line);
                    }
                });

                // Save last section
                if (currentSection && currentContent.length > 0) {
                    sections[currentSection] = currentContent.join('\n');
                }

                // Rebuild config in correct order
                let orderedConfig = '';

                // Add header first
                if (sections['_header']) {
                    orderedConfig += sections['_header'].join('\n') + '\n';
                }

                // Add sections in RouterOS order
                sectionOrder.forEach(section => {
                    if (sections[section]) {
                        orderedConfig += sections[section] + '\n';
                    }
                });

                // Add any remaining sections not in the standard order
                Object.keys(sections).forEach(section => {
                    if (section !== '_header' && !sectionOrder.includes(section)) {
                        orderedConfig += sections[section] + '\n';
                    }
                });

                return orderedConfig.trim();
            }

            // Live validation function - runs on input events
            function performLiveValidation() {
                const results = [];
                const validationList = document.getElementById('validationList');
                const validationResults = document.getElementById('validationResults');

                if (!validationList || !validationResults) return;

                // Clear previous results
                validationList.innerHTML = '';

                // Validate required fields
                const siteName = document.getElementById('siteName')?.value.trim();
                const routerId = document.getElementById('routerId')?.value.trim();
                const targetDevice = document.getElementById('targetDevice')?.value;

                if (!siteName) {
                    results.push({ type: 'error', message: 'Site Name is required' });
                }

                if (!routerId) {
                    results.push({ type: 'error', message: 'Router ID is required' });
                } else if (routerId && !isValidIP(routerId)) {
                    results.push({ type: 'error', message: 'Router ID must be a valid IP address' });
                }

                if (!targetDevice) {
                    results.push({ type: 'warning', message: 'Target device selection recommended' });
                }

                // Validate IP addresses using validateAllIPs (which includes new port/uplink structure)
                const ipErrors = validateAllIPs();
                ipErrors.forEach(error => {
                    results.push({ type: 'error', message: error });
                });

                // Validate Site Coordinates
                const siteLatitude = document.getElementById('siteLatitude')?.value.trim();
                const siteLongitude = document.getElementById('siteLongitude')?.value.trim();
                if (siteLatitude && !isValidCoordinate(siteLatitude, 'latitude')) {
                    results.push({ type: 'error', message: 'Site Latitude must be a valid coordinate (-90 to 90)' });
                }
                if (siteLongitude && !isValidCoordinate(siteLongitude, 'longitude')) {
                    results.push({ type: 'error', message: 'Site Longitude must be a valid coordinate (-180 to 180)' });
                }

                // Validate uplinks (OLD STRUCTURE: #uplinks)
                const uplinkElements = document.querySelectorAll('#uplinks .uplink-item:not(#uplinkTemplate)');
                uplinkElements.forEach((element, index) => {
                    const ip = element.querySelector('input[id*="Ip"]')?.value;
                    const port = element.querySelector('select[id*="NewPort"]')?.value;

                    if (ip && !isValidIPWithCIDR(ip)) {
                        results.push({ type: 'error', message: `Uplink ${index + 1} IP must be in CIDR format` });
                    }

                    if (ip && !port) {
                        results.push({ type: 'error', message: `Uplink ${index + 1} port selection required` });
                    }
                });

                // Validate port/uplink configs (NEW STRUCTURE: #portConfigs)
                const portUplinkElements = document.querySelectorAll('#portConfigs .uplink-item:not(#portUplinkTemplate)');
                portUplinkElements.forEach((element, index) => {
                    const portType = element.querySelector('select[name="portUplinkType"]')?.value;
                    const ip = element.querySelector('input[name="portUplinkIp"]')?.value?.trim();
                    const port = element.querySelector('select[name="portUplinkPort"]')?.value ||
                        element.querySelector('select[name="portName"]')?.value;

                    // For routed ports, IP and port are required
                    if (portType === 'routed') {
                        if (ip && !isValidIPWithCIDR(ip)) {
                            results.push({ type: 'error', message: `Port/Uplink ${index + 1} IP must be in CIDR format` });
                        }
                        if (ip && !port) {
                            results.push({ type: 'error', message: `Port/Uplink ${index + 1} port selection required` });
                        }
                    }
                });

                // Validate keys and settings
                const sharedKey = document.getElementById('sharedKey')?.value.trim();
                const snmpCommunity = document.getElementById('snmpCommunity')?.value.trim();
                const dhcpSecret = document.getElementById('dhcpSecret')?.value.trim();

                if (!sharedKey) {
                    results.push({ type: 'error', message: 'Shared Key is required for OSPF/BGP' });
                }

                if (!snmpCommunity) {
                    results.push({ type: 'warning', message: 'SNMP Community recommended for monitoring' });
                }

                if (document.getElementById('enableDHCP')?.checked && !dhcpSecret) {
                    results.push({ type: 'error', message: 'DHCP Secret required when DHCP is enabled' });
                }

                // Display results
                results.forEach(result => {
                    const li = document.createElement('li');
                    li.style.color = result.type === 'error' ? '#f44336' : '#ff9800';
                    li.textContent = `${result.type.toUpperCase()}: ${result.message}`;
                    validationList.appendChild(li);
                });

                if (results.length === 0) {
                    const li = document.createElement('li');
                    li.style.color = '#4caf50';
                    li.textContent = 'SUCCESS: Configuration validation passed';
                    validationList.appendChild(li);
                }

                validationResults.style.display = 'block';
            }

            function validateConfiguration() {
                performLiveValidation();

                // Auto-update compliance checklist
                updateComplianceStatus();
            }
            function updateComplianceStatus() {
                // Auto-check RFC compliance items based on configuration
                const complianceSecurity = document.getElementById('complianceSecurity');
                const complianceRouting = document.getElementById('complianceRouting');
                const complianceNAT = document.getElementById('complianceNAT');
                const complianceDHCP = document.getElementById('complianceDHCP');
                const complianceSNMP = document.getElementById('complianceSNMP');
                const complianceLogging = document.getElementById('complianceLogging');
                const complianceNTP = document.getElementById('complianceNTP');

                // RFC Security: Always true - RFC baseline firewall rules are always applied
                if (complianceSecurity) {
                    complianceSecurity.checked = true;
                }

                // RFC Routing: Check if OSPF/BGP is configured
                if (complianceRouting) {
                    const routerId = document.getElementById('routerId').value.trim();
                    const ospfArea = document.getElementById('ospfArea').value;
                    complianceRouting.checked = routerId && ospfArea;
                }

                // RFC NAT: Check if NAT rules will be generated
                if (complianceNAT) {
                    const natPublicIP = document.getElementById('natPublicIP').value.trim();
                    const lanBridgeIP = document.getElementById('lanBridgeIP').value.trim();
                    complianceNAT.checked = natPublicIP && lanBridgeIP;
                }

                // RFC DHCP: Check if DHCP is enabled and configured
                if (complianceDHCP) {
                    const enableDHCP = document.getElementById('enableDHCP').checked;
                    const dhcpSecret = document.getElementById('dhcpSecret').value.trim();
                    complianceDHCP.checked = enableDHCP && dhcpSecret;
                }

                // RFC SNMP: Check if SNMP community is set
                if (complianceSNMP) {
                    const snmpCommunity = document.getElementById('snmpCommunity').value.trim();
                    complianceSNMP.checked = !!snmpCommunity;
                }

                // RFC Logging: Always true - RFC baseline logging is always applied
                if (complianceLogging) {
                    complianceLogging.checked = true;
                }

                // RFC NTP: Always true - RFC baseline NTP is always applied
                if (complianceNTP) {
                    complianceNTP.checked = true;
                }
            }

            function isValidIP(ip) {
                const ipRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
                return ipRegex.test(ip);
            }

            function isValidIPWithCIDR(ip) {
                const parts = ip.split('/');
                if (parts.length !== 2) return false;

                const ipPart = parts[0];
                const cidrPart = parseInt(parts[1]);

                return isValidIP(ipPart) && cidrPart >= 0 && cidrPart <= 32;
            }

            function isNetworkOrBroadcastAddress(ipCidr) {
                if (!isValidIPWithCIDR(ipCidr)) return false;

                const [ip, cidr] = ipCidr.split('/');
                const cidrNum = parseInt(cidr);
                const ipParts = ip.split('.').map(Number);

                // Convert IP to 32-bit integer
                const ipInt = (ipParts[0] << 24) + (ipParts[1] << 16) + (ipParts[2] << 8) + ipParts[3];

                // Calculate network mask
                const mask = (0xFFFFFFFF << (32 - cidrNum)) >>> 0;

                // Calculate network address
                const networkAddress = (ipInt & mask) >>> 0;

                // Calculate broadcast address
                const broadcastAddress = (networkAddress | (~mask)) >>> 0;

                // Check if the IP is network or broadcast address
                return ipInt === networkAddress || ipInt === broadcastAddress;
            }

            function isValidCoordinate(coord, type) {
                const num = parseFloat(coord);
                if (isNaN(num)) return false;

                if (type === 'latitude') {
                    return num >= -90 && num <= 90;
                } else if (type === 'longitude') {
                    return num >= -180 && num <= 180;
                }
                return false;
            }
            function validateAllIPs() {
                const errors = [];

                // Validate Router ID
                const routerId = document.getElementById('routerId').value.trim();
                if (routerId && !isValidIP(routerId)) {
                    errors.push('Router ID: Invalid IP address format');
                }

                // Validate LAN Bridge IP
                const lanBridgeIP = document.getElementById('lanBridgeIP').value.trim();
                if (lanBridgeIP && !isValidIPWithCIDR(lanBridgeIP)) {
                    errors.push('LAN Bridge IP: Invalid IP/CIDR format');
                } else if (lanBridgeIP && isNetworkOrBroadcastAddress(lanBridgeIP)) {
                    errors.push('LAN Bridge IP: Cannot use network or broadcast address');
                }

                // Validate NAT Public IP
                const natPublicIP = document.getElementById('natPublicIP').value.trim();
                if (natPublicIP && !isValidIP(natPublicIP)) {
                    errors.push('NAT Public IP: Invalid IP address format');
                }

                // Validate LDP Transport
                const ldpTransport = document.getElementById('ldpTransport').value.trim();
                if (ldpTransport && !isValidIP(ldpTransport)) {
                    errors.push('LDP Transport: Invalid IP address format');
                }

                // Validate Site Coordinates
                const siteLatitude = document.getElementById('siteLatitude').value.trim();
                const siteLongitude = document.getElementById('siteLongitude').value.trim();
                if (siteLatitude && !isValidCoordinate(siteLatitude, 'latitude')) {
                    errors.push('Site Latitude: Invalid coordinate (-90 to 90)');
                }
                if (siteLongitude && !isValidCoordinate(siteLongitude, 'longitude')) {
                    errors.push('Site Longitude: Invalid coordinate (-180 to 180)');
                }

                // Validate Uplink IPs (OLD STRUCTURE: #uplinks)
                const uplinkIPs = document.querySelectorAll('#uplinks input[id*="Ip"]');
                uplinkIPs.forEach((input, index) => {
                    const ip = input.value.trim();
                    if (ip && !isValidIPWithCIDR(ip)) {
                        errors.push(`Uplink ${index + 1}: Invalid IP/CIDR format`);
                    } else if (ip && isNetworkOrBroadcastAddress(ip)) {
                        errors.push(`Uplink ${index + 1}: Cannot use network or broadcast address`);
                    }
                });

                // Validate Uplink IPs (NEW STRUCTURE: #portConfigs portUplinkIp)
                const newUplinkIPs = document.querySelectorAll('#portConfigs input[name="portUplinkIp"]');
                newUplinkIPs.forEach((input, index) => {
                    const ip = input.value.trim();
                    if (ip && !isValidIPWithCIDR(ip)) {
                        errors.push(`Port/Uplink ${index + 1}: Invalid IP/CIDR format`);
                    } else if (ip && isNetworkOrBroadcastAddress(ip)) {
                        errors.push(`Port/Uplink ${index + 1}: Cannot use network or broadcast address`);
                    }
                });

                // Validate Static Customer IPs
                const customerRanges = document.querySelectorAll('#staticCustomers input[name="customerRange"]');
                customerRanges.forEach((input, index) => {
                    const range = input.value.trim();
                    if (range && !isValidIPWithCIDR(range)) {
                        errors.push(`Static Customer ${index + 1}: Invalid IP/CIDR format`);
                    } else if (range && isNetworkOrBroadcastAddress(range)) {
                        errors.push(`Static Customer ${index + 1}: Cannot use network or broadcast address`);
                    }
                });

                // Validate VLAN Subnets
                const vlan3000Subnet = document.getElementById('vlan3000Subnet').value.trim();
                if (vlan3000Subnet && !isValidIPWithCIDR(vlan3000Subnet)) {
                    errors.push('VLAN 3000 Subnet: Invalid IP/CIDR format');
                } else if (vlan3000Subnet && isNetworkOrBroadcastAddress(vlan3000Subnet)) {
                    errors.push('VLAN 3000 Subnet: Cannot use network or broadcast address');
                }

                const vlan4000Subnet = document.getElementById('vlan4000Subnet').value.trim();
                if (vlan4000Subnet && !isValidIPWithCIDR(vlan4000Subnet)) {
                    errors.push('VLAN 4000 Subnet: Invalid IP/CIDR format');
                } else if (vlan4000Subnet && isNetworkOrBroadcastAddress(vlan4000Subnet)) {
                    errors.push('VLAN 4000 Subnet: Cannot use network or broadcast address');
                }

                return errors;
            }

            function generateConfigHeader(siteName, targetDevice, currentDevice, currentRouterOS, targetRouterOS, deviceConfig) {
                const timestamp = new Date().toISOString();
                const date = timestamp.split('T')[0];
                const time = timestamp.split('T')[1].split('.')[0];

                let header = `# ========================================\n`;
                header += `# NextLink MikroTik Configuration Generator\n`;
                header += `# ========================================\n`;
                header += `# Site: ${siteName}\n`;
                header += `# Target Device: ${deviceConfig.name}\n`;
                if (currentDevice) {
                    header += `# Upgrade From: ${DEVICE_CONFIGS[currentDevice]?.name || currentDevice}\n`;
                }
                if (currentRouterOS && targetRouterOS) {
                    header += `# RouterOS Upgrade: ${currentRouterOS}  ${targetRouterOS}\n`;
                }
                header += `# Generated: ${date} ${time} UTC\n`;
                header += `# Compliance: NextLink Standards\n`;
                header += `# Features: ${deviceConfig.features.join(', ')}\n`;
                header += `# Max Uplinks: ${deviceConfig.maxUplinks}\n`;
                header += `# Ports: ${deviceConfig.ports.length} ethernet, ${deviceConfig.sfpPorts.length} SFP+\n`;
                header += `# ========================================\n\n`;

                // Add RFC compliance checklist results
                header += `# RFC COMPLIANCE CHECKLIST:\n`;
                const complianceItems = [
                    ' RFC Baseline: Standard firewall rules applied',
                    ' RFC Address Lists: EOIP-ALLOW, managerIP, BGP-ALLOW, SNMP configured',
                    ' RFC System Hardening: Services locked down, watchdog enabled',
                    ' RFC Logging: Remote syslog configured',
                    ' RFC SNMP: Community strings and access controls set',
                    ' RFC NTP: Time synchronization configured',
                    ' RFC RADIUS: DHCP authentication servers configured',
                    ' RFC User Management: AAA and group policies hardened',
                    ' RFC DHCP Options: Vendor-specific options configured',
                    ' RFC MPLS: LDP accept/advertise filters (if enabled)',
                    ' Dynamic Features: User-selected configurations applied',
                    ' Device-Specific: Optimizations for target device applied'
                ];

                complianceItems.forEach(item => {
                    header += `# ${item}\n`;
                });
                header += `# ========================================\n\n`;

                return header;
            }

            function generateDeviceSpecificConfig(config, deviceConfig, targetDevice) {
                // Add device-specific optimizations
                if (targetDevice === 'rb1009' || targetDevice === 'rb2011') {
                    // Basic devices - simpler configuration
                    config += `# Basic device optimization\n`;
                    config += `/system resource\nset cpu-frequency=auto\n`;
                } else if (targetDevice === 'ccr1036') {
                    // High-performance device
                    config += `# CCR1036 optimization\n`;
                    config += `/system resource\nset cpu-frequency=auto\nset cpu-count=36\n`;
                } else if (targetDevice === 'rb5009' || targetDevice === 'ccr2004' || targetDevice === 'ccr2116' || targetDevice === 'ccr2216') {
                    // ARM-based devices
                    config += `# ARM device optimization\n`;
                    config += `/system resource\nset cpu-frequency=auto\n`;
                }

                return config;
            }
            // RFC Compliance Configuration Templates
            const RFC_COMPLIANCE_CONFIG = {
                // Standard Firewall Address Lists (always required) - /ip firewall address-list
                firewallAddressLists: {
                    'WALLED-GARDEN': [
                        '142.147.112.3', '142.147.112.19', '107.178.15.27', '142.147.112.12', '67.219.126.2'
                    ],
                    'NAT-EXEMPT-DST': [
                        '142.147.112.3', '142.147.112.19', '107.178.15.0/27', '107.178.5.97'
                    ],
                    'NTP': [
                        '52.128.59.240', '52.128.59.241', '52.128.59.242', '52.128.59.243'
                    ],
                    'NETFLIX': [
                        '69.53.224.0/19', '108.175.32.0/20', '192.173.64.0/18', '198.38.96.0/19', '198.45.48.0/20',
                        '208.75.76.0/22', '24.220.183.0/24', '216.168.119.0/24', '23.246.0.0/20', '173.246.157.0/24',
                        '37.77.184.0/23', '64.140.112.0/24', '66.97.254.0/24', '185.2.223.0/24'
                    ],
                    'Voip-Servers': ['107.178.15.4'],
                    'EOIP-ALLOW': ['10.0.0.0/8'],
                    'managerIP': [
                        '192.168.128.0/21', '107.178.5.97', '198.100.53.0/25', '143.55.62.143',
                        '142.147.127.2', '132.147.132.6', '67.219.122.201', '10.249.1.26', '10.0.0.0/8'
                    ],
                    'BGP-ALLOW': ['10.0.0.0/8'],
                    'SNMP': [
                        '143.55.35.47', '107.178.15.15', '107.178.15.162', '142.147.112.4', '142.147.124.26',
                        '107.178.5.97', '67.219.126.240/28', '198.100.53.120', '143.55.62.143', '132.147.138.2',
                        '132.147.138.0', '132.147.138.6', '132.147.138.23', '132.147.138.29', '132.147.138.30',
                        '132.147.138.31', '143.55.37.40', '143.55.37.41', '132.147.132.24', '198.100.49.99',
                        '132.147.132.26', '204.11.183.126', '173.215.67.124', '132.147.138.3', '132.147.138.7',
                        '132.147.138.21', '132.147.138.26'
                    ],
                    'bgp-networks': [
                        // This will be populated dynamically with UNAUTH, CGNAT_PUBLIC, CGNAT_PRIVATE IPs
                    ]
                },

                // MPLS LDP Filters (standard prefixes)
                mplsLdpFilters: {
                    acceptDeny: [
                        '10.2.0.14/32', '10.2.0.21/32', '10.2.0.107/32', '10.2.0.108/32', '10.17.0.10/32',
                        '10.17.0.11/32', '10.30.0.9/32', '10.240.0.3/32', '10.243.0.9/32', '10.248.0.220/32',
                        '10.249.0.220/32', '10.0.0.87/32', '10.9.0.88/32', '10.254.247.9/32'
                    ],
                    acceptAllow: [
                        '10.2.0.10/32', '10.0.0.0/24', '10.0.1.0/24', '10.1.0.0/24', '10.2.0.0/24', '10.3.0.0/24',
                        '10.4.0.0/24', '10.4.3.0/24', '10.5.0.0/24', '10.6.0.0/24', '10.7.0.0/24', '10.7.250.0/24',
                        '10.7.254.0/24', '10.8.0.0/24', '10.9.0.0/24', '10.9.1.0/24', '10.9.2.0/24', '10.10.0.0/24',
                        '10.11.0.0/24', '10.12.0.0/24', '10.13.0.0/24', '10.14.0.0/24', '10.15.0.0/24', '10.16.0.0/24',
                        '10.17.0.0/24', '10.17.16.0/24', '10.17.18.0/24', '10.17.31.0/24', '10.17.48.0/24',
                        '10.18.0.0/24', '10.18.2.0/24', '10.19.0.0/24', '10.21.0.0/24', '10.22.0.0/24', '10.25.0.0/24',
                        '10.26.0.0/24', '10.27.0.0/24', '10.30.0.0/24', '10.32.0.0/24', '10.33.0.0/24', '10.34.0.0/24',
                        '10.35.0.0/24', '10.36.0.0/24', '10.37.0.0/24', '10.39.0.0/24', '10.45.252.0/24', '10.47.0.0/24',
                        '10.53.252.0/22', '10.254.243.0/24', '10.243.0.0/24', '10.54.0.0/22', '10.250.0.0/24',
                        '10.250.40.0/22', '10.241.0.0/24', '10.241.64.0/22', '10.254.245.0/24',
                        '10.254.249.0/24', '10.249.0.0/24', '10.249.7.0/24', '10.249.180.0/22',
                        '10.254.247.0/24', '10.247.0.0/24', '10.247.13.0/24', '10.247.72.0/24',
                        '10.247.147.0/24', '10.247.187.0/24', '10.247.64.0/22', '10.254.248.0/24',
                        '10.248.0.0/24', '10.248.32.0/24', '10.248.36.0/24', '10.248.86.0/24', '10.248.208.0/22'
                    ]
                }
            };
            // RFC Compliance Functions
            function verifyFirewallAddressLists() {
                // Expected address lists from user specification
                const expectedAddressLists = {
                    'EOIP-ALLOW': ['10.0.0.0/8'],
                    'managerIP': [
                        '192.168.128.0/21', '107.178.5.97', '198.100.53.0/25', '143.55.62.143',
                        '142.147.127.2', '132.147.132.6', '67.219.122.201', '10.249.1.26', '10.0.0.0/8'
                    ],
                    'BGP-ALLOW': ['10.0.0.0/8'],
                    'SNMP': [
                        '143.55.35.47', '107.178.15.15', '107.178.15.162', '142.147.112.4', '142.147.124.26',
                        '107.178.5.97', '67.219.126.240/28', '198.100.53.120', '143.55.62.143', '132.147.138.2',
                        '132.147.138.0', '132.147.138.6', '132.147.138.23', '132.147.138.29', '132.147.138.30',
                        '132.147.138.31', '143.55.37.40', '143.55.37.41', '132.147.132.24', '198.100.49.99',
                        '132.147.132.26', '204.11.183.126', '173.215.67.124', '132.147.138.3', '132.147.138.7',
                        '132.147.138.21', '132.147.138.26'
                    ]
                };

                // Check if our configuration matches
                const configAddressLists = RFC_COMPLIANCE_CONFIG.firewallAddressLists;
                let allMatch = true;
                let report = 'Address List Verification:\n\n';

                Object.entries(expectedAddressLists).forEach(([listName, expectedAddresses]) => {
                    if (configAddressLists[listName]) {
                        const configAddresses = configAddressLists[listName];
                        const match = expectedAddresses.every(addr => configAddresses.includes(addr)) &&
                            expectedAddresses.length === configAddresses.length;

                        report += `${listName}: ${match ? ' MATCH' : ' MISMATCH'}\n`;
                        report += `  Expected: ${expectedAddresses.length} addresses\n`;
                        report += `  Config: ${configAddresses.length} addresses\n`;

                        if (!match) {
                            allMatch = false;
                            report += `  Missing: ${expectedAddresses.filter(addr => !configAddresses.includes(addr)).join(', ')}\n`;
                        }
                    } else {
                        report += `${listName}:  MISSING\n`;
                        allMatch = false;
                    }
                    report += '\n';
                });

                report += `Overall Status: ${allMatch ? ' ALL ADDRESS LISTS CORRECT' : ' ISSUES FOUND'}`;
                return report;
            }

            function verifyFirewallRules() {
                // Expected firewall filter rules from user specification
                const expectedFilterRules = {
                    input: [
                        'rem [find chain=input dynamic=no]',
                        'add action=accept chain=input comment="ALLOW EST REL" connection-state=established,related,untracked',
                        'add action=accept chain=input comment="ALLOW MT NEIGHBOR" dst-port=5678 protocol=udp',
                        'add action=accept chain=input comment="ALLOW MAC TELNET" dst-port=20561 protocol=udp',
                        'add action=accept chain=input comment="ALLOW IGMP" protocol=igmp',
                        'add action=accept chain=input comment="ALLOW ICMP" protocol=icmp',
                        'add action=accept chain=input comment="ALLOW DHCPv4" protocol=udp dst-port=67',
                        'add action=accept chain=input comment="ALLOW DHCPv6" protocol=udp dst-port=547',
                        'add action=accept chain=input comment="ALLOW OSPF" protocol=ospf',
                        'add action=accept chain=input comment="ALLOW LDP" dst-port=646 protocol=tcp',
                        'add action=accept chain=input comment="ALLOW LDP" dst-port=646 protocol=udp',
                        'add action=accept chain=input comment="ALLOW MANAGER IP" src-address-list=managerIP',
                        'add action=accept chain=input comment="ALLOW BGP" protocol=tcp dst-port=179 src-address-list=BGP-ALLOW',
                        'add action=accept chain=input comment="ALLOW EOIP" protocol=gre src-address-list=EOIP-ALLOW',
                        'add action=accept chain=input comment="ALLOW SNMP" dst-port=161 protocol=udp src-address-list=SNMP',
                        'add action=drop chain=input comment="DROP INPUT" log=no'
                    ],
                    raw: [
                        'rem [find dynamic=no]',
                        'add action=drop chain=prerouting comment="DROP BAD UDP" port=0 protocol=udp'
                    ],
                    forward: [
                        'rem [find where chain=forward dynamic=no]',
                        'add action=accept chain=forward comment="BGP Accept" dst-address=10.0.0.0/8 dst-port=179 protocol=tcp src-address=10.0.0.0/8',
                        'add action=accept chain=forward comment="GRE Accept" dst-address=10.0.0.0/8 protocol=gre src-address=10.0.0.0/8',
                        'add action=drop chain=forward comment="unauth drop rule" dst-address-list=!WALLED-GARDEN src-address-list=unauth',
                        'add action=fasttrack-connection chain=forward connection-state=established,related,untracked hw-offload=yes',
                        'add action=accept chain=forward connection-state=established,related,untracked'
                    ]
                };

                const expectedNATRules = [
                    'rem [find]',
                    'add chain=dstnat protocol=tcp dst-port=5022 action=redirect to-ports=22',
                    'add action=dst-nat chain=dstnat comment="unauth proxy rule" dst-address-list=!WALLED-GARDEN dst-port=80 protocol=tcp src-address-list=unauth to-addresses=107.178.15.27 to-ports=3128'
                ];

                let report = 'Firewall Rules Verification:\n\n';
                let allMatch = true;

                // Test generation (using placeholder - actual secret should come from environment/config)
                let testConfig = '';
                testConfig = addRFCComplianceBaseline(testConfig, '10.0.0.1', 'FBZ1yYdphf', 'PLACEHOLDER_SECRET', false, '10.100.0.0/22', '100.64.0.0/10', '10.200.0.0/22');

                // Check Input Chain
                const inputSection = testConfig.split('# FIREWALL INPUT CHAIN')[1];
                if (inputSection) {
                    const inputContent = inputSection.split('# FIREWALL RAW CHAIN')[0];
                    const inputLines = inputContent.split('\n').filter(line => line.trim() && !line.startsWith('#'));

                    report += `INPUT CHAIN: ${inputLines.length} rules generated\n`;
                    expectedFilterRules.input.forEach((expectedRule, index) => {
                        const found = inputLines.some(line => line.includes(expectedRule.split(' ')[2])); // Check by action
                        report += `  Rule ${index + 1}: ${found ? '' : ''} ${expectedRule.split(' ')[2]}\n`;
                        if (!found) allMatch = false;
                    });
                } else {
                    report += 'INPUT CHAIN:  NOT FOUND\n';
                    allMatch = false;
                }

                // Check Raw Chain
                const rawSection = testConfig.split('# FIREWALL RAW CHAIN')[1];
                if (rawSection) {
                    const rawContent = rawSection.split('# FIREWALL FORWARD CHAIN')[0];
                    const rawLines = rawContent.split('\n').filter(line => line.trim() && !line.startsWith('#'));

                    report += `\nRAW CHAIN: ${rawLines.length} rules generated\n`;
                    expectedFilterRules.raw.forEach((expectedRule, index) => {
                        const found = rawLines.some(line => line.includes(expectedRule.split(' ')[2])); // Check by action
                        report += `  Rule ${index + 1}: ${found ? '' : ''} ${expectedRule.split(' ')[2]}\n`;
                        if (!found) allMatch = false;
                    });
                } else {
                    report += '\nRAW CHAIN:  NOT FOUND\n';
                    allMatch = false;
                }

                // Check Forward Chain
                const forwardSection = testConfig.split('# FIREWALL FORWARD CHAIN')[1];
                if (forwardSection) {
                    const forwardContent = forwardSection.split('# FIREWALL MANGLE')[0];
                    const forwardLines = forwardContent.split('\n').filter(line => line.trim() && !line.startsWith('#'));

                    report += `\nFORWARD CHAIN: ${forwardLines.length} rules generated\n`;
                    expectedFilterRules.forward.forEach((expectedRule, index) => {
                        const found = forwardLines.some(line => line.includes(expectedRule.split(' ')[2])); // Check by action
                        report += `  Rule ${index + 1}: ${found ? '' : ''} ${expectedRule.split(' ')[2]}\n`;
                        if (!found) allMatch = false;
                    });
                } else {
                    report += '\nFORWARD CHAIN:  NOT FOUND\n';
                    allMatch = false;
                }

                // Check NAT Rules
                const natSection = testConfig.split('# FIREWALL NAT')[1];
                if (natSection) {
                    const natContent = natSection.split('# SYSTEM HARDENING')[0];
                    const natLines = natContent.split('\n').filter(line => line.trim() && !line.startsWith('#'));

                    report += `\nNAT RULES: ${natLines.length} rules generated\n`;
                    expectedNATRules.forEach((expectedRule, index) => {
                        const found = natLines.some(line => line.includes(expectedRule.split(' ')[2])); // Check by action
                        report += `  Rule ${index + 1}: ${found ? '' : ''} ${expectedRule.split(' ')[2]}\n`;
                        if (!found) allMatch = false;
                    });
                } else {
                    report += '\nNAT RULES:  NOT FOUND\n';
                    allMatch = false;
                }

                report += `\nOverall Status: ${allMatch ? ' ALL FIREWALL RULES CORRECT' : ' ISSUES FOUND'}`;
                return report;
            }
            function addRFCComplianceBaseline(config, routerId, snmpCommunity, dhcpSecret, enableMPLS, unauthRange, cgnatRange, vlan4000Range) {
                // Variables section
                config += `# RFC COMPLIANCE BASELINE CONFIGURATION\n`;
                config += `# Variables\n`;
                config += `:global LoopIP [/ip address get [find interface=loop0] address]\n`;
                config += `:global curDate [/system clock get date]\n`;
                config += `:global curTime [/system clock get time]\n`;
                config += `:global CurDT ($curDate . " " . $curTime)\n\n`;

                // IP Services Hardening
                config += `# IP SERVICES - RFC Compliance Hardening\n`;
                config += `/ip service\n`;
                config += `set telnet disabled=yes port=5023\n`;
                config += `set ftp disabled=yes port=5021\n`;
                config += `set www disabled=yes port=1234\n`;
                config += `set api disabled=yes\n`;
                config += `set api-ssl disabled=yes\n`;
                config += `set www-ssl disabled=no port=443\n`;
                config += `set winbox port=8291 address="" disabled=no\n`;
                config += `set ssh port=5022 address="" disabled=no\n\n`;

                // DNS Configuration
                config += `# DNS Configuration\n`;
                config += `/ip dns\n`;
                config += `set servers=${getDNSList()}\n\n`;

                // System Clock and NTP
                config += `# CLOCK AND NTP\n`;
                // (Removed duplicated user account creation block for MPLS output)
                config += `\n`;

                // Firewall Input Chain (RFC Standard)
                config += `# FIREWALL INPUT CHAIN - RFC Standard\n`;
                config += `/ip firewall filter\n`;
                config += `rem [find chain=input dynamic=no]\n`;
                config += `add action=accept chain=input comment="ALLOW EST REL" connection-state=established,related,untracked\n`;
                config += `add action=accept chain=input comment="ALLOW MT NEIGHBOR" dst-port=5678 protocol=udp\n`;
                config += `add action=accept chain=input comment="ALLOW MAC TELNET" dst-port=20561 protocol=udp\n`;
                config += `add action=accept chain=input comment="ALLOW IGMP" protocol=igmp\n`;
                config += `add action=accept chain=input comment="ALLOW ICMP" protocol=icmp\n`;
                config += `add action=accept chain=input comment="ALLOW DHCPv4" protocol=udp dst-port=67\n`;
                config += `add action=accept chain=input comment="ALLOW DHCPv6" protocol=udp dst-port=547\n`;
                config += `add action=accept chain=input comment="ALLOW OSPF" protocol=ospf\n`;
                config += `add action=accept chain=input comment="ALLOW LDP" dst-port=646 protocol=tcp\n`;
                config += `add action=accept chain=input comment="ALLOW LDP" dst-port=646 protocol=udp\n`;
                config += `add action=accept chain=input comment="ALLOW MANAGER IP" src-address-list=managerIP\n`;
                config += `add action=accept chain=input comment="ALLOW BGP" protocol=tcp dst-port=179 src-address-list=BGP-ALLOW\n`;
                config += `add action=accept chain=input comment="ALLOW EOIP" protocol=gre src-address-list=EOIP-ALLOW\n`;
                config += `add action=accept chain=input comment="ALLOW SNMP" dst-port=161 protocol=udp src-address-list=SNMP\n`;
                config += `add action=drop chain=input comment="DROP INPUT" log=no\n\n`;

                // Firewall Raw Chain
                config += `# FIREWALL RAW CHAIN\n`;
                config += `/ip firewall raw\n`;
                config += `rem [find dynamic=no]\n`;
                config += `add action=drop chain=prerouting comment="DROP BAD UDP" port=0 protocol=udp\n\n`;

                // Firewall Forward Chain
                config += `# FIREWALL FORWARD CHAIN\n`;
                config += `/ip firewall filter\n`;
                config += `rem [find where chain=forward dynamic=no]\n`;
                config += `add action=accept chain=forward comment="BGP Accept" dst-address=10.0.0.0/8 dst-port=179 protocol=tcp src-address=10.0.0.0/8\n`;
                config += `add action=accept chain=forward comment="GRE Accept" dst-address=10.0.0.0/8 protocol=gre src-address=10.0.0.0/8\n`;
                config += `add action=drop chain=forward comment="unauth drop rule" dst-address-list=!WALLED-GARDEN src-address-list=unauth\n`;
                config += `add action=fasttrack-connection chain=forward connection-state=established,related,untracked hw-offload=yes\n`;
                config += `add action=accept chain=forward connection-state=established,related,untracked\n\n`;

                // Firewall Mangle
                config += `# FIREWALL MANGLE\n`;
                config += `/ip firewall mangle\n`;
                config += `rem [find where dynamic=no]\n`;
                config += `add action=mark-packet chain=prerouting comment="Mark NTP packets" dst-address-list=NTP dst-port=123 new-packet-mark=NTP passthrough=no protocol=udp\n\n`;

                // Firewall NAT
                config += `# FIREWALL NAT\n`;
                config += `/ip firewall nat\n`;
                config += `rem [find]\n`;
                config += `add action=dst-nat chain=dstnat comment="unauth proxy rule" dst-address-list=!WALLED-GARDEN dst-port=80 protocol=tcp src-address-list=unauth to-addresses=107.178.15.27 to-ports=3128\n`;
                config += `add action=src-nat chain=srcnat packet-mark=NTP to-addresses=${routerId}\n\n`;

                // System Hardening
                config += `# SYSTEM HARDENING\n`;
                config += `/system watchdog\n`;
                config += `set watchdog-timer=yes\n`;
                config += `/system routerboard settings\n`;
                config += `set auto-upgrade=yes\n`;
                config += `/ip firewall connection tracking\n`;
                config += `set udp-timeout=30s\n`;
                config += `/ip proxy\n`;
                config += `set enabled=yes\n`;
                config += `/ip firewall service-port\n`;
                config += `set sip disabled=yes\n\n`;

                // SNMP Configuration
                config += `# SNMP CONFIGURATION\n`;
                config += `/snmp\n`;
                config += `set enabled=yes src-address=${routerId} trap-community=${snmpCommunity}\n`;
                config += `/snmp community\n`;
                config += `set [find default=yes] read-access=no\n`;
                config += `rem [find default=no]\n`;
                config += `add name=${snmpCommunity} addresses=::/0\n\n`;

                // Logging Configuration
                config += `# LOGGING CONFIGURATION\n`;
                config += `/system logging action\n`;
                config += `rem [find default=no]\n`;
                config += `set [find name="memory"] memory-lines=1000\n`;
                config += `set [find name="disk"] disk-lines-per-file=10000 disk-file-count=3\n`;
                const syslogServer = getSyslogServer();
                if (syslogServer) {
                    config += `add name=syslog remote=${syslogServer} src-address=$LoopIP target=remote\n`;
                }
                config += `/system logging\n`;
                config += `rem [find default=no]\n`;
                config += `add action=syslog topics=critical\n`;
                config += `add action=syslog topics=error\n`;
                config += `add action=syslog topics=warning\n`;
                config += `add action=disk topics=critical\n`;
                config += `add action=disk topics=error\n`;
                config += `add action=disk topics=warning\n`;
                config += `add action=memory topics=critical\n`;
                config += `add action=memory topics=error\n`;
                config += `add action=memory topics=warning\n`;
                config += `set 0 action=echo\n\n`;

                // User Management
                config += `# USER MANAGEMENT\n`;
                config += `/user aaa\n`;
                config += `set use-radius=yes\n`;
                config += `/user group\n`;
                config += `rem [find where name!="full" and name!="read" and name!="write"]\n`;
                config += `set read policy="local,telnet,read,test,winbox,sniff,ssh,!ftp,!reboot,!write,!policy,!password,!web,!sensitive,!api,!romon,!rest-api"\n\n`;

                // DHCP Options
                config += `# DHCP OPTIONS\n`;
                config += `/ip dhcp-server option\n`;
                config += `rem [find]\n`;
                config += `add code=66 name=option66-ata value="'http://ndp1-dal.nxlink.com/cfg/\$MA.cfg'"\n`;
                config += `add code=43 name=opt43 value=0x011768747470733a2f2f7573732e6e786c696e6b2e636f6d2f\n`;
                config += `/ip dhcp-server option sets\n`;
                config += `rem [find]\n`;
                config += `add name=optset options=opt43\n\n`;
                // Note: DHCP server network entries should include dhcp-option-set=optset when added
                // if they don't start with "10." - this is handled dynamically when entries are created

                // RADIUS Configuration
                config += `# RADIUS CONFIGURATION\n`;
                config += `/radius\n`;
                config += `rem [find]\n`;
                const radiusDHCPServers2 = getRADIUSDHCPServers();
                if (radiusDHCPServers2.length > 0) {
                    radiusDHCPServers2.forEach(server => {
                        if (server.address && server.secret) {
                            config += `add address=${server.address} secret=${server.secret} service=dhcp src-address=$LoopIP timeout=5s\n`;
                        }
                    });
                    config += `\n`;
                }
                const radiusLoginServers2 = getRADIUSLoginServers();
                if (radiusLoginServers2.length > 0) {
                    radiusLoginServers2.forEach(server => {
                        if (server.address && server.secret) {
                            const comment = server.comment ? ` comment="${server.comment}"` : '';
                            config += `add address=${server.address} secret=${server.secret} service=login src-address=$LoopIP timeout=5s${comment}\n`;
                        }
                    });
                    config += `\n`;
                }

                // MPLS LDP Filters (if MPLS enabled)
                if (enableMPLS) {
                    config += `# MPLS LDP FILTERS\n`;
                    config += `/mpls ldp accept-filter\n`;
                    config += `rem [find]\n`;
                    RFC_COMPLIANCE_CONFIG.mplsLdpFilters.acceptDeny.forEach(prefix => {
                        config += `add accept=no disabled=no prefix=${prefix}\n`;
                    });
                    RFC_COMPLIANCE_CONFIG.mplsLdpFilters.acceptAllow.forEach(prefix => {
                        config += `add accept=yes disabled=no prefix=${prefix}\n`;
                    });
                    config += `add accept=no disabled=no prefix=0.0.0.0/0\n\n`;

                    config += `/mpls ldp advertise-filter\n`;
                    config += `rem [find]\n`;
                    RFC_COMPLIANCE_CONFIG.mplsLdpFilters.acceptDeny.forEach(prefix => {
                        config += `add advertise=no disabled=no prefix=${prefix}\n`;
                    });
                    RFC_COMPLIANCE_CONFIG.mplsLdpFilters.acceptAllow.forEach(prefix => {
                        config += `add advertise=yes disabled=no prefix=${prefix}\n`;
                    });
                    config += `add advertise=no disabled=no prefix=0.0.0.0/0\n\n`;
                }
                // BGP Template Configuration
                config += `# BGP TEMPLATE CONFIGURATION\n`;
                config += `/routing bgp template\n`;
                config += `set default as=26077 disabled=no multihop=yes output.network=bgp-networks router-id=${routerId} routing-table=main\n\n`;
                // OSPF Instance and Area Configuration
                config += `# OSPF INSTANCE AND AREA CONFIGURATION\n`;
                config += `/routing ospf instance\n`;
                config += `add disabled=no name=default-v2 router-id=${routerId}\n`;
                config += `/routing ospf area\n`;
                config += `add disabled=no instance=default-v2 name=backbone-v2\n\n`;

                // SNMP Configuration
                config += `# SNMP CONFIGURATION\n`;
                config += `/snmp\n`;
                const siteLatitude = document.getElementById('siteLatitude').value.trim();
                const siteLongitude = document.getElementById('siteLongitude').value.trim();
                const location = siteLatitude && siteLongitude ? `"${siteLatitude}, ${siteLongitude}"` : '"Unknown Location"';
                const snmpContact = getInfrastructureValue('snmp.contact', 'netops@team.nxlink.com');
                config += `set contact=${snmpContact} enabled=yes location=${location} src-address=${routerId} trap-community=${snmpCommunity}\n\n`;

                // System Note
                config += `# SYSTEM NOTE\n`;
                config += `/system note\n`;
                config += `set note="RFC COMPLIANCE SCRIPT APPLIED ON $CurDT"\n\n`;

                return config;
            }
            function addOutOfStateConfiguration(config, routerId, snmpCommunity, lanBridgeIP, natPublicIP, siteLatitude, siteLongitude) {
                // Out-of-state configuration - simple bridge/DHCP setup
                config += `# OUT-OF-STATE CONFIGURATION\n`;
                config += `# Simple bridge and DHCP setup for out-of-state deployments\n\n`;

                // Basic bridges
                config += `/interface bridge\n`;
                config += `add name=public-bridge priority=0x1\n`;
                config += `add name=nat-bridge priority=0x1\n`;
                config += `add name=loop0\n\n`;

                // Basic IP addresses
                config += `/ip address\n`;
                config += `add address=${routerId}/32 interface=loop0 comment=loop0\n`;
                if (natPublicIP) {
                    config += `add address=${natPublicIP} interface=public-bridge comment="PUBLIC(S)"\n`;
                }
                if (lanBridgeIP) {
                    const lanIP = lanBridgeIP.includes('/') ? lanBridgeIP.split('/')[0] : lanBridgeIP;
                    config += `add address=${lanIP}/24 interface=nat-bridge comment="PRIVATES"\n`;
                }
                config += `\n`;

                // Basic DNS
                config += `/ip dns\n`;
                config += `set max-udp-packet-size=512 servers=${getDNSList()}\n\n`;

                // Basic DHCP pools
                config += `/ip pool\n`;
                if (natPublicIP) {
                    const publicIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                    const publicRange = publicIP.replace(/\.\d+$/, '.226') + '-' + publicIP.replace(/\.\d+$/, '.230');
                    config += `add name=public ranges="${publicRange}"\n`;
                }
                if (lanBridgeIP) {
                    const lanIP = lanBridgeIP.includes('/') ? lanBridgeIP.split('/')[0] : lanBridgeIP;
                    const privateRange = lanIP.replace(/\.\d+$/, '.10') + '-' + lanIP.replace(/\.\d+$/, '.254');
                    config += `add name=private ranges="${privateRange}"\n`;
                }
                config += `\n`;

                // Basic DHCP servers
                config += `/ip dhcp-server\n`;
                if (natPublicIP) {
                    config += `add address-pool=public disabled=no interface=public-bridge lease-time=1h name=public-server use-radius=no authoritative=yes\n`;
                }
                if (lanBridgeIP) {
                    config += `add address-pool=private disabled=no interface=nat-bridge lease-time=1h name=nat-server use-radius=no authoritative=yes\n`;
                }
                config += `\n`;

                // Basic DHCP networks
                config += `/ip dhcp-server network\n`;
                if (natPublicIP) {
                    const publicIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                    const publicNetwork = publicIP.replace(/\.\d+$/, '.224/29');
                    config += `add address=${publicNetwork} dns-server=${getDNSList()} comment="PUBLIC(S)" gateway=${publicIP} netmask=29\n`;
                }
                if (lanBridgeIP) {
                    const lanIP = lanBridgeIP.includes('/') ? lanBridgeIP.split('/')[0] : lanBridgeIP;
                    config += `add address=${lanIP}/24 dns-server=${getDNSList()} comment=PRIVATES gateway=${lanIP} netmask=24\n`;
                }
                config += `\n`;

                // Basic SNMP
                config += `/snmp community\n`;
                config += `set [ find default=yes ] read-access=no\n`;
                config += `add name=${snmpCommunity} addresses=::/0\n`;
                config += `/snmp\n`;
                const location = siteLatitude && siteLongitude ? `"${siteLatitude}, ${siteLongitude}"` : '"Unknown Location"';
                const snmpContact = getInfrastructureValue('snmp.contact', 'netops@team.nxlink.com');
                config += `set contact=${snmpContact} enabled=yes location=${location} trap-community=${snmpCommunity} src-address=${routerId}\n\n`;

                // Basic NAT
                config += `/ip firewall nat\n`;
                if (natPublicIP && lanBridgeIP) {
                    const publicIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                    const lanIP = lanBridgeIP.includes('/') ? lanBridgeIP.split('/')[0] : lanBridgeIP;
                    config += `add action=src-nat chain=srcnat src-address=${lanIP}/24 to-addresses=${publicIP}\n`;
                }
                config += `\n`;

                // Basic address lists
                config += `/ip firewall address-list\n`;
                config += `add address=67.219.119.0/24 list=ACS\n`;
                config += `add address=142.147.121.0/24 list=ACS\n\n`;

                // Basic filter rules
                config += `/ip firewall filter\n`;
                config += `add action=accept chain=input comment="ACS RULE" src-address-list=ACS\n\n`;

                // Basic logging
                config += `/system logging action\n`;
                config += `set 0 memory-lines=100\n`;
                config += `set 1 disk-lines-per-file=10000\n`;
                const syslogServer2 = getSyslogServer();
                if (syslogServer2) {
                    config += `add name=syslog remote=${syslogServer2} src-address=${routerId} target=remote\n`;
                }
                config += `/system logging\n`;
                config += `add action=syslog topics=critical\n`;
                config += `add action=syslog topics=error\n`;
                config += `add action=syslog topics=info\n`;
                config += `add action=syslog topics=warning\n`;
                config += `add disabled=yes topics=debug\n\n`;

                return config;
            }

            // Dynamic Configuration Functions
            function addDynamicConfigurations(config, enableTarana, enableSWT, enableVPLS, enableMPLS, enableDHCP, lanBridgeIP, cgnatRange, unauthRange, vlan4000Range, routerId, sharedKey) {
                // Add dynamic address lists for user-configured features (append to existing RFC lists)
                config += `# DYNAMIC ADDRESS LISTS (Additional to RFC Baseline)\n`;

                // Add static customers to address lists
                const staticCustomers = Array.from(document.querySelectorAll('#staticCustomers .customer-item:not(#customerTemplate)'))
                    .map(item => ({
                        name: item.querySelector('input[name="customerName"]')?.value,
                        range: item.querySelector('input[name="customerRange"]')?.value,
                        comment: item.querySelector('input[name="customerComment"]')?.value
                    }))
                    .filter(customer => customer.name && customer.range);

                if (staticCustomers.length > 0) {
                    config += `/ip firewall address-list\n`;
                    config += `rem [find list=static-customers]\n`;
                    staticCustomers.forEach(customer => {
                        config += `add address=${customer.range} comment="${customer.comment || customer.name}" list=static-customers\n`;
                    });
                }

                // Add DHCP-related address lists (these are now handled in RFC baseline bgp-networks)
                // Note: UNAUTH, CGNAT_PUBLIC, CGNAT_PRIVATE are now added to bgp-networks in RFC baseline
                if (enableDHCP) {
                    if (cgnatRange) {
                        config += `/ip firewall address-list\n`;
                        config += `rem [find list=cgnat-customers]\n`;
                        config += `add address=${cgnatRange} comment="CGNAT customers" list=cgnat-customers\n`;
                    }
                    if (vlan4000Range) {
                        config += `/ip firewall address-list\n`;
                        config += `rem [find list=vlan4000-customers]\n`;
                        config += `add address=${vlan4000Range} comment="VLAN 4000 customers" list=vlan4000-customers\n`;
                    }
                }
                config += `\n`;

                // Add dynamic firewall rules for user features (append to existing RFC rules)
                config += `# DYNAMIC FIREWALL RULES (Additional to RFC Baseline)\n`;

                // Allow static customers full access
                if (staticCustomers.length > 0) {
                    config += `/ip firewall filter\n`;
                    config += `add action=accept chain=forward comment="Allow static customers" src-address-list=static-customers\n`;
                }

                // Tarana-specific rules
                if (enableTarana) {
                    config += `/ip firewall filter\n`;
                    config += `add action=accept chain=forward comment="Allow Tarana traffic" src-address=10.25.0.0/16\n`;
                    config += `add action=accept chain=forward comment="Allow Tarana management" src-address=10.25.34.0/28\n`;
                }

                // SWT-specific rules
                if (enableSWT) {
                    config += `/ip firewall filter\n`;
                    config += `add action=accept chain=forward comment="Allow SWT traffic" src-address=10.10.0.0/16\n`;
                    config += `add action=accept chain=forward comment="Allow SWT management" src-address=10.10.9.0/22\n`;
                }

                // VPLS-specific rules
                if (enableVPLS) {
                    config += `/ip firewall filter\n`;
                    config += `add action=accept chain=forward comment="Allow VPLS traffic" protocol=gre\n`;
                    config += `add action=accept chain=forward comment="Allow VPLS control" dst-port=4789 protocol=udp\n`;
                }
                config += `\n`;

                // Add dynamic NAT rules
                config += `# DYNAMIC NAT RULES\n`;
                config += `/ip firewall nat\n`;

                const natPublicIP = document.getElementById('natPublicIP').value.trim();
                if (natPublicIP && lanBridgeIP) {
                    const natIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                    const lanNetwork = calculateNetwork(lanBridgeIP);
                    const lanCidr = lanBridgeIP.split('/')[1];

                    // Source NAT for LAN traffic
                    config += `add action=src-nat chain=srcnat comment="LAN to Internet NAT" out-interface=all src-address=${lanNetwork}/${lanCidr} to-addresses=${natIP}\n`;
                }

                if (enableDHCP) {
                    if (cgnatRange && natPublicIP) {
                        const natIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                        config += `add action=dst-nat chain=dstnat comment="CGNAT to Public" dst-address=${cgnatRange} to-addresses=${natIP}\n`;
                    }

                    if (unauthRange && natPublicIP) {
                        const natIP = natPublicIP.includes('/') ? natPublicIP.split('/')[0] : natPublicIP;
                        config += `add action=dst-nat chain=dstnat comment="Unauth to Public" dst-address=${unauthRange} to-addresses=${natIP}\n`;
                    }
                }
                config += `\n`;

                // Add OSPF Interface Templates
                config += `# OSPF INTERFACE TEMPLATES\n`;
                config += `/routing ospf interface-template\n`;

                // Loopback interface template
                config += `add area=backbone-v2 cost=10 disabled=no interfaces=loop0 networks=${routerId}/32 passive priority=1\n`;

                // LAN bridge interface template
                if (lanBridgeIP) {
                    const lanNetwork = calculateNetwork(lanBridgeIP);
                    const lanCidr = lanBridgeIP.split('/')[1];
                    config += `add area=backbone-v2 cost=10 disabled=no interfaces=lan-bridge networks=${lanNetwork}/${lanCidr} priority=1\n`;
                }

                // Add uplink interface templates - Handle both old (#uplinks) and new (#portConfigs) structures
                // Old structure: #uplinks .uplink-item
                const oldUplinkElements = document.querySelectorAll('#uplinks .uplink-item:not(#uplinkTemplate)');
                oldUplinkElements.forEach((element, index) => {
                    const port = element.querySelector('select[id*="NewPort"]')?.value || element.querySelector('select[name="port"]')?.value;
                    const ip = element.querySelector('input[id*="Ip"]')?.value || element.querySelector('input[name="ip"]')?.value;
                    const comment = element.querySelector('input[id*="Comment"]')?.value || element.querySelector('input[name="comment"]')?.value || `Uplink-${index + 1}`;
                    const cost = element.querySelector('input[id*="Cost"]')?.value || element.querySelector('input[name="cost"]')?.value || '10';

                    if (port && ip) {
                        const network = calculateNetwork(ip);
                        const cidr = ip.split('/')[1];
                        config += `add area=backbone-v2 auth=md5 auth-id=1 auth-key=${sharedKey} comment="${comment}" cost=${cost} disabled=no interfaces=${port} networks=${network}/${cidr} priority=1 type=ptp\n`;
                    }
                });

                // New structure: #portConfigs with portUplinkType="routed"
                const newPortUplinkElements = document.querySelectorAll('#portConfigs .uplink-item:not(#portUplinkTemplate)');
                newPortUplinkElements.forEach((element, index) => {
                    const portType = element.querySelector('select[name="portUplinkType"]')?.value;
                    if (portType === 'routed') {
                        const port = element.querySelector('select[name="portUplinkPort"]')?.value;
                        const ip = element.querySelector('input[name="portUplinkIp"]')?.value;
                        const comment = element.querySelector('input[name="portUplinkComment"]')?.value || `Uplink-${index + 1}`;
                        const cost = element.querySelector('input[name="portUplinkCost"]')?.value || '10';

                        if (port && ip) {
                            const network = calculateNetwork(ip);
                            const cidr = ip.split('/')[1];
                            config += `add area=backbone-v2 auth=md5 auth-id=1 auth-key=${sharedKey} comment="${comment}" cost=${cost} disabled=no interfaces=${port} networks=${network}/${cidr} priority=1 type=ptp\n`;
                        }
                    }
                });
                config += `\n`;

                // Add BGP Connections (backbone-v2 mode; when MPLS is NOT enabled)
                if (!enableMPLS) {
                    config += `# BGP CONNECTIONS\n`;
                    config += `/routing bgp connection\n`;

                    // Add BGP connections for core routers
                    const bgpConnections = [
                        { name: 'CR7', remote: '10.2.0.107' },
                        { name: 'CR8', remote: '10.2.0.108' }
                    ];

                    bgpConnections.forEach(conn => {
                        config += `add cisco-vpls-nlri-len-fmt=auto-bits connect=yes listen=yes local.address=${routerId} .role=ibgp multihop=yes name=${conn.name} remote.address=${conn.remote} .as=26077 .port=179 tcp-md5-key=${sharedKey} templates=default\n`;
                    });
                    config += `\n`;

                    // Add BGP Routing Filter Rules
                    config += `# BGP ROUTING FILTER RULES\n`;
                    config += `/routing filter rule\n`;
                    config += `add chain=bgr-a-bgp-in-filter disabled=no rule="if (dst in 0.0.0.0/0 && dst-len == 32 && protocol bgp && bgp-communities includes 26077:86) { set blackhole yes; accept; }"\n`;
                    config += `add chain=bgr-a-bgp-in-filter disabled=no rule="if (dst in 0.0.0.0/0 && dst-len == 0 && protocol bgp) { set bgp-local-pref 500; accept; }"\n`;
                    config += `add chain=bgr-a-bgp-in-filter disabled=no rule="if (dst in 0.0.0.0/0 && dst-len >= 0 && protocol bgp) { accept; }"\n`;
                    config += `add chain=bgr-b-bgp-in-filter disabled=no rule="if (dst in 0.0.0.0/0 && dst-len == 32 && protocol bgp && bgp-communities includes 26077:86) { set blackhole yes; accept; }"\n`;
                    config += `add chain=bgr-b-bgp-in-filter disabled=no rule="if (dst in 0.0.0.0/0 && dst-len == 0 && protocol bgp) { set bgp-local-pref 500; accept; }"\n`;
                    config += `add chain=bgr-b-bgp-in-filter disabled=no rule="if (dst in 0.0.0.0/0 && dst-len >= 0 && protocol bgp) { accept; }"\n\n`;
                }

                return config;
            }
            // Make functions globally accessible for onclick handlers
            window.generateConfig = function () {
                try {
                    // Show MUSHU-style live progress tracker
                    showProgressTracker('Tower Configuration Generation');
                    updateProgressStep('Initializing and gathering input parameters...');
                    updateProgressPercent(5);
                    addProgressLog('info', 'Starting Tower config generation');

                    const siteName = document.getElementById('siteName').value.trim();
                    const routerId = document.getElementById('routerId').value.trim();
                    const targetDevice = document.getElementById('targetDevice').value || 'ccr2004';
                    const currentDevice = document.getElementById('currentDevice').value;
                    const currentRouterOS = document.getElementById('currentRouterOS').value;
                    const targetRouterOS = document.getElementById('targetRouterOS').value;

                    addProgressLog('info', `Site: ${siteName}, Device: ${targetDevice}, RouterOS: ${targetRouterOS}`);

                    // Get device configuration
                    const deviceConfig = DEVICE_CONFIGS[targetDevice] || DEVICE_CONFIGS.ccr2004;
                    const systemName = document.getElementById('systemName').value.trim() || `RTR-${deviceConfig.name}-1.${siteName}`;
                    const lanBridgeIP = document.getElementById('lanBridgeIP').value.trim();
                    const ospfArea = document.getElementById('ospfArea').value === 'custom'
                        ? document.getElementById('ospfAreaCustom').value.trim()
                        : document.getElementById('ospfArea').value;
                    const ospfAreaId = document.getElementById('ospfAreaId').value.trim();
                    const bgpPeersJson = document.getElementById('bgpPeers').value.trim();
                    const bgpAS = document.getElementById('bgpAS').value.trim();
                    const configType = document.getElementById('configType').value;
                    const isLegacySimple = configType === 'simple-baseline';
                    const isOutOfState = configType === 'out-of-state';
                    const isInState = configType === 'in-state';
                    const enableVPLS = document.getElementById('enableVPLS').checked;
                    const enableMPLS = document.getElementById('enableMPLS').checked;
                    const enableDHCP = document.getElementById('enableDHCP').checked;
                    const enableTarana = document.getElementById('enableTarana').checked;
                    const enableSWT = document.getElementById('enableSWT').checked;
                    const disableUnusedPorts = document.getElementById('disableUnusedPorts')?.checked === true;

                    // Hidden fields are auto-managed; still, enforce safe defaults to avoid blank keys/DNS/community.
                    let sharedKey = document.getElementById('sharedKey').value.trim();
                    if (!sharedKey) {
                        sharedKey = getInfrastructureValue('sharedKeys.ospfBgpMd5', 'm8M5JwvdYM') || 'm8M5JwvdYM';
                        document.getElementById('sharedKey').value = sharedKey;
                    }

                    let dnsServers = document.getElementById('dnsServers').value.trim();
                    if (!dnsServers) {
                        dnsServers = (typeof getDNSList === 'function' ? getDNSList() : '142.147.112.3,142.147.112.19');
                        document.getElementById('dnsServers').value = dnsServers;
                    }

                    const dhcpSecret = document.getElementById('dhcpSecret').value.trim();

                    let snmpCommunity = document.getElementById('snmpCommunity').value.trim();
                    if (!snmpCommunity || snmpCommunity.toUpperCase() === 'CHANGE_ME') {
                        const suffix = Math.random().toString(36).slice(2, 10);
                        snmpCommunity = `NX${suffix}`;
                        document.getElementById('snmpCommunity').value = snmpCommunity;
                    }
                    const natPublicIPRaw = document.getElementById('natPublicIP').value.trim();
                    const siteLatitude = document.getElementById('siteLatitude').value.trim();
                    const siteLongitude = document.getElementById('siteLongitude').value.trim();

                    // Get IP range variables (needed early for RFC compliance)
                    const cgnatRange = document.getElementById('cgnatRange').value.trim();
                    const unauthRange = document.getElementById('unauthRange').value.trim();
                    const vlan4000Range = document.getElementById('vlan4000Range').value.trim();

                    if (!siteName || !routerId) {
                        addProgressLog('error', 'Missing required fields: Site Name or Router ID');
                        completeProgressTracker(false);
                        alert('Please fill in Site Name and Router ID!');
                        return;
                    }

                    updateProgressPercent(10);
                    updateProgressStep('Validating input parameters and gathering VLAN data...');
                    addProgressLog('success', 'All required fields validated');

                    // Get VLAN data once for reuse
                    const vlanRows = Array.from(document.querySelectorAll('#vlanInterfaces .vlan-item:not(#vlanTemplate)'))
                        .map(item => ({
                            parent: item.querySelector('select[name="vlanParent"]')?.value,
                            vid: item.querySelector('input[name="vlanId"]')?.value,
                            comment: item.querySelector('input[name="vlanComment"]')?.value,
                            bridge: item.querySelector('input[name="vlanBridge"]')?.value || 'lan-bridge'
                        }))
                        .filter(v => v.parent && v.vid);

                    // Deduplicate VLANs with same parent and VID
                    const seen = new Set();
                    let uniqueVlans = vlanRows.filter(v => {
                        const key = `${v.parent}|${v.vid}`;
                        if (seen.has(key)) return false;
                        seen.add(key);
                        return true;
                    });

                    // If no VLANs were defined in the UI, auto-add Nextlink tower baseline VLANs (In-State).
                    // This avoids "minimal config" generation and matches real tower defaults (1000/2000/3000/4000).
                    if (isInState && uniqueVlans.length === 0) {
                        const allPorts = [...(deviceConfig.ports || []), ...(deviceConfig.sfpPorts || [])].filter(p => p && p !== 'ether1');
                        const preferredTrunks = ['sfp-sfpplus2', 'sfp-sfpplus3', 'sfp2', 'sfp3', 'sfp-sfpplus1', 'sfp1'];
                        const trunks = [];
                        preferredTrunks.forEach(p => { if (allPorts.includes(p) && !trunks.includes(p)) trunks.push(p); });
                        allPorts.forEach(p => { if (!trunks.includes(p)) trunks.push(p); });
                        const trunkPorts = trunks.slice(0, 2);

                        const baseVlans = [
                            { vid: '1000', bridge: 'bridge1000', comment: 'VLAN1000-DYNAMIC' },
                            { vid: '2000', bridge: 'bridge2000', comment: 'VLAN2000-STATIC' },
                            { vid: '3000', bridge: 'bridge3000', comment: 'VLAN3000-INFRA' },
                            { vid: '4000', bridge: 'bridge4000', comment: 'VLAN4000-CPE' },
                        ];

                        trunkPorts.forEach(parent => {
                            baseVlans.forEach(v => uniqueVlans.push({ parent, vid: v.vid, comment: v.comment, bridge: v.bridge }));
                        });

                        addProgressLog('info', `Auto-added baseline VLANs on trunks: ${trunkPorts.join(', ')}`);
                    }
                    // Collect direct portbridge assignments early so we only create needed bridges
                    const portBridgeAssignmentsEarly = Array.from(
                        document.querySelectorAll('#portConfigs .uplink-item:not(#portTemplate)')
                    ).map(item => {
                        const port = item.querySelector('select[name="portName"]')?.value?.trim();
                        const bridge = item.querySelector('select[name="portBridge"]')?.value?.trim();
                        return { port, bridge };
                    }).filter(x => x.port && x.bridge);

                    // Work out which bridges we actually need
                    const bridgesNeeded = new Set(
                        uniqueVlans.map(v => v.bridge).filter(Boolean)
                    );
                    portBridgeAssignmentsEarly.forEach(({ bridge }) => bridgesNeeded.add(bridge));

                    // Nextlink tower baseline bridges are always present in In-State configs, even if no ports are assigned yet.
                    if (isInState) {
                        ['bridge1000', 'bridge2000', 'bridge3000', 'bridge4000'].forEach(b => bridgesNeeded.add(b));
                    }

                    // Only add lan-bridge if the LAN Bridge IP is set
                    if (lanBridgeIP) bridgesNeeded.add('lan-bridge');
                    // Only add nat-public-bridge if the NAT Public IP is set
                    if (natPublicIPRaw) bridgesNeeded.add('nat-public-bridge');

                    // Add Tarana bridges if Tarana is enabled
                    if (enableTarana) {
                        bridgesNeeded.add('bridge1000');
                        bridgesNeeded.add('bridge2000');
                        bridgesNeeded.add('bridge3000');
                    }

                    // Always keep loopback pseudo-bridge (loop0) as in current build
                    const needsLoop = true;

                    updateProgressPercent(20);
                    updateProgressStep('Building configuration header and RFC compliance baseline...');
                    addProgressLog('info', `Generating for: ${deviceConfig.name}`);

                    // Generate device-specific configuration header
                    let config = generateConfigHeader(siteName, targetDevice, currentDevice, currentRouterOS, targetRouterOS, deviceConfig);

                    // Add configuration based on type
                    if (isInState) {
                        // In-state: Full RFC compliance baseline
                        config = addRFCComplianceBaseline(config, routerId, snmpCommunity, dhcpSecret, enableMPLS, unauthRange, cgnatRange, vlan4000Range);
                    } else {
                        // Out-of-state / simple-baseline: Simple bridge/DHCP configuration
                        config = addOutOfStateConfiguration(config, routerId, snmpCommunity, lanBridgeIP, natPublicIPRaw, siteLatitude, siteLongitude);
                    }

                    if (isInState) {
                        updateProgressPercent(30);
                        updateProgressStep('Configuring interfaces, bridges, and port mappings...');
                        addProgressLog('info', `Creating ${bridgesNeeded.size} bridges`);

                        // 1. Interface Bridge (only create bridges actually referenced/needed)
                        if (isInState) {
                            config += `/interface bridge\n`;
                            if (needsLoop) {
                                config += `add fast-forward=no name=loop0\n`;
                            }
                            if (bridgesNeeded.has('lan-bridge')) {
                                config += `add fast-forward=no name=lan-bridge priority=0x1\n`;
                            }
                            if (bridgesNeeded.has('nat-public-bridge')) {
                                config += `add fast-forward=no name=nat-public-bridge\n`;
                            }
                            // Create only VLAN bridges that are referenced anywhere
                            ['bridge1000', 'bridge2000', 'bridge3000', 'bridge4000', 'bridge999249'].forEach(b => {
                                if (bridgesNeeded.has(b)) {
                                    if (b === 'bridge999249') {
                                        config += `add comment=m-VPLS name=bridge999249 port-cost-mode=short priority=0x7000 protocol-mode=mstp vlan-filtering=yes\n`;
                                    } else {
                                        config += `add name=${b}\n`;
                                    }
                                }
                            });

                            // --- Consolidated ethernet emission (ordered & de-duped) ---
                            const configuredPorts = new Set();

                            // Seed from Uplink inputs - process all uplinks dynamically (OLD STRUCTURE: #uplinks)
                            const ethMap = new Map(); // port -> {comment, speed, mtu, l2mtu}
                            const allUplinkElementsEth = document.querySelectorAll('#uplinks .uplink-item:not(#uplinkTemplate)');
                            allUplinkElementsEth.forEach((element, index) => {
                                const port = element.querySelector('select[id*="NewPort"]')?.value;
                                if (!port || port === 'ether1') return; // ether1 is reserved for management only
                                const comment = element.querySelector('input[id*="Comment"]')?.value || `Uplink-${index + 1}`;
                                const speed = element.querySelector('select[id*="Speed"]')?.value || '1Gbps';
                                ethMap.set(port, { comment, speed, mtu: '', l2mtu: '' });
                            });

                            // NEW STRUCTURE: #portConfigs with portUplinkType
                            const newPortUplinkElementsEth = document.querySelectorAll('#portConfigs .uplink-item:not(#portUplinkTemplate)');
                            newPortUplinkElementsEth.forEach((element, index) => {
                                const port = element.querySelector('select[name="portUplinkPort"]')?.value;
                                if (!port || port === 'ether1') return; // don't override ether1 Management
                                const comment = element.querySelector('input[name="portUplinkComment"]')?.value || `Port-${index + 1}`;
                                const speed = element.querySelector('select[name="portUplinkSpeed"]')?.value || 'auto';
                                ethMap.set(port, { comment, speed, mtu: '', l2mtu: '' });
                            });

                            // Merge Port Config rows (OLD STRUCTURE - for backward compatibility)
                            const portConfigs = Array.from(document.querySelectorAll('#portConfigs .uplink-item:not(#portTemplate):not(#portUplinkTemplate)'))
                                .map(item => ({
                                    port: item.querySelector('select[name="portName"]')?.value,
                                    speed: item.querySelector('select[name="portSpeed"]')?.value,
                                    comment: item.querySelector('input[name="portComment"]')?.value || '',
                                    bridge: item.querySelector('select[name="portBridge"]')?.value,
                                    mtu: item.querySelector('input[name="portMtu"]')?.value,
                                    l2mtu: item.querySelector('input[name="portL2Mtu"]')?.value
                                }))
                                .filter(pc => pc.port && pc.port !== 'ether1');

                            portConfigs.forEach(pc => {
                                const prev = ethMap.get(pc.port) || {};
                                ethMap.set(pc.port, {
                                    comment: pc.comment || prev.comment || '',
                                    speed: (pc.speed && pc.speed !== '') ? pc.speed : (prev.speed || ''),
                                    mtu: (pc.mtu != null && pc.mtu !== '') ? pc.mtu : (prev.mtu || ''),
                                    l2mtu: (pc.l2mtu != null && pc.l2mtu !== '') ? pc.l2mtu : (prev.l2mtu || '')
                                });
                            });

                            // Ordering: ether1, sfp-sfpplusN, sfp28-N, then the rest alpha
                            function portRank(p) {
                                if (p === 'ether1') return [0, 1];
                                let m = /^sfp-sfpplus(\d+)$/.exec(p);
                                if (m) return [1, Number(m[1]) || 0];
                                m = /^sfp28-(\d+)$/.exec(p);
                                if (m) return [2, Number(m[1]) || 0];
                                return [3, p];
                            }

                            const entries = Array.from(ethMap.entries()).sort((a, b) => {
                                const ra = portRank(a[0]);
                                const rb = portRank(b[0]);
                                if (ra[0] !== rb[0]) return ra[0] - rb[0];
                                if (typeof ra[1] === 'number' && typeof rb[1] === 'number') return ra[1] - rb[1];
                                return String(ra[1]).localeCompare(String(rb[1]));
                            });

                            // Emit section once, in order
                            config += `/interface ethernet\n`;
                            // Only configure ether1 if the device has ether1 port
                            if (deviceConfig.ports.includes('ether1')) {
                                config += `set [ find default-name=ether1 ] auto-negotiation=yes comment="Management"\n`;
                            }

                            entries.forEach(([port, pc]) => {
                                const autoNegPart =
                                    pc.speed ? (pc.speed === 'auto' ? ' auto-negotiation=yes' : ' auto-negotiation=no') : '';
                                const speedPart = pc.speed && pc.speed !== 'auto' ? ` speed=${pc.speed}` : '';
                                const mtuPart = (pc.mtu != null && pc.mtu !== '') ? ` mtu=${pc.mtu}` : '';
                                const l2mtuPart = (pc.l2mtu != null && pc.l2mtu !== '') ? ` l2mtu=${pc.l2mtu}` : '';
                                const commentPart = pc.comment ? ` comment="${pc.comment}"` : '';
                                config += `set [ find default-name=${port} ]${autoNegPart}${commentPart}${speedPart}${mtuPart}${l2mtuPart}\n`;
                                configuredPorts.add(port);
                            });

                            // Optional: disable unused ports for security/power savings (OFF by default to avoid breaking live parity).
                            if (disableUnusedPorts) {
                                const allDevicePorts = [...deviceConfig.ports, ...deviceConfig.sfpPorts];
                                allDevicePorts.forEach(port => {
                                    if (!configuredPorts.has(port) && port !== 'ether1') {
                                        config += `set [ find default-name=${port} ] disabled=yes\n`;
                                    }
                                });
                            }
                        }

                        // 3. Interface VLAN (in-state only)
                        if (isInState && uniqueVlans.length) {
                            config += `/interface vlan\n`;
                            uniqueVlans.forEach(v => {
                                const vlanName = `vlan${v.vid}-${v.parent}`;
                                const commentStr = v.comment ? ` comment="${v.comment}"` : '';
                                config += `add interface=${v.parent} name=${vlanName} vlan-id=${v.vid}${commentStr}\n`;
                            });
                        }

                        // 4. Interface VPLS (in-state only)
                        if (isInState && enableVPLS) {
                            const vplsRows = Array.from(document.querySelectorAll('#vplsInstances .vpls-item:not(#vplsTemplate)'))
                                .map(item => ({
                                    name: item.querySelector('input[name="vplsName"]')?.value,
                                    peer: item.querySelector('input[name="vplsPeer"]')?.value,
                                    staticId: item.querySelector('input[name="vplsStaticId"]')?.value
                                }))
                                .filter(v => v.name && v.peer && v.staticId);

                            if (vplsRows.length) {
                                config += `/interface vpls\n`;
                                vplsRows.forEach(v => {
                                    config += `add arp=enabled cisco-static-id=${v.staticId} disabled=no mtu=1500 name=${v.name} peer=${v.peer} pw-control-word=disabled pw-l2mtu=1580 pw-type=raw-ethernet\n`;
                                });

                                // If Tarana is enabled, reapply defaults for the new device (after tarana selects populated)
                                if (document.getElementById('enableTarana')?.checked) {
                                    applyTaranaDefaults();
                                }
                            }
                        }

                        // 5. DHCP Configuration (consolidated function call)
                        config = addDHCPConfiguration(config, enableDHCP, routerId, dnsServers, dhcpSecret);

                        // 6. Routing Configuration  
                        // Only emit BGP when MPLS is not enabled
                        if (!enableMPLS) {
                            if (deviceConfig.bgpSyntax === 'v7') {
                                config += `/routing bgp template\nset default as=${bgpAS} disabled=no output.network=bgp-networks router-id=${routerId} routing-table=main\n`;
                            } else {
                                config += `/routing bgp instance\nset default as=${bgpAS} router-id=${routerId}\n`;
                            }
                        }

                        if (deviceConfig.ospfSyntax === 'v7') {
                            config += `/routing ospf instance\nadd disabled=no name=default-v2 router-id=${routerId}\n`;
                            config += `/routing ospf area\nadd area-id=${ospfAreaId} disabled=no instance=default-v2 name=${ospfArea}\n`;
                        } else {
                            config += `/routing ospf instance\nset [ find default=yes ] router-id=${routerId}\n`;
                        }

                        // 7. SNMP Community
                        config += `/snmp community\nset [ find default=yes ] read-access=no\nadd addresses=::/0 name=${snmpCommunity}\n`;

                        // 8. System Logging Action (dynamic syslog server)
                        const syslogServerTower = getSyslogServer();
                        if (syslogServerTower) {
                            config += `/system logging action\nset 0 memory-lines=1000\nset 1 disk-lines-per-file=10000 disk-file-count=3\nadd name=syslog remote=${syslogServerTower} src-address=${routerId} target=remote\n`;
                        } else {
                            config += `/system logging action\nset 0 memory-lines=1000\nset 1 disk-lines-per-file=10000 disk-file-count=3\n`;
                        }

                        // Collect direct portbridge assignments from the Port Configuration section
                        const portBridgeAssignments = Array.from(
                            document.querySelectorAll('#portConfigs .uplink-item:not(#portTemplate)')
                        ).map(item => {
                            const port = item.querySelector('select[name="portName"]')?.value?.trim();
                            const bridge = item.querySelector('select[name="portBridge"]')?.value?.trim();
                            return { port, bridge };
                        }).filter(x => x.port && x.bridge && x.bridge !== '');

                        // 9. Interface Bridge Port
                        if (uniqueVlans.length || portBridgeAssignments.length) {
                            config += `/interface bridge port\n`;

                            // Add VLAN interface bridge assignments
                            uniqueVlans.forEach(v => {
                                const vlanName = `vlan${v.vid}-${v.parent}`;
                                config += `add bridge=${v.bridge} interface=${vlanName}\n`;
                            });

                            // Add direct port bridge assignments from port configuration
                            portBridgeAssignments.forEach(({ port, bridge }) => {
                                config += `add bridge=${bridge} interface=${port}\n`;
                            });
                        }

                        // 10. IP Settings
                        config += `/ip firewall connection tracking\nset udp-timeout=30s\n`;
                        config += `/ip settings\nset max-neighbor-entries=8192\n`;
                        config += `/ipv6 settings\nset disable-ipv6=yes max-neighbor-entries=8192\n`;

                        updateProgressPercent(45);
                        updateProgressStep('Assigning IP addresses and configuring routing...');
                        addProgressLog('info', 'Configuring IP addressing scheme');

                        // 11. IP Addresses
                        config += `/ip address\n`;
                        config += `add address=${routerId} interface=loop0 network=${routerId}\n`;
                        // LAN address only if LAN IP provided and lan-bridge exists
                        if (lanBridgeIP && bridgesNeeded.has('lan-bridge')) {
                            const _lanNet = calculateNetwork(lanBridgeIP);
                            config += `add address=${lanBridgeIP} interface=lan-bridge network=${_lanNet}\n`;
                        }
                        // NAT public address only if provided and nat-public-bridge exists
                        if (natPublicIPRaw && bridgesNeeded.has('nat-public-bridge')) {
                            const natPublicIP = natPublicIPRaw.includes('/') ? natPublicIPRaw : `${natPublicIPRaw}/32`;
                            const _natNet = calculateNetwork(natPublicIP);
                            config += `add address=${natPublicIP} interface=nat-public-bridge network=${_natNet}\n`;
                        }

                        updateProgressPercent(75);
                        updateProgressStep('Configuring Tarana sectors and wireless settings...');
                        addProgressLog('info', 'Processing Tarana sector configuration');

                        // If Tarana optional feature is enabled, append Tarana sector configuration
                        if (enableTarana) {
                            try {
                                const tAlpha = document.getElementById('tower_tarana_alpha')?.value;
                                const tBeta = document.getElementById('tower_tarana_beta')?.value;
                                const tGamma = document.getElementById('tower_tarana_gamma')?.value;
                                const tDelta = document.getElementById('tower_tarana_delta')?.value;
                                const unicornSubnet = document.getElementById('tower_unicornmgmt_subnet')?.value.trim();

                                const taranaBlock = generateTowerTaranaBlock({
                                    alpha: tAlpha,
                                    beta: tBeta,
                                    gamma: tGamma,
                                    delta: tDelta,
                                    unicornSubnet
                                }, deviceConfig);

                                config += `\n################################\n###       TARANA SECTORS     ###\n################################\n\n`;
                                config += taranaBlock;
                            } catch (err) {
                                console.error('Tarana generation error', err);
                            }
                        }

                        // Uplink addresses - process all uplinks dynamically (OLD STRUCTURE: #uplinks)
                        const allUplinkElementsAddr = document.querySelectorAll('#uplinks .uplink-item:not(#uplinkTemplate)');
                        allUplinkElementsAddr.forEach((element, index) => {
                            // Try multiple selectors to find the IP input
                            const ip = element.querySelector('input[placeholder*="IP/Net"]')?.value ||
                                element.querySelector('input[id*="Ip"]')?.value ||
                                element.querySelector('input[placeholder*="Backhaul IP"]')?.value;
                            const port = element.querySelector('select[id*="NewPort"]')?.value;
                            const comment = element.querySelector('input[id*="Comment"]')?.value || `Uplink-${index + 1}`;

                            if (ip && port) {
                                const network = calculateNetwork(ip);
                                config += `add address=${ip} comment="${comment}" interface=${port} network=${network}\n`;
                            }
                        });

                        // NEW STRUCTURE: #portConfigs with portUplinkType="routed"
                        const newPortUplinkElementsAddr = document.querySelectorAll('#portConfigs .uplink-item:not(#portUplinkTemplate)');
                        newPortUplinkElementsAddr.forEach((element, index) => {
                            const portType = element.querySelector('select[name="portUplinkType"]')?.value;
                            if (portType === 'routed') {
                                const port = element.querySelector('select[name="portUplinkPort"]')?.value;
                                const ip = element.querySelector('input[name="portUplinkIp"]')?.value;
                                const comment = element.querySelector('input[name="portUplinkComment"]')?.value || `Uplink-${index + 1}`;

                                if (ip && port) {
                                    const network = calculateNetwork(ip);
                                    config += `add address=${ip} comment="${comment}" interface=${port} network=${network}\n`;
                                }
                            }
                        });

                        // Additional IP addresses for DHCP pools
                        if (enableDHCP) {
                            const cgnatRange = document.getElementById('cgnatRange').value.trim();
                            const unauthRange = document.getElementById('unauthRange').value.trim();
                            const vlan4000Range = document.getElementById('vlan4000Range').value.trim();

                            if (cgnatRange && cgnatRange.includes('/')) {
                                const [cgnatNet, cgnatCidr] = cgnatRange.split('/');
                                const cgnatGateway = cgnatNet.split('.').map((octet, i) => i === 3 ? '1' : octet).join('.');
                                const cgnatNetwork = calculateNetwork(cgnatRange);
                                config += `add address=${cgnatGateway}/${cgnatCidr} interface=lan-bridge network=${cgnatNetwork}\n`;
                            }
                            if (unauthRange && unauthRange.includes('/')) {
                                const [unauthNet, unauthCidr] = unauthRange.split('/');
                                const unauthGateway = unauthNet.split('.').map((octet, i) => i === 3 ? '1' : octet).join('.');
                                const unauthNetwork = calculateNetwork(unauthRange);
                                config += `add address=${unauthGateway}/${unauthCidr} interface=lan-bridge network=${unauthNetwork}\n`;
                            }
                            if (document.getElementById('enableSWT').checked && vlan4000Range && vlan4000Range.includes('/')) {
                                const [vlan4000Net, vlan4000Cidr] = vlan4000Range.split('/');
                                const vlan4000Gateway = vlan4000Net.split('.').map((octet, i) => i === 3 ? '1' : octet).join('.');
                                const vlan4000Network = calculateNetwork(vlan4000Range);
                                config += `add address=${vlan4000Gateway}/${vlan4000Cidr} interface=bridge4000 network=${vlan4000Network}\n`;
                            }
                        }

                        // 12. IP DNS
                        config += `/ip dns\nset max-udp-packet-size=512 servers=${dnsServers}\n`;

                        // 13. Firewall Configuration
                        // In-state runs RFC baseline which already owns filter/raw/nat; only add address-lists to keep references valid.
                        config = addFirewallConfiguration(config, enableDHCP, enableMPLS, isInState ? { listsOnly: true } : {});

                        // 14. IP Service
                        // Handled by the selected baseline (RFC hardening or out-of-state), so we don't override ports/toggles here.
                        // 15. MPLS Configuration (consolidated function call)
                        config = addMPLSConfiguration(config, enableMPLS, uplinkCount, deviceConfig);
                        updateProgressPercent(60);
                        updateProgressStep('Configuring routing protocols (BGP/OSPF)...');
                        addProgressLog('info', 'Setting up dynamic routing');

                        // 16. Routing BGP Connection (only when MPLS is OFF)
                        if (!enableMPLS) {
                            if (deviceConfig.bgpSyntax === 'v7') {
                                config += `/routing bgp connection\n`;
                                try {
                                    const peers = JSON.parse(bgpPeersJson);
                                    peers.forEach(peer => {
                                        config += `add cisco-vpls-nlri-len-fmt=auto-bits connect=yes disabled=no listen=yes local.address=${routerId} .role=ibgp multihop=yes name=${peer.name} remote.address=${peer.remote} .as=${bgpAS} .port=179 tcp-md5-key=${sharedKey} templates=default\n`;
                                    });
                                } catch (e) {
                                    config += `# Error parsing BGP peers JSON; add manually\n`;
                                }
                            } else {
                                config += `/routing bgp peer\n`;
                                try {
                                    const peers = JSON.parse(bgpPeersJson);
                                    peers.forEach(peer => {
                                        config += `add in-filter=bgr-a-bgp-in-filter multihop=yes name=${peer.name} remote-address=${peer.remote} remote-as=${bgpAS} tcp-md5-key=${sharedKey} ttl=default update-source=loop0\n`;
                                    });
                                } catch (e) {
                                    config += `# Error parsing BGP peers JSON; add manually\n`;
                                }
                            }
                        } else {
                            config += `# BGP omitted (MPLS selected)\n`;
                        }

                        // 17. Routing OSPF Interface Configuration
                        if (deviceConfig.ospfSyntax === 'v7') {
                            config += `/routing ospf interface-template\n`;
                            config += `add area=${ospfArea} disabled=no interfaces=loop0 networks=${routerId}/32 passive priority=1\n`;

                            // OSPF LAN template only if we actually have a LAN Bridge IP + lan-bridge
                            if (lanBridgeIP && bridgesNeeded.has('lan-bridge')) {
                                const lanNetwork = calculateNetwork(lanBridgeIP);
                                const lanCidr = lanBridgeIP.split('/')[1];
                                config += `add area=${ospfArea} disabled=no interfaces=lan-bridge networks=${lanNetwork}/${lanCidr} priority=1\n`;
                            }

                            // Process all uplinks dynamically (OLD STRUCTURE: #uplinks)
                            const allUplinkElementsOSPF = document.querySelectorAll('#uplinks .uplink-item:not(#uplinkTemplate)');
                            allUplinkElementsOSPF.forEach((element, index) => {
                                const ip = element.querySelector('input[placeholder*="IP/Net"], input[id*="Ip"]')?.value;
                                const port = element.querySelector('select[id*="NewPort"]')?.value;
                                const comment = element.querySelector('input[id*="Comment"]')?.value || `Uplink-${index + 1}`;
                                const cost = element.querySelector('input[id*="Cost"]')?.value || 10;

                                if (ip && port) {
                                    const network = calculateNetwork(ip);
                                    const cidr = ip.split('/')[1];
                                    config += `add area=${ospfArea} auth=md5 auth-id=1 auth-key=${sharedKey} comment="${comment}" cost=${cost} disabled=no interfaces=${port} networks=${network}/${cidr} priority=1 type=ptp\n`;
                                }
                            });

                            // NEW STRUCTURE: #portConfigs with portUplinkType="routed"
                            const newPortUplinkElementsOSPF = document.querySelectorAll('#portConfigs .uplink-item:not(#portUplinkTemplate)');
                            newPortUplinkElementsOSPF.forEach((element, index) => {
                                const portType = element.querySelector('select[name="portUplinkType"]')?.value;
                                if (portType === 'routed') {
                                    const port = element.querySelector('select[name="portUplinkPort"]')?.value;
                                    const ip = element.querySelector('input[name="portUplinkIp"]')?.value;
                                    const comment = element.querySelector('input[name="portUplinkComment"]')?.value || `Uplink-${index + 1}`;
                                    const cost = element.querySelector('input[name="portUplinkCost"]')?.value || 10;

                                    if (ip && port) {
                                        const network = calculateNetwork(ip);
                                        const cidr = ip.split('/')[1];
                                        config += `add area=${ospfArea} auth=md5 auth-id=1 auth-key=${sharedKey} comment="${comment}" cost=${cost} disabled=no interfaces=${port} networks=${network}/${cidr} priority=1 type=ptp\n`;
                                    }
                                }
                            });
                        } else {
                            // RouterOS v6 syntax
                            config += `/routing ospf interface\n`;
                            config += `add authentication=md5 authentication-key=${sharedKey} comment=loop0 interface=loop0 network-type=point-to-point\n`;

                            // Process all uplinks dynamically (including those added via "Add Uplink" button)
                            const allUplinkElementsOSPF = document.querySelectorAll('#uplinks .uplink-item:not(#uplinkTemplate)');
                            allUplinkElementsOSPF.forEach((element, index) => {
                                const ip = element.querySelector('input[placeholder*="IP/Net"], input[id*="Ip"]')?.value;
                                const port = element.querySelector('select[id*="NewPort"]')?.value;
                                const comment = element.querySelector('input[id*="Comment"]')?.value || `Uplink-${index + 1}`;

                                if (ip && port) {
                                    config += `add authentication=md5 authentication-key=${sharedKey} comment="${comment}" interface=${port} network-type=point-to-point\n`;
                                }
                            });

                            config += `/routing ospf network\n`;
                            config += `add area=backbone comment=loop0 network=${routerId}/32\n`;

                            // OSPF LAN network only if we actually have a LAN Bridge IP + lan-bridge
                            if (lanBridgeIP && bridgesNeeded.has('lan-bridge')) {
                                const lanNetwork = calculateNetwork(lanBridgeIP);
                                const lanCidr = lanBridgeIP.split('/')[1];
                                config += `add area=backbone comment=LAN network=${lanNetwork}/${lanCidr}\n`;
                            }

                            // Process all uplinks for network configuration
                            allUplinkElementsOSPF.forEach((element, index) => {
                                const ip = element.querySelector('input[placeholder*="IP/Net"], input[id*="Ip"]')?.value;
                                const port = element.querySelector('select[id*="NewPort"]')?.value;
                                const comment = element.querySelector('input[id*="Comment"]')?.value || `Uplink-${index + 1}`;

                                if (ip && port) {
                                    const network = calculateNetwork(ip);
                                    const cidr = ip.split('/')[1];
                                    config += `add area=backbone comment="${comment}" network=${network}/${cidr}\n`;
                                }
                            });
                        }
                    } else {
                        addProgressLog('info', 'Out-of-state/simple baseline selected: generating baseline-only config');
                        updateProgressPercent(60);
                        updateProgressStep('Baseline configuration generated');
                    }

                    // 18. SNMP
                    config += `/snmp\nset enabled=yes src-address=${routerId} trap-community=${snmpCommunity}\n`;

                    // 19. System Configuration
                    config += `/system clock\nset time-zone-name=America/Chicago\n`;
                    config += `/system identity\nset name=${systemName}\n`;
                    // 20. System Logging
                    config += `/system logging\n`;
                    config += `add action=syslog topics=critical\n`;
                    config += `add action=syslog topics=error\n`;
                    config += `add action=syslog topics=warning\n`;
                    config += `add action=disk topics=critical\n`;
                    config += `add action=disk topics=error\n`;
                    config += `add action=disk topics=warning\n`;
                    config += `add action=memory topics=critical\n`;
                    config += `add action=memory topics=error\n`;
                    config += `add action=memory topics=warning\n`;
                    config += `set 0 action=echo\n`;

                    // 21. System NTP Client
                    config += `/system ntp client\nset enabled=yes\n`;
                    config += `/system ntp client servers\n`;
                    const ntpServers = getNTPServer();
                    // Always add default NTP servers
                    ntpServers.defaults.forEach(server => {
                        config += `add address=${server}\n`;
                    });
                    // Add custom NTP server if configured
                    if (ntpServers.custom) {
                        config += `add address=${ntpServers.custom}\n`;
                    }

                    // 22. System RouterBoard Settings
                    config += `/system routerboard settings\nset auto-upgrade=yes\n`;

                    // 23. System Watchdog
                    config += `/system watchdog\nset watchdog-timer=yes\n`;

                    // 24. User AAA (RADIUS login is enabled only when login servers are configured)
                    const loginRadius = (typeof getRADIUSLoginServers === 'function') ? getRADIUSLoginServers() : [];
                    const hasLoginRadius = Array.isArray(loginRadius) && loginRadius.some(s => s && s.address && s.secret);
                    config += `/user aaa\nset use-radius=${hasLoginRadius ? 'yes' : 'no'}\n`;

                    // Add dynamic configurations for user-selected features (in-state only)
                    if (isInState) {
                        config = addDynamicConfigurations(config, enableTarana, enableSWT, enableVPLS, enableMPLS, enableDHCP, lanBridgeIP, cgnatRange, unauthRange, vlan4000Range, routerId, sharedKey);
                    }

                    // Add device-specific optimizations
                    config = generateDeviceSpecificConfig(config, deviceConfig, targetDevice);

                    // Add System Scripts (Backup and Monitoring) - in-state only
                    if (isInState) {
                        config += `# SYSTEM SCRIPTS\n`;
                        config += `/system scheduler\n`;
                        config += `add interval=1d name=nightly on-event="/system script run \"backup\"\\r\\n    \\n/system script run \"dhcp-count\"\\r\\n    \\n" policy=ftp,reboot,read,write,policy,test,password,sniff,sensitive start-date=2013-06-21 start-time=00:00:00\n\n`;

                        config += `/system script\n`;
                        // Backup script - only include if backup is configured
                        if (typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' &&
                            NEXTLINK_INFRASTRUCTURE.backup &&
                            NEXTLINK_INFRASTRUCTURE.backup.enabled &&
                            NEXTLINK_INFRASTRUCTURE.backup.ftpHost &&
                            NEXTLINK_INFRASTRUCTURE.backup.ftpUser &&
                            NEXTLINK_INFRASTRUCTURE.backup.ftpPassword) {
                            const backup = NEXTLINK_INFRASTRUCTURE.backup;
                            config += `add dont-require-permissions=no name=backups owner=root policy=ftp,reboot,read,write,policy,test,password,sniff,sensitive source="# automated backup 2 External ftp\\r\\n    \\n\\r\\n    \\n# ftp configuration\\r\\n    \\n:local ftphost \"${backup.ftpHost}\"\\r\\n    \\n:local ftpuser \"${backup.ftpUser}\"\\r\\n    \\n:local ftppassword \"${backup.ftpPassword}\"\\r\\n    \\n:local ftppath \"${backup.ftpPath || 'backups'}\"\\r\\n    \\n\\r\\n    \\n# months array\\r\\n    \\n:local months (\"jan\",\"feb\",\"mar\",\"apr\",\"may\",\"jun\",\"jul\",\"aug\",\"sep\",\"oct\",\"nov\",\"dec\");\\r\\n    \\n\\r\\n    \\n# get time\\r\\n    \\n:local ts [/system clock get time]\\r\\n    \\n:set ts ([:pick \\$ts 0 2].[:pick \\$ts 3 5].[:pick \\$ts 6 8])\\r\\n    \\n\\r\\n    \\n# get Date\\r\\n    \\n:local ds [/system clock get date]\\r\\n    \\n# convert name of month to number\\r\\n    \\n:local month [ :pick \\$ds 0 3 ];\\r\\n    \\n:local mm ([ :find \\$months \\$month -1 ] + 1);\\r\\n    \\n:if (\\$mm < 10) do={ :set mm (\"0\" . \\$mm); }\\r\\n    \\n# set \\$ds to format YYYY-MM-DD\\r\\n    \\n:set ds ([:pick \\$ds 7 11] . \\$mm . [:pick \\$ds 4 6])\\r\\n    \\n\\r\\n    \\n\\r\\n    \\n# file name for system backup - file name will be servername-date-time.backup\\r\\n    \\n:local fname1 ([/system identity get name].\"-\".\\$ds.\"-\".\\$ts.\".backup\")\\r\\n    \\n# file name for config export - file name will be servername-date-time.rsc\\r\\n    \\n:local fname2 ([/system identity get name].\"-\".\\$ds.\"-\".\\$ts.\".rsc\")\\r\\n    \\n\\r\\n    \\n# backup the data\\r\\n    \\n\\r\\n    \\n/system backup save name=\\$fname1\\r\\n    \\n:log info message=\"System backup finished (1/2).\";\\r\\n    \\n/export compact file=\\$fname2\\r\\n    \\n:log info message=\"Config export finished (2/2).\"\\r\\n    \\n\\r\\n    \\n\\r\\n    \\n# upload the system backup\\r\\n    \\n:log info message=\"Uploading system backup (1/2).\"\\r\\n    \\n/tool fetch address=\"\\$ftphost\" src-path=\\$fname1 user=\"\\$ftpuser\" mode=ftp password=\"\\$ftppassword\" dst-path=\"\\$ftppath/\\$fname1\" upload=yes\\r\\n    \\n# upload the config export\\r\\n    \\n:log info message=\"Uploading config export (2/2).\"\\r\\n    \\n/tool fetch address=\"\\$ftphost\" src-path=\\$fname2 user=\"\\$ftpuser\" mode=ftp password=\"\\$ftppassword\" dst-path=\"\\$ftppath/\\$fname2\" upload=yes\\r\\n    \\n\\r\\n    \\n# delay time to finish the upload - increase it if your backup file is big\\r\\n    \\n:delay 60s;\\r\\n    \\n# find and remove old backup files\\r\\n    \\n:foreach i in=[/file find] do={ :if ([:typeof [:find [/file get \\$i name] \"RTR-\"]]!=\"nil\") do={/file remove \\$i}; }\\r\\n    \\n:log info message=\"Configuration backup finished.\";"\n`;
                        }
                        config += `add dont-require-permissions=no name=dhcp-count owner=root policy=ftp,reboot,read,write,policy,test,password,sniff,sensitive,romon source="# List stats for IP -> Pool\\r\\n    \\n#\\r\\n    \\n# criticalthreshold = output pool display in red if pool used is above this %\\r\\n    \\n# warnthreshold = output pool display in gold if pool used is above this %\\r\\n    \\n\\r\\n    \\n:local criticalthreshold 85\\r\\n    \\n:local warnthreshold 70\\r\\n    \\n\\r\\n    \\n# Internal processing below...\\r\\n    \\n# ----------------------------------\\r\\n    \\n/ip pool {\\r\\n    \\n   :local poolname\\r\\n    \\n   :local pooladdresses\\r\\n    \\n   :local poolused\\r\\n    \\n   :local poolpercent\\r\\n    \\n   :local minaddress\\r\\n    \\n   :local maxaddress\\r\\n    \\n   :local findindex\\r\\n    \\n   :local tmpint\\r\\n    \\n   :local maxindex\\r\\n    \\n   :local line\\r\\n    \\n\\r\\n    \\n   :put (\"IP Pool Statistics\")\\r\\n    \\n   :put (\"------------------\")\\r\\n    \\n\\r\\n    \\n# Iterate through IP Pools\\r\\n    \\n   :foreach p in=[find] do={\\r\\n    \\n\\r\\n    \\n      :set poolname [get \\$p name]\\r\\n    \\n      :set pooladdresses 0\\r\\n    \\n      :set poolused 0\\r\\n    \\n      :set line \"\"\\r\\n    \\n\\r\\n    \\n      :set line (\"     \" . \\$poolname)\\r\\n    \\n\\r\\n    \\n#   Iterate through current pool's IP ranges\\r\\n    \\n      :foreach r in=[:toarray [get \\$p range]] do={\\r\\n    \\n\\r\\n    \\n#      Get min and max addresses\\r\\n    \\n         :set findindex [:find [:tostr \\$r] \"-\"]\\r\\n    \\n         :if ([:len \\$findindex] > 0) do={\\r\\n    \\n            :set minaddress [:pick [:tostr \\$r] 0 \\$findindex]\\r\\n    \\n            :set maxaddress [:pick [:tostr \\$r] (\\$findindex + 1) [:len [:tostr \\$r]]]\\r\\n    \\n         } else={\\r\\n    \\n            :set minaddress [:tostr \\$r]\\r\\n    \\n            :set maxaddress [:tostr \\$r]\\r\\n    \\n         }\\r\\n    \\n\\r\\n    \\n#       Convert to array of octets (replace '.' with ',')\\r\\n    \\n         :for x from=0 to=([:len [:tostr \\$minaddress]] - 1) do={\\r\\n    \\n            :if ([:pick [:tostr \\$minaddress] \\$x (\\$x + 1)] = \".\") do={\\r\\n    \\n               :set minaddress ([:pick [:tostr \\$minaddress] 0 \\$x] . \",\" . \\\\\\r\\n    \\n                                       [:pick [:tostr \\$minaddress] (\\$x + 1) [:len [:tostr \\$minaddress]]]) }\\r\\n    \\n         }\\r\\n    \\n         :for x from=0 to=([:len [:tostr \\$maxaddress]] - 1) do={\\r\\n    \\n            :if ([:pick [:tostr \\$maxaddress] \\$x (\\$x + 1)] = \".\") do={\\r\\n    \\n               :set maxaddress ([:pick [:tostr \\$maxaddress] 0 \\$x] . \",\" . \\\\\\r\\n    \\n                                       [:pick [:tostr \\$maxaddress] (\\$x + 1) [:len [:tostr \\$maxaddress]]]) }\\r\\n    \\n         }\\r\\n    \\n\\r\\n    \\n#      Calculate available addresses for current range\\r\\n    \\n         :if ([:len [:toarray \\$minaddress]] = [:len [:toarray \\$maxaddress]]) do={\\r\\n    \\n            :set maxindex ([:len [:toarray \\$minaddress]] - 1)\\r\\n    \\n            :for x from=\\$maxindex to=0 step=-1 do={\\r\\n    \\n#             Calculate 256^(\\$maxindex - \\$x)\\r\\n    \\n               :set tmpint 1\\r\\n    \\n               :if ((\\$maxindex - \\$x) > 0) do={\\r\\n    \\n                  :for y from=1 to=(\\$maxindex - \\$x) do={ :set tmpint (256 * \\$tmpint) }\\r\\n    \\n               }\\r\\n    \\n               :set tmpint (\\$tmpint * ([:tonum [:pick [:toarray \\$maxaddress] \\$x]] - \\\\\\r\\n    \\n                                                    [:tonum [:pick [:toarray \\$minaddress] \\$x]]) )\\r\\n    \\n               :set pooladdresses (\\$pooladdresses + \\$tmpint)\\r\\n    \\n#         for x\\r\\n    \\n            }\\r\\n    \\n\\r\\n    \\n#      if len array \\$minaddress = \\$maxaddress\\r\\n    \\n         }\\r\\n    \\n\\r\\n    \\n#      Add current range to total pool's available addresses\\r\\n    \\n         :set pooladdresses (\\$pooladdresses + 1)\\r\\n    \\n\\r\\n    \\n#   foreach r\\r\\n    \\n      }\\r\\n    \\n\\r\\n    \\n#   Now, we have the available address for all ranges in this pool\\r\\n    \\n#   Get the number of used addresses for this pool\\r\\n    \\n      :set poolused [:len [used find pool=[:tostr \\$poolname]]]\\r\\n    \\n      :set poolpercent ((\\$poolused * 100) / \\$pooladdresses)\\r\\n    \\n\\r\\n    \\n#   Output information\\r\\n    \\n      :set line ([:tostr \\$line] . \"  [\" . \\$poolused . \"/\" . \\$pooladdresses . \"]\")\\r\\n    \\n      :set line ([:tostr \\$line] . \"  \" . \\$poolpercent . \" % used\")\\r\\n    \\n\\r\\n    \\n#   Set colored display for used thresholds\\r\\n    \\n      :if ( [:tonum \\$poolpercent] > \\$criticalthreshold ) do={\\r\\n    \\n         :log error (\"IP Pool \" . \\$poolname . \" is \" . \\$poolpercent . \"% full\")\\r\\n    \\n         :put ([:terminal style varname] . \\$line)\\r\\n    \\n         :local Subject ([/system identity get name] . \" DHCP pool \\$poolname is at \\$poolpercent % Full\")\\r\\n    \\n         :local Body (\"\\$poolused of \\$pooladdresses used\")\\r\\n    \\n         :if ([:len [/tool e-mail find where to="${typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' && NEXTLINK_INFRASTRUCTURE.emailAlerts && NEXTLINK_INFRASTRUCTURE.emailAlerts.enabled ? NEXTLINK_INFRASTRUCTURE.emailAlerts.recipient : ''}"]] > 0) do={ /tool e-mail send to="${typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' && NEXTLINK_INFRASTRUCTURE.emailAlerts && NEXTLINK_INFRASTRUCTURE.emailAlerts.enabled ? NEXTLINK_INFRASTRUCTURE.emailAlerts.recipient : ''}" subject=\\$Subject body=\\$Body from="${typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' && NEXTLINK_INFRASTRUCTURE.emailAlerts && NEXTLINK_INFRASTRUCTURE.emailAlerts.enabled ? NEXTLINK_INFRASTRUCTURE.emailAlerts.from : 'alerts@configmaker.local'}" }\\r\\n    \\n      } else={\\r\\n    \\n         :if ( [:tonum \\$poolpercent] > \\$warnthreshold ) do={\\r\\n    \\n            :log warning (\"IP Pool \" . \\$poolname . \" is \" . \\$poolpercent . \"% full\")\\r\\n    \\n            :put ([:terminal style syntax-meta] . \\$line)\\r\\n    \\n            :local Subject ([/system identity get name] . \" DHCP pool \\$poolname is at \\$poolpercent % Full\")\\r\\n    \\n            :local Body (\"\\$poolused of \\$pooladdresses used\")\\r\\n    \\n            :if ([:len [/tool e-mail find where to="${typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' && NEXTLINK_INFRASTRUCTURE.emailAlerts && NEXTLINK_INFRASTRUCTURE.emailAlerts.enabled ? NEXTLINK_INFRASTRUCTURE.emailAlerts.recipient : ''}"]] > 0) do={ /tool e-mail send to="${typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' && NEXTLINK_INFRASTRUCTURE.emailAlerts && NEXTLINK_INFRASTRUCTURE.emailAlerts.enabled ? NEXTLINK_INFRASTRUCTURE.emailAlerts.recipient : ''}" subject=\\$Subject body=\\$Body from="${typeof NEXTLINK_INFRASTRUCTURE !== 'undefined' && NEXTLINK_INFRASTRUCTURE.emailAlerts && NEXTLINK_INFRASTRUCTURE.emailAlerts.enabled ? NEXTLINK_INFRASTRUCTURE.emailAlerts.from : 'alerts@configmaker.local'}" }\\r\\n    \\n         } else={\\r\\n    \\n            :put ([:terminal style none] . \\$line)\\r\\n    \\n         }\\r\\n    \\n      }\\r\\n    \\n\\r\\n    \\n# foreach p\\r\\n    \\n   }\\r\\n    \\n# /ip pool\\r\\n    \\n}"\n\n`;
                    }

                    // Add NextLink compliance footer
                    config += `\n# ========================================\n`;
                    config += `# NextLink RFC Compliance Footer\n`;
                    config += `# ========================================\n`;
                    config += `# Configuration follows RFC compliance standards\n`;
                    config += `# Baseline hardening applied\n`;
                    config += `# Dynamic features configured based on selections\n`;
                    config += `# Ready for deployment\n`;
                    config += `# Backup recommended before import\n`;
                    config += `# ========================================\n`;

                    // Normalize the config order to match RouterOS standard
                    const normalizedConfig = normalizeConfigOrder(config);

                    // Separate metadata from router commands
                    const metadataOutput = document.getElementById('metadataOutput');
                    const configOutput = document.getElementById('output');
                    // Split config into metadata (comments) and router commands
                    const lines = normalizedConfig.split('\n');
                    let metadata = [];
                    let routerCommands = [];

                    for (const line of lines) {
                        if (line.trim().startsWith('#') || line.trim().startsWith(':global') || line.trim() === '') {
                            metadata.push(line);
                        } else {
                            routerCommands.push(line);
                        }
                    }

                    metadataOutput.value = metadata.join('\n');
                    configOutput.value = routerCommands.join('\n');
                    downloadBtn.disabled = false;

                    // Auto-save completed config
                    const fullConfig = normalizedConfig;
                    saveCompletedConfig({
                        config_type: 'tower',
                        device_name: systemName,
                        device_type: targetDevice,
                        customer_code: '',
                        loopback_ip: routerId,
                        routeros_version: targetRouterOS,
                        config_content: fullConfig,
                        site_name: siteName,
                        router_id: routerId,
                        lan_bridge_ip: lanBridgeIP,
                        ospf_area: ospfArea,
                        bgp_peers: bgpPeersJson ? JSON.parse(bgpPeersJson) : [],
                        uplinks: Array.from(document.querySelectorAll('#uplinks .uplink-item:not(#uplinkTemplate)')).map(el => ({
                            port: el.querySelector('select[name="port"]')?.value,
                            ip: el.querySelector('input[name="ip"]')?.value,
                            comment: el.querySelector('input[name="comment"]')?.value
                        })).filter(u => u.port && u.ip)
                    });

                    updateProgressPercent(95);
                    updateProgressStep('Finalizing configuration output...');
                    addProgressLog('info', 'Rendering configuration');

                    // Track activity for live feed
                    saveConfigToHistory({
                        type: 'new-config',
                        device: targetDevice,
                        siteName: siteName || systemName || 'Tower Config',
                        routeros: targetRouterOS,
                        success: true
                    });

                    updateProgressPercent(100);
                    addProgressLog('success', 'Tower configuration generated successfully!');
                    addProgressLog('info', `Config size: ${fullConfig.length} characters`);
                    completeProgressTracker(true);

                    // Auto-update compliance status
                    updateComplianceStatus();
                } catch (error) {
                    console.error('Error in generateConfig:', error);
                    addProgressLog('error', `Generation failed: ${error.message}`);
                    completeProgressTracker(false);

                    // Track failure
                    saveConfigToHistory({
                        type: 'new-config',
                        device: targetDevice || 'Unknown',
                        siteName: siteName || 'Tower Config',
                        routeros: targetRouterOS || 'Unknown',
                        success: false
                    });

                    alert('Error generating configuration: ' + error.message);
                }
            }

            // Initialize all event handlers and main functionality
            console.log('NextLink MikroTik Configuration Generator v2.0 Loaded');
            console.log('Device Support: RB1009, RB2011, CCR1036, RB5009, CCR2004, CCR2216');
            console.log('RouterOS Support: 6.45.2, 6.49.2, 7.11.2, 7.16.2, 7.19.4');
            console.log('Features: Dynamic device selection, compliance validation, auto-configuration');

            // Verify generate functions are accessible
            console.log('Generate functions loaded:', {
                generateConfig: typeof window.generateConfig,
                generateEnterpriseConfig: typeof window.generateEnterpriseConfig,
                generateMPLSEnterpriseConfig: typeof window.generateMPLSEnterpriseConfig
            });

            // Initialize all event handlers
            initializeEventHandlers();

            // Initialize dashboard
            updateDashboardMetrics();
            updateRecentActivity();

            // Load saved theme preference
            const savedTheme = localStorage.getItem('theme') || 'dark';
            document.documentElement.setAttribute('data-theme', savedTheme);
            if (savedTheme !== 'light') localStorage.setItem('theme_last_nonlight', savedTheme);
            const darkToggle = document.getElementById('darkToggle');
            if (darkToggle) {
                darkToggle.innerHTML = savedTheme === 'light' ? ' Light' : ' Dark';
            }

            // Auto-validate on page load
            setTimeout(() => {
                updateComplianceStatus();
            }, 1000);
        });
    </script>

    <script>
        // Enterprise Config Functions
        function updateEnterpriseDeviceName() {
            const deviceType = document.getElementById('ent_deviceType').value;
            const customerCode = document.getElementById('ent_customerCode').value;
            if (deviceType && customerCode) {
                let prefix = 'RTR-MT';
                if (deviceType === 'CCR2004') prefix += 'CCR2004';
                else if (deviceType === 'CCR1036') prefix += 'CCR1036';
                else if (deviceType === 'RB5009') prefix += 'RB-5009';
                else if (deviceType === 'CCR2216') prefix += 'CCR2216';
                document.getElementById('ent_deviceName').value = `${prefix}.${customerCode}`;
            }
        }

        function updateMPLSEnterpriseDeviceName() {
            const deviceType = document.getElementById('ent_mpls_deviceType').value;
            const customerCode = document.getElementById('ent_mpls_customerCode').value;
            if (deviceType && customerCode) {
                let prefix = 'RTR-MT';
                if (deviceType === 'CCR2004') prefix += 'CCR2004';
                else if (deviceType === 'CCR1036') prefix += 'CCR1036';
                else if (deviceType === 'RB5009') prefix += 'RB-5009';
                else if (deviceType === 'CCR2216') prefix += 'CCR2216';
                else if (deviceType === 'CCR1072') prefix += 'CCR1072';
                document.getElementById('ent_mpls_deviceName').value = `${prefix}.${customerCode}`;
            }
        }

        // ===== Enterprise (Non-MPLS) smart auto-fill helpers =====
        function ipToInt(ip) {
            const p = ip.split('.').map(Number);
            return ((p[0] << 24) >>> 0) + (p[1] << 16) + (p[2] << 8) + p[3];
        }
        function intToIp(n) {
            return [n >>> 24 & 255, n >>> 16 & 255, n >>> 8 & 255, n & 255].join('.');
        }
        function parseCidr(cidrStr) {
            if (!cidrStr || cidrStr.indexOf('/') === -1) return null;
            const [ip, maskStr] = cidrStr.trim().split('/');
            const mask = parseInt(maskStr, 10);
            if (isNaN(mask)) return null;
            const ipInt = ipToInt(ip);
            const netMask = mask === 0 ? 0 : (~0 << (32 - mask)) >>> 0;
            const network = ipInt & netMask;
            const broadcast = network + (~netMask >>> 0);
            const firstHost = mask >= 31 ? network : network + 1;
            const lastHost = mask >= 31 ? broadcast : broadcast - 1;
            return { ip, mask, network: intToIp(network >>> 0), broadcast: intToIp(broadcast >>> 0), firstHost: intToIp(firstHost >>> 0), lastHost: intToIp(lastHost >>> 0) };
        }
        function calcPoolExcluding(interfaceIpCidr) {
            const info = parseCidr(interfaceIpCidr);
            if (!info) return '';
            // If only one usable host, pool equals that host if different from interface IP
            const ifaceIp = interfaceIpCidr.split('/')[0];
            const first = ipToInt(info.firstHost);
            const last = ipToInt(info.lastHost);
            const iface = ipToInt(ifaceIp);
            if (first === last) {
                return iface !== first ? `${info.firstHost}-${info.lastHost}` : '';
            }
            // Exclude interface IP; choose continuous range(s)
            if (iface <= first) return `${intToIp(first + 1)}-${info.lastHost}`;
            if (iface >= last) return `${info.firstHost}-${intToIp(last - 1)}`;
            // Interface sits in the middle; prefer the upper slice by default
            const start = iface + 1;
            return `${intToIp(start)}-${info.lastHost}`;
        }
        function updatePublicPoolFromPublicIp() {
            // This function is a duplicate - the correct implementation is at line 10348
            // Keeping this for backward compatibility with the same logic
            const pub = document.getElementById('ent_publicIP')?.value?.trim();
            const out = document.getElementById('ent_publicPool');
            if (!pub || !out) return;

            // Use the same logic as the main function (line 10348)
            try {
                const info = parseCidr(pub);
                if (!info) return;

                const gatewayIP = info.ip;
                const gatewayInt = ipToInt(gatewayIP);
                const networkInt = ipToInt(gatewayIP) & info.mask;
                const broadcastInt = networkInt | (~info.mask >>> 0);

                // For /30: exactly 2 usable IPs (gateway and customer)
                // Customer IP = gateway + 1
                if (info.prefix === 30) {
                    const customerInt = gatewayInt + 1;
                    if (customerInt < broadcastInt) {
                        const customerIP = intToIp(customerInt);
                        out.value = customerIP; // Single IP, no dash format
                    }
                } else if (info.prefix === 29) {
                    const startInt = gatewayInt + 1;
                    const lastUsable = broadcastInt - 1;
                    if (startInt <= lastUsable) {
                        out.value = `${intToIp(startInt)}-${intToIp(lastUsable)}`;
                    }
                } else if (info.prefix >= 28) {
                    const startInt = gatewayInt + 1;
                    const lastUsable = broadcastInt - 1;
                    const endInt = Math.min(startInt + 9, lastUsable);
                    if (startInt <= endInt) {
                        out.value = `${intToIp(startInt)}-${intToIp(endInt)}`;
                    }
                } else {
                    const startInt = gatewayInt + 1;
                    const lastUsable = broadcastInt - 1;
                    const endInt = Math.min(startInt + 19, lastUsable);
                    if (startInt <= endInt) {
                        out.value = `${intToIp(startInt)}-${intToIp(endInt)}`;
                    }
                }
            } catch (e) {
                console.log('Error calculating public pool:', e);
            }
        }
        function updatePrivatePoolFromPrivateIp() {
            const priv = document.getElementById('ent_privateIP')?.value?.trim();
            const out = document.getElementById('ent_privatePool');
            if (!priv || !out) return;
            const [ip, maskStr] = priv.split('/');
            const mask = parseInt(maskStr, 10);
            if (mask === 24) {
                const a = ip.split('.'); a[3] = '10'; const start = a.join('.');
                const b = ip.split('.'); b[3] = '254'; const end = b.join('.');
                out.value = `${start}-${end}`;
            } else {
                const pool = calcPoolExcluding(priv);
                if (pool) out.value = pool;
            }
        }
        function updateGatewayFromUplink() {
            const uplinkIp = document.querySelector('.ent_uplinkIP')?.value?.trim();
            const gw = document.getElementById('ent_gateway');
            if (!uplinkIp || !gw) return;
            const info = parseCidr(uplinkIp);
            if (!info) return;
            gw.value = info.firstHost; // first usable by default
        }
        function getDevicePortOptions(device) {
            const defaults = ['ether7', 'ether8', 'sfp-sfpplus1', 'sfp-sfpplus2'];
            if (!device) return defaults;
            if (device === 'ccr2004') return ['sfp-sfpplus7', 'sfp-sfpplus8', 'sfp-sfpplus1', 'sfp-sfpplus2', 'ether7', 'ether8'];
            if (device === 'ccr1036') return ['sfp-sfpplus7', 'sfp-sfpplus8', 'sfp-sfpplus1', 'sfp-sfpplus2', 'ether7', 'ether8'];
            if (device === 'ccr2216') return ['sfp28-1', 'sfp28-2', 'sfp28-3', 'sfp28-4', 'sfp28-5', 'sfp28-6', 'sfp28-7', 'sfp28-8', 'sfp28-9', 'sfp28-10', 'sfp28-11', 'sfp28-12', 'ether1'];
            if (device === 'rb5009') return ['ether7', 'ether8', 'sfp-sfpplus1', 'ether2', 'ether3', 'ether4', 'ether5', 'ether6'];
            return defaults;
        }
        function repopulateInterfaceSelect(sel, options, prefer) {
            if (!sel) return;
            const current = sel.value;
            sel.innerHTML = '<option value="">Select Interface</option>';
            options.forEach(o => {
                const opt = document.createElement('option');
                opt.value = o; opt.textContent = o; sel.appendChild(opt);
            });
            if (prefer && options.includes(prefer)) sel.value = prefer; else if (options.length) sel.value = options[0];
        }
        function updateEnterpriseInterfaces() {
            const dev = document.getElementById('ent_routerboard_device')?.value;
            const ports = getDevicePortOptions(dev);
            const pubSel = document.getElementById('ent_publicInterface');
            const natSel = document.getElementById('ent_natInterface');
            const bhSel = document.getElementById('ent_backhaulInterface');

            // Auto-select interfaces based on device type and Nextlink policy
            let publicPort, natPort, backhaulPort;

            if (dev === 'rb5009') {
                publicPort = 'ether7';    // Customer Handoff (CX HANDOFF)
                natPort = 'ether8';       // NAT
                backhaulPort = 'sfp-sfpplus1'; // Uplink (Weston)
            } else if (dev === 'ccr2004' || dev === 'ccr1036') {
                publicPort = 'sfp-sfpplus7';  // Customer Handoff
                natPort = 'sfp-sfpplus8';     // NAT
                backhaulPort = 'sfp-sfpplus1'; // Uplink
            } else {
                // Default fallback
                publicPort = ports.find(p => p.includes('ether7')) || ports[0];
                natPort = ports.find(p => p.includes('ether8')) || ports[1];
                backhaulPort = ports.find(p => p.startsWith('sfp')) || ports[2];
            }

            repopulateInterfaceSelect(pubSel, ports, publicPort);
            repopulateInterfaceSelect(natSel, ports, natPort);
            repopulateInterfaceSelect(bhSel, ports, backhaulPort);
        }

        function handleEntDeviceChange() {
            const dev = document.getElementById('ent_routerboard_device')?.value || '';
            // Map routerboard device to deviceType for naming
            const map = { ccr2004: 'CCR2004', ccr2216: 'CCR2216', ccr1036: 'CCR1036', rb5009: 'RB5009', ccr1072: 'CCR1072', rb2011: 'RB2011', rb1009: 'RB1009' };
            const mappedType = map[dev] || '';
            const typeSel = document.getElementById('ent_deviceType');
            if (typeSel && mappedType) { typeSel.value = mappedType; updateEnterpriseDeviceName(); }
            updateEnterpriseInterfaces();
        }

        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('ent_deviceType').addEventListener('change', updateEnterpriseDeviceName);
            document.getElementById('ent_customerCode').addEventListener('input', updateEnterpriseDeviceName);
            // Auto-fill bindings for Enterprise (Non-MPLS)
            const entDev = document.getElementById('ent_routerboard_device');
            if (entDev) entDev.addEventListener('change', handleEntDeviceChange);
            const pubIp = document.getElementById('ent_publicIP');
            if (pubIp) pubIp.addEventListener('input', updatePublicPoolFromPublicIp);
            const privIp = document.getElementById('ent_privateIP');
            if (privIp) privIp.addEventListener('input', updatePrivatePoolFromPrivateIp);
            const uplink = document.querySelector('.ent_uplinkIP');
            if (uplink) uplink.addEventListener('input', updateGatewayFromUplink);
            // Initial population
            handleEntDeviceChange();
            updatePublicPoolFromPublicIp();
            updatePrivatePoolFromPrivateIp();
            updateGatewayFromUplink();
            // Mark computed fields read-only for clarity
            const pubPool = document.getElementById('ent_publicPool');
            const priPool = document.getElementById('ent_privatePool');
            const gw = document.getElementById('ent_gateway');
            [pubPool, priPool, gw].forEach(el => { if (el) { el.readOnly = true; el.style.background = 'var(--output-bg)'; } });

            // Optional OSPF/BGP features event handlers
            const enableOSPF = document.getElementById('ent_enableOSPF');
            const enableBGP = document.getElementById('ent_enableBGP');
            const ospfBgpConfig = document.getElementById('ent_ospfBgpConfig');
            const ospfArea = document.getElementById('ent_ospfArea');
            const customOspfArea = document.getElementById('ent_customOspfArea');

            function toggleOspfBgpConfig() {
                if (enableOSPF.checked || enableBGP.checked) {
                    ospfBgpConfig.style.display = 'block';
                } else {
                    ospfBgpConfig.style.display = 'none';
                }
            }

            function toggleCustomOspfArea() {
                if (ospfArea.value === 'custom') {
                    customOspfArea.style.display = 'block';
                } else {
                    customOspfArea.style.display = 'none';
                }
            }

            if (enableOSPF) enableOSPF.addEventListener('change', toggleOspfBgpConfig);
            if (enableBGP) enableBGP.addEventListener('change', toggleOspfBgpConfig);
            if (ospfArea) ospfArea.addEventListener('change', toggleCustomOspfArea);

            // MPLS Enterprise event handlers
            const entMplsDevice = document.getElementById('ent_mpls_routerboard_device');
            const entMplsCustomerCode = document.getElementById('ent_mpls_customerCode');
            const generateMPLSBtn = document.getElementById('generateMPLSEnterpriseBtn');

            if (entMplsDevice) {
                entMplsDevice.addEventListener('change', function () {
                    if (window.updateMPLSDeviceName) window.updateMPLSDeviceName();
                    if (typeof updateMPLSEnterpriseInterfaces === 'function') updateMPLSEnterpriseInterfaces();
                });
            }
            if (entMplsCustomerCode) {
                entMplsCustomerCode.addEventListener('input', function () {
                    if (window.updateMPLSDeviceName) window.updateMPLSDeviceName();
                });
            }
            if (generateMPLSBtn) {
                generateMPLSBtn.addEventListener('click', generateMPLSEnterpriseConfig);
            }

            // Initialize ports if device is already selected
            if (entMplsDevice && entMplsDevice.value) {
                updateMPLSEnterpriseInterfaces();
            }
        });

        function applyMplsPreset() {
            // Apply a minimal preset: set device type only so UI shows proper interfaces.
            // Do NOT fill customer-specific fields (customerCode/deviceName/IPs/snmp)  this tool is used dynamically per customer.
            document.getElementById('ent_mpls_deviceType').value = 'CCR2004';
            // Do not auto-fill customerCode, deviceName, loopback, public/private IPs, gateway, or SNMP.
            updateMPLSEnterpriseDeviceName();
        }

        function addEnterpriseUplink() {
            const container = document.getElementById('ent_uplinksContainer');
            const newUplink = document.createElement('div');
            newUplink.className = 'interface-item';
            newUplink.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div><label>Uplink Interface:</label>
                        <select class="ent_uplinkInterface">
                            <option value="">Select Interface</option>
                            <option value="sfp-sfpplus1">sfp-sfpplus1</option>
                            <option value="ether1">ether1</option>
                            <option value="ether2">ether2</option>
                            <option value="ether3">ether3</option>
                        </select>
                    </div>
                    <div><label>Uplink IP/Net:</label>
                        <input type="text" class="ent_uplinkIP" placeholder="10.1.241.92/29">
                    </div>
                </div>
                <div style="margin-top: 10px;"><label>Uplink Comment/Location:</label>
                    <input type="text" class="ent_uplinkComment" placeholder="TX-LOCATION-1">
                </div>
                <button class="remove-btn" onclick="this.parentElement.remove()">Remove Uplink</button>
            `;
            container.appendChild(newUplink);
        }

        function calculateNetworkAddress(ipCidr) {
            if (!ipCidr || !ipCidr.includes('/')) return '';
            const parts = ipCidr.split('/');
            const ip = parts[0];
            const cidr = parseInt(parts[1]);
            const ipParts = ip.split('.').map(Number);
            const mask = -1 << (32 - cidr);
            const network = [
                ipParts[0] & (mask >> 24 & 255),
                ipParts[1] & (mask >> 16 & 255),
                ipParts[2] & (mask >> 8 & 255),
                ipParts[3] & (mask & 255)
            ];
            return network.join('.');
        }
        window.generateEnterpriseConfig = function () {
            try {
                // Show MUSHU-style live progress tracker
                showProgressTracker('Enterprise Config Generation');
                updateProgressStep('Initializing and validating input parameters...');
                updateProgressPercent(5);
                addProgressLog('info', 'Starting Enterprise configuration generation');

                const device = (document.getElementById('ent_routerboard_device') || {}).value || '';
                const version = (document.getElementById('ent_routeros_version') || {}).value || '';
                const loopback = (document.getElementById('ent_loopbackIP') || {}).value || '';
                const publicCidr = (document.getElementById('ent_publicIP') || {}).value || '';
                const backhaulIP = (document.getElementById('ent_backhaulIP') || {}).value || '';
                const gatewayIP = (document.getElementById('ent_gatewayIP') || {}).value || '';
                const customerCode = (document.getElementById('ent_customerCode') || {}).value || '';

                addProgressLog('info', `Device: ${device}, RouterOS: ${version}`);
                addProgressLog('info', `Customer: ${customerCode || 'Not specified'}`);

                // Show "ongoing" activity immediately
                showOngoingActivity(`Generating Enterprise Config: ${customerCode || device}`, 'enterprise-non-mpls');

                // Use simple BH field in AI mode if present
                const simpleBh = (document.getElementById('ent_bh_cidr_simple') || {}).value || '';
                const uplinkField = document.querySelector('#ent_uplinksContainer .ent_uplinkIP');
                const bhCidr = uplinkField ? uplinkField.value : '';
                const publicPort = (document.getElementById('ent_publicInterface') || {}).value || '';
                const natPort = (document.getElementById('ent_natInterface') || {}).value || '';
                const uplinkIf = (document.getElementById('ent_backhaulInterface') || {}).value || '';
                const identity = (document.getElementById('ent_deviceName') || {}).value || '';
                const lat = (document.getElementById('ent_latitude') || {}).value || '';
                const lon = (document.getElementById('ent_longitude') || {}).value || '';
                const coords = (lat && lon) ? (lat + ', ' + lon) : undefined;
                const uplinkComment = (document.getElementById('ent_uplinkComment') || {}).value || '';

                const effectiveBh = backhaulIP || simpleBh || bhCidr;
                if (!loopback || !publicCidr || !effectiveBh) {
                    addProgressLog('error', 'Validation failed: Missing Loopback, Public CIDR, or Backhaul CIDR');
                    completeProgressTracker(false);
                    showAIStatus(' Please provide Loopback /32, Public /29|/30, and Backhaul /29|/30.', 'error');
                    return;
                }

                if (!device || !version) {
                    addProgressLog('error', 'Validation failed: Missing device or RouterOS version');
                    completeProgressTracker(false);
                    showAIStatus(' Please select RouterBoard device and RouterOS version.', 'error');
                    return;
                }

                if (!customerCode) {
                    addProgressLog('error', 'Validation failed: Missing customer code');
                    completeProgressTracker(false);
                    showAIStatus(' Please enter customer code.', 'error');
                    return;
                }

                addProgressLog('success', 'Input validation passed');
                updateProgressPercent(10);

                // Get private IP and pool from form
                const privateIP = (document.getElementById('ent_privateIP') || {}).value || '';
                const privatePool = (document.getElementById('ent_privatePool') || {}).value || '';

                const payload = {
                    device,
                    target_version: version,
                    loopback_ip: loopback,
                    public_cidr: publicCidr,
                    bh_cidr: effectiveBh,
                    public_port: publicPort,
                    nat_port: natPort,
                    uplink_interface: uplinkIf,
                    identity,
                    coords,
                    uplink_comment: uplinkComment,  // Uplink comment/location for backhaul
                    private_cidr: privateIP,  // e.g., 192.168.88.1/24
                    private_pool: privatePool  // e.g., 192.168.88.10-192.168.88.254
                };

                const btn = document.getElementById('generateEnterpriseBtn');
                if (btn) { btn.disabled = true; btn.textContent = ' Generating...'; }

                updateProgressStep('Requesting AI suggestions for optimal configuration...');
                updateProgressPercent(15);
                addProgressLog('info', 'Calling AI service for configuration suggestions');
                showAIStatus(' Getting AI suggestions for optimal configuration...', 'info');

                // Stage 1: Ask AI for suggestions to fill any missing/derived values
                const suggestPayload = {
                    device: device, target_version: version, loopback_ip: loopback, public_cidr: publicCidr, bh_cidr: effectiveBh
                };
                let startedEnterpriseGeneration = false;

                robustFetch(`${AI_API_BASE}/suggest-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(suggestPayload)
                }, 3, 1000).then(function (r) {
                    if (!r.ok) {
                        const statusText = r.status === 500 ? 'Server error' : r.status === 404 ? 'Endpoint not found' : `HTTP ${r.status}`;
                        throw new Error(`Backend request failed: ${statusText}`);
                    }
                    return r.json();
                }).then(function (sres) {
                    if (sres && sres.success) {
                        updateProgressPercent(30);
                        addProgressLog('success', 'AI suggestions received successfully');
                        showAIStatus(' AI suggestions received, applying optimizations...', 'success');
                        // Merge helpful suggestions into payload (non-destructive)
                        if (sres.public_port && !publicPort) {
                            payload.public_port = sres.public_port;
                            addProgressLog('info', `AI suggested public port: ${sres.public_port}`);
                        }
                        if (sres.nat_port && !natPort) {
                            payload.nat_port = sres.nat_port;
                            addProgressLog('info', `AI suggested NAT port: ${sres.nat_port}`);
                        }
                        if (sres.uplink_interface && !uplinkIf) {
                            payload.uplink_interface = sres.uplink_interface;
                            addProgressLog('info', `AI suggested uplink interface: ${sres.uplink_interface}`);
                        }
                        if (sres.public_pool && !document.getElementById('ent_publicPool')?.value) {
                            const f = document.getElementById('ent_publicPool'); if (f) f.value = sres.public_pool;
                        }
                        if (sres.gateway && !document.getElementById('ent_gateway')?.value) {
                            const f = document.getElementById('ent_gateway'); if (f) f.value = sres.gateway;
                        }
                    }

                    updateProgressStep('Generating configuration with Nextlink policy compliance...');
                    updateProgressPercent(45);
                    addProgressLog('info', 'Applying Nextlink standards and policies');
                    showAIStatus(' Generating configuration with Nextlink policy compliance...', 'info');

                    // Stage 2: Generate final config
                    startedEnterpriseGeneration = true;
                    return robustFetch(`${AI_API_BASE}/gen-enterprise-non-mpls`, {
                        method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                    }, 3, 1000);
                })
                    .catch(function (err) {
                        // If AI suggestions fail (e.g., Ollama not running on the VM), continue without them.
                        if (startedEnterpriseGeneration) throw err;
                        console.warn('[ENTERPRISE] AI suggestions unavailable; continuing without them:', err);
                        addProgressLog('warning', 'AI suggestions unavailable; continuing without suggestions');
                        showAIStatus('AI suggestions unavailable; generating config without them...', 'warning');

                        updateProgressStep('Generating configuration with Nextlink policy compliance...');
                        updateProgressPercent(45);
                        addProgressLog('info', 'Applying Nextlink standards and policies');
                        showAIStatus('Generating configuration with Nextlink policy compliance...', 'info');

                        startedEnterpriseGeneration = true;
                        return robustFetch(`${AI_API_BASE}/gen-enterprise-non-mpls`, {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
                        }, 3, 1000);
                    })
                    .then(function (r) {
                        if (!r.ok) {
                            const statusText = r.status === 500 ? 'Server error' : r.status === 404 ? 'Endpoint not found' : `HTTP ${r.status}`;
                            throw new Error(`Backend request failed: ${statusText}`);
                        }
                        return r.json();
                    })
                    .then(function (res) {
                        if (!res || res.success !== true || !res.config) {
                            throw new Error((res && res.error) || 'Configuration generation failed');
                        }

                        updateProgressPercent(70);
                        addProgressLog('success', 'Configuration generated successfully');
                        addProgressLog('info', `Config size: ${res.config.length} characters`);

                        updateProgressStep('Validating generated configuration...');
                        updateProgressPercent(75);
                        addProgressLog('info', 'Running RouterOS syntax validation');
                        showAIStatus(' Validating generated configuration...', 'info');

                        // Stage 3: Validate the generated config
                        return robustFetch(`${AI_API_BASE}/validate-config`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ config: res.config, type: 'enterprise-non-mpls' })
                        }, 3, 1000).then(function (validationRes) {
                            if (!validationRes.ok) {
                                console.warn('[VALIDATION] Validation request failed, continuing without validation');
                                return { validation: { issues: [] } }; // Return empty validation on error
                            }
                            return validationRes.json();
                        }).then(function (validation) {
                            updateProgressPercent(90);
                            if (validation && validation.validation && validation.validation.issues && validation.validation.issues.length > 0) {
                                addProgressLog('warning', `Validation completed with ${validation.validation.issues.length} warnings`);
                                validation.validation.issues.forEach(issue => {
                                    addProgressLog('warning', issue);
                                });
                                showAIStatus(' Configuration generated with warnings. Check output for details.', 'warning');
                            } else {
                                addProgressLog('success', 'Validation passed - no issues found');
                                showAIStatus(' Configuration generated successfully with full validation!', 'success');
                            }

                            updateProgressStep('Finalizing and displaying configuration...');
                            updateProgressPercent(95);
                            addProgressLog('info', 'Rendering configuration output');

                            window.enterpriseConfigOriginal = res.config;
                            window.enterprisePasswordsVisible = false;
                            displayEnterpriseConfig(false);

                            // Auto-save completed config
                            saveCompletedConfig({
                                config_type: 'enterprise',
                                device_name: customerCode || device,
                                device_type: device,
                                customer_code: customerCode,
                                loopback_ip: loopback,
                                routeros_version: version,
                                config_content: res.config,
                                site_name: '',
                                router_id: loopback,
                                lan_bridge_ip: '',
                                ospf_area: '',
                                bgp_peers: [],
                                uplinks: []
                            });

                            // Track activity for live feed
                            // Clear ongoing activity and save to history
                            clearOngoingActivity('enterprise-non-mpls');

                            const historyEntry = {
                                type: 'enterprise-non-mpls',
                                device: device,
                                siteName: customerCode || 'Enterprise Config',
                                routeros: version,
                                success: true
                            };

                            saveConfigToHistory(historyEntry);
                            console.log('[ENTERPRISE] Config saved to history:', historyEntry);

                            // Update dashboard immediately
                            updateDashboardMetrics();
                            updateRecentActivity();

                            // Complete progress tracker
                            updateProgressPercent(100);
                            addProgressLog('success', 'Configuration generation completed successfully!');
                            completeProgressTracker(true);
                        });
                    })
                    .catch(function (err) {
                        console.error('[ENTERPRISE] Generation error:', err);
                        clearOngoingActivity('enterprise-non-mpls');
                        const errorMsg = err.message || String(err);
                        addProgressLog('error', 'Generation failed: ' + errorMsg);
                        completeProgressTracker(false);

                        // More accurate error messages
                        if (errorMsg.includes('Failed to fetch') || errorMsg.includes('NetworkError') || errorMsg.includes('timeout')) {
                            showAIStatus(' Network error: Unable to reach backend server. Please check your connection and ensure the service is running.', 'error');
                        } else if (errorMsg.includes('HTTP 500')) {
                            showAIStatus(' Server error: Backend encountered an internal error. Please check server logs.', 'error');
                        } else if (errorMsg.includes('HTTP 404')) {
                            showAIStatus(' Endpoint not found: The requested API endpoint does not exist.', 'error');
                        } else {
                            showAIStatus(' Error: ' + errorMsg, 'error');
                        }
                    })
                    .finally(function () {
                        if (btn) {
                            btn.disabled = false;
                            btn.textContent = ' Generate Enterprise Configuration';
                        }
                    });
            } catch (e) {
                console.error(e);
                alert('Unexpected error while generating config.');
            }
        }

        // === Non-MPLS AI helpers ===
        function entAutofillFromExport() {
            const raw = (document.getElementById('ent_exportInput') || {}).value || '';
            if (!raw.trim()) { alert('Paste a RouterOS export first.'); return; }
            const btn = document.getElementById('entAutofillBtn'); if (btn) { btn.disabled = true; btn.textContent = 'Autofilling...'; }
            robustFetch(`${AI_API_BASE}/autofill-from-export`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ config: raw })
            }, 2, 1000).then(r => {
                if (!r.ok) throw new Error(`Request failed: HTTP ${r.status}`);
                return r.json();
            }).then(res => {
                if (!res.success) throw new Error(res.error || 'Autofill failed');
                // Map suggestions into fields if present
                if (res.device) { const map = { 'CCR2004': 'ccr2004', 'CCR2216': 'ccr2216', 'RB5009': 'rb5009', 'CCR1036': 'ccr1036', 'CCR2116': 'ccr2116', 'CCR1072': 'ccr1072' }; const devSel = document.getElementById('ent_routerboard_device'); if (devSel && map[res.device]) devSel.value = map[res.device]; }
                if (res.loopback_ip) { const f = document.getElementById('ent_loopbackIP'); if (f) f.value = res.loopback_ip.replace('/32', '/32'); }
                if (res.public_cidr) { const f = document.getElementById('ent_publicIP'); if (f) f.value = res.public_cidr; }
                if (res.uplink_cidr) { const f = document.querySelector('.ent_uplinkIP'); if (f) f.value = res.uplink_cidr; }
                if (res.identity) { const f = document.getElementById('ent_deviceName'); if (f) f.value = res.identity; }
                handleEntDeviceChange(); updatePublicPoolFromPublicIp(); updatePrivatePoolFromPrivateIp(); updateGatewayFromUplink();
            }).catch(e => { alert('Autofill failed: ' + e.message); }).finally(() => { if (btn) { btn.disabled = false; btn.textContent = ' Autofill from Export'; } });
        }

        function entAISuggest() {
            const btn = document.getElementById('entSuggestBtn'); if (btn) { btn.disabled = true; btn.textContent = 'Suggesting...'; }
            const payload = {
                device: (document.getElementById('ent_routerboard_device') || {}).value,
                target_version: (document.getElementById('ent_routeros_version') || {}).value,
                loopback_ip: (document.getElementById('ent_loopbackIP') || {}).value,
                public_cidr: (document.getElementById('ent_publicIP') || {}).value,
                bh_cidr: (document.querySelector('.ent_uplinkIP') || {}).value
            };
            robustFetch(`${AI_API_BASE}/suggest-config`, {
                method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload)
            }, 2, 1000).then(r => {
                if (!r.ok) throw new Error(`Request failed: HTTP ${r.status}`);
                return r.json();
            }).then(res => {
                if (!res.success) throw new Error(res.error || 'Suggest failed');
                // Apply non-destructive suggestions
                if (res.public_port) { const s = document.getElementById('ent_publicInterface'); if (s) s.value = res.public_port; }
                if (res.nat_port) { const s = document.getElementById('ent_natInterface'); if (s) s.value = res.nat_port; }
                if (res.uplink_interface) { const s = document.getElementById('ent_backhaulInterface'); if (s) s.value = res.uplink_interface; }
                if (res.public_pool) { const f = document.getElementById('ent_publicPool'); if (f) f.value = res.public_pool; }
                if (res.gateway) { const f = document.getElementById('ent_gateway'); if (f) f.value = res.gateway; }
            }).catch(e => { alert('Suggest failed: ' + e.message); }).finally(() => { if (btn) { btn.disabled = false; btn.textContent = ' AI Suggest'; } });
        }

        function entValidateDryRun() {
            const btn = document.getElementById('entValidateBtn'); if (btn) { btn.disabled = true; btn.textContent = 'Validating...'; }
            const config = (window.enterpriseConfigOriginal || document.getElementById('enterpriseOutput')?.textContent || '').trim();
            if (!config) { alert('Generate config first.'); if (btn) { btn.disabled = false; btn.textContent = ' Validate / Dryrun'; } return; }
            robustFetch(`${AI_API_BASE}/validate-config`, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ config }) }, 2, 1000)
                .then(r => {
                    if (!r.ok) throw new Error(`Request failed: HTTP ${r.status}`);
                    return r.json();
                }).then(res => {
                    const rep = document.getElementById('entValidateReport'); if (!rep) return;
                    if (!res.success) { rep.textContent = 'Validation failed: ' + (res.error || 'Unknown'); return; }
                    const issues = res.issues || []; const errors = issues.filter(i => i.severity === 'error'); const warnings = issues.filter(i => i.severity === 'warning');
                    rep.textContent = `Validation: ${errors.length} errors, ${warnings.length} warnings` + (issues.length ? '\n- ' + issues.map(i => `[${i.severity}] ${i.message}`).join('\n- ') : '\n(no issues)');
                }).catch(e => { alert('Validate failed: ' + e.message); }).finally(() => { if (btn) { btn.disabled = false; btn.textContent = ' Validate / Dryrun'; } });
        }

        function maskPasswords(config) {
            // Replace all password values with asterisks
            return config.replace(/password=[^\s]+/g, 'password=**********');
        }

        function displayEnterpriseConfig(showPasswords) {
            const config = window.enterpriseConfigOriginal || '';
            const displayConfig = showPasswords ? config : maskPasswords(config);
            document.getElementById('enterpriseOutput').textContent = displayConfig;

            // Update button text
            const btn = document.getElementById('toggleEntPasswordBtn');
            if (btn) {
                btn.textContent = showPasswords ? ' Hide Passwords' : ' Show Passwords';
                btn.style.background = showPasswords ? '#dc3545' : '#FF9800';
            }
        }

        function toggleEnterprisePasswords() {
            if (!window.enterpriseConfigOriginal) {
                alert('Please generate a configuration first!');
                return;
            }
            window.enterprisePasswordsVisible = !window.enterprisePasswordsVisible;
            displayEnterpriseConfig(window.enterprisePasswordsVisible);
        }

        function copyEnterpriseConfig() {
            // Always copy the REAL config with passwords
            const config = window.enterpriseConfigOriginal || document.getElementById('enterpriseOutput').textContent;
            if (!config) { alert('No configuration to copy!'); return; }
            navigator.clipboard.writeText(config).then(() => alert(' Configuration copied to clipboard (with real passwords)!')).catch(err => alert('Failed to copy: ' + err));
        }
        function downloadEnterpriseConfig() {
            // Always download the REAL config with passwords
            const config = window.enterpriseConfigOriginal || document.getElementById('enterpriseOutput').textContent;
            if (!config) { alert('No configuration to download!'); return; }
            const deviceName = document.getElementById('ent_deviceName').value || 'enterprise-config';
            const date = new Date().toISOString().split('T')[0];
            const filename = `${date}_${deviceName}.rsc`;
            const blob = new Blob([config], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function clearEnterpriseOutput() {
            document.getElementById('enterpriseOutput').textContent = '';
            window.enterpriseConfigOriginal = '';
            window.enterprisePasswordsVisible = false;
            const btn = document.getElementById('toggleEntPasswordBtn');
            if (btn) {
                btn.textContent = ' Show Passwords';
                btn.style.background = '#FF9800';
            }
        }
        // ===== MPLS ENTERPRISE CONFIG FUNCTIONS =====

        window.generateMPLSEnterpriseConfig = function () {
            // Show MUSHU-style live progress tracker
            showProgressTracker('MPLS Enterprise Configuration');
            updateProgressStep('Validating input parameters...');
            updateProgressPercent(5);
            addProgressLog('info', 'Starting MPLS Enterprise config generation');

            const routerboardDevice = document.getElementById('ent_mpls_routerboard_device')?.value || '';
            const routerosVersion = document.getElementById('ent_mpls_routeros_version')?.value || '';
            const customerCode = document.getElementById('ent_mpls_customerCode')?.value.trim() || '';
            const deviceName = document.getElementById('ent_mpls_deviceName')?.value.trim() || customerCode;
            const loopbackIPRaw = document.getElementById('ent_mpls_loopbackIP')?.value.trim() || '';
            const latitude = document.getElementById('ent_mpls_latitude')?.value.trim() || '';
            const longitude = document.getElementById('ent_mpls_longitude')?.value.trim() || '';
            const customerHandoff = document.getElementById('ent_mpls_customerHandoff')?.value || '';

            addProgressLog('info', `Customer: ${customerCode}, Device: ${routerboardDevice}`);

            // Validate required fields
            if (!routerboardDevice || !customerCode || !loopbackIPRaw) {
                addProgressLog('error', 'Validation failed: Missing required fields');
                completeProgressTracker(false);
                document.getElementById('mplsEnterprise_warn').innerHTML = '<div style="background: #f44336; color: white; padding: 10px; border-radius: 5px;"> Please fill in RouterBoard Device, Customer Code, and Loopback IP.</div>';
                return;
            }

            addProgressLog('success', 'Input validation passed');
            updateProgressPercent(15);

            // Get button and show AI status
            const btn = document.getElementById('generateMPLSEnterpriseBtn');
            if (btn) {
                btn.disabled = true;
                btn.textContent = ' Processing with AI...';
            }

            // Show AI status
            const warnDiv = document.getElementById('mplsEnterprise_warn');
            function showAIStatus(message, type) {
                if (warnDiv) {
                    const bg = type === 'success' ? '#4CAF50' : type === 'error' ? '#f44336' : '#FF9800';
                    warnDiv.innerHTML = `<div style="background: ${bg}; color: white; padding: 10px; border-radius: 5px;">${message}</div>`;
                }
            }

            showAIStatus(' Getting AI suggestions for optimal MPLS Enterprise configuration...', 'info');

            // Stage 1: Get AI suggestions (similar to Non-MPLS enterprise)
            const suggestPayload = {
                device: routerboardDevice,
                target_version: routerosVersion,
                loopback_ip: loopbackIPRaw,
                config_type: 'mpls-enterprise'
            };

            robustFetch(`${AI_API_BASE}/suggest-config`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(suggestPayload)
            }, 3, 1000)
                .then(function (r) {
                    if (!r.ok) {
                        const statusText = r.status === 500 ? 'Server error' : r.status === 404 ? 'Endpoint not found' : `HTTP ${r.status}`;
                        throw new Error(`Backend request failed: ${statusText}`);
                    }
                    return r.json();
                })
                .then(function (sres) {
                    if (sres && sres.success) {
                        updateProgressPercent(30);
                        updateProgressStep('AI suggestions received, building configuration...');
                        addProgressLog('success', 'AI suggestions received');
                        showAIStatus(' AI suggestions received, generating MPLS Enterprise configuration...', 'success');
                    }

                    // Continue with generation
                    generateMPLSEnterpriseConfigInternal(routerboardDevice, routerosVersion, customerCode, deviceName, loopbackIPRaw, latitude, longitude, customerHandoff, btn, showAIStatus);
                })
                .catch(function (error) {
                    console.error('[MPLS Enterprise] AI suggestion error:', error);
                    showAIStatus(' AI suggestions unavailable, generating configuration directly...', 'info');
                    // Continue with generation even if AI fails
                    generateMPLSEnterpriseConfigInternal(routerboardDevice, routerosVersion, customerCode, deviceName, loopbackIPRaw, latitude, longitude, customerHandoff, btn, showAIStatus);
                });
        }

        function generateMPLSEnterpriseConfigInternal(routerboardDevice, routerosVersion, customerCode, deviceName, loopbackIPRaw, latitude, longitude, customerHandoff, btn, showAIStatus) {
            updateProgressPercent(40);
            updateProgressStep('Initializing MPLS configuration parameters...');
            addProgressLog('info', `Device: ${routerboardDevice}, RouterOS: ${routerosVersion}`);

            let config = '';
            const snmpCommunity = 'CHANGE_ME'; // SNMP community (user should change this)

            // Get device config
            const deviceKey = routerboardDevice.toLowerCase();
            const deviceConfig = (typeof DEVICE_CONFIGS !== 'undefined' && DEVICE_CONFIGS[deviceKey])
                ? DEVICE_CONFIGS[deviceKey]
                : { name: routerboardDevice.toUpperCase(), ports: [], sfpPorts: [] };

            // Extract loopback IP without /32
            const loopbackIP = loopbackIPRaw.replace('/32', '').trim();

            addProgressLog('info', `Loopback: ${loopbackIP}`);

            // Collect all uplink data for MPLS (moved here to be accessible later)
            const uplinks = document.querySelectorAll('#ent_mpls_uplinksContainer .interface-item');
            const uplinkData = [];
            uplinks.forEach((uplink, index) => {
                const uplinkInterface = uplink.querySelector('.ent_mpls_uplinkInterface').value;
                const uplinkIP = uplink.querySelector('.ent_mpls_uplinkIP').value;
                const uplinkComment = uplink.querySelector('.ent_mpls_uplinkComment').value;
                if (uplinkInterface && uplinkIP) {
                    uplinkData.push({
                        interface: uplinkInterface,
                        ip: uplinkIP,
                        comment: uplinkComment || `Uplink-${index + 1}`
                    });
                }
            });

            // Parse BGP ASN and peers only if BGP is explicitly enabled
            const enableBGP = (document.getElementById('ent_mpls_enableBGP') && document.getElementById('ent_mpls_enableBGP').checked);
            const bgpAsRaw = enableBGP && document.getElementById('ent_mpls_bgpAs') ? document.getElementById('ent_mpls_bgpAs').value.trim() : '';
            const bgpPeersRaw = enableBGP && document.getElementById('ent_mpls_bgpPeers') ? document.getElementById('ent_mpls_bgpPeers').value.trim() : '';
            const bgpAs = bgpAsRaw ? parseInt(bgpAsRaw, 10) : null;
            const bgpPeers = [];
            if (bgpPeersRaw) {
                bgpPeersRaw.split(',').forEach(p => {
                    const parts = p.trim().split(':');
                    if (parts[0]) {
                        bgpPeers.push({ ip: parts[0].trim(), as: parts[1] ? parseInt(parts[1].trim(), 10) : null });
                    }
                });
            }
            // Get DNS and syslog from NextLink infrastructure configuration (no fallbacks)
            const dnsList = getDNSList();
            if (!dnsList) {
                alert('DNS servers must be configured in nextlink_constants.js. Please configure dnsServers.primary and dnsServers.secondary.');
                return;
            }
            const dnsServers = dnsList.split(',').map(s => s.trim());
            const dns1 = dnsServers[0];
            const dns2 = dnsServers[1];
            if (!dns1 || !dns2) {
                alert('Both DNS servers must be configured in nextlink_constants.js.');
                return;
            }
            const syslogServer = getSyslogServer();  // Must be configured in nextlink_constants.js

            // Auto-select customer handoff interface if not specified
            let effectiveHandoff = customerHandoff;
            if (!effectiveHandoff && deviceConfig) {
                if (deviceConfig.sfpPorts && deviceConfig.sfpPorts.length > 0) {
                    // Prefer sfp-sfpplus1 for customer handoff (typical policy)
                    effectiveHandoff = deviceConfig.sfpPorts.find(p => p.includes('sfp-sfpplus1')) || deviceConfig.sfpPorts[0];
                } else if (deviceConfig.ports && deviceConfig.ports.length > 0) {
                    effectiveHandoff = deviceConfig.ports[0];
                } else {
                    effectiveHandoff = 'sfp-sfpplus1'; // Default fallback
                }
            }

            // Determine VPLS cisco-static-id (2245 per example, but can be dynamic)
            const vplsStaticId = getInfrastructureValue('mpls.vplsStaticId', '2245');
            const vplsPeer = getInfrastructureValue('mpls.vplsPeer', ''); // BNG1 peer - must be configured

            // ========================================
            // BASE CONFIG SECTION
            // ========================================
            config += `################################\n`;
            config += `###       BASE CONFIG        ###\n`;
            config += `################################\n\n`;

            // IP SERVICES (individual set commands - matches example format)
            config += `# IP SERVICES\n`;
            config += `/ip service set telnet disabled=yes port=5023\n`;
            config += `/ip service set ftp disabled=yes port=5021\n`;
            config += `/ip service set www disabled=yes port=1234\n`;
            config += `/ip service set ssh port=5022 address=""\n`;
            config += `/ip service set api disabled=yes\n`;
            config += `/ip service set api-ssl disabled=yes\n`;
            config += `/ip service set www-ssl disabled=no port=443\n`;
            config += `/ip service set winbox address=""\n\n`;

            // BRIDGES (from reference - matches example format)
            config += `# BRIDGES\n`;
            config += `/interface bridge\n`;
            config += `add comment=DYNAMIC name=bridge1000 protocol-mode=none\n`;
            config += `add comment=STATIC name=bridge2000 protocol-mode=none\n`;
            config += `add comment=INFRA name=bridge3000 protocol-mode=none\n`;
            config += `add comment=CPE name=bridge4000 protocol-mode=none\n`;
            config += `add comment=LOOPBACK name=loop0\n\n`;

            // DNS
            config += `# DNS\n`;
            config += `/ip dns\n`;
            config += `set servers=${dns1},${dns2}\n\n`;

            // NOTE: Firewall rules, address-lists, and user groups are handled by RFC-09-10-25 compliance section
            // This prevents duplicates - the compliance section uses 'rem' commands to ensure clean application

            // ========================================
            // SYSTEM SPECIFIC SECTION
            // ========================================
            config += `################################\n`;
            config += `###       SYSTEM SPECIFIC    ###\n`;
            config += `################################\n\n`;

            // System Identity
            config += `/system identity\n`;
            config += `set name=${deviceName}\n\n`;

            // MPLS Interface
            config += `/mpls interface\n`;
            config += `add disabled=no interface=all mpls-mtu=9000\n\n`;

            // Interface VPLS (only if VPLS peer configured)
            if (vplsPeer) {
                config += `/interface vpls\n`;
                config += `add arp=enabled bridge=bridge2000 bridge-horizon=1 cisco-static-id=${vplsStaticId} disabled=no mtu=1500 name=vpls2000-bng1 peer=${vplsPeer} pw-control-word=disabled pw-l2mtu=1500 pw-type=raw-ethernet\n\n`;
            }

            // Interface Ethernet (for customer handoff - use "Customer Uplink #1" as per example)
            if (effectiveHandoff) {
                config += `/interface ethernet\n`;
                config += `set [ find default-name=${effectiveHandoff} ] comment="Customer Uplink #1"\n\n`;
            }

            // Interface Bridge Port
            config += `/interface bridge port\n`;
            if (effectiveHandoff) {
                config += `add bridge=bridge2000 interface=${effectiveHandoff}\n\n`;
            }

            // Interface Ethernet Configuration for uplinks
            if (uplinkData.length > 0) {
                uplinkData.forEach(u => {
                    const commentSafe = u.comment && String(u.comment).trim() ? String(u.comment).replace(/"/g, '') : deviceName;
                    config += `/interface ethernet\n`;
                    config += `set [ find default-name=${u.interface} ] comment="${commentSafe}" l2mtu=9212 mtu=9198\n`;

                    // IP Address for uplink
                    if (u.ip) {
                        let network = u.ip;
                        if (u.ip.includes('/')) {
                            const cidr = u.ip.split('/')[1];
                            const networkAddr = calculateNetwork(u.ip);
                            network = networkAddr + '/' + cidr;
                        }
                        config += `/ip address\n`;
                        config += `add address=${u.ip} interface=${u.interface} comment="${commentSafe}" network=${network}\n\n`;
                    }

                    updateProgressPercent(55);
                    updateProgressStep('Configuring MPLS LDP and OSPF for uplinks...');
                    addProgressLog('info', `Processing ${uplinkData.length} uplinks`);

                    // MPLS LDP Interface
                    config += `/mpls ldp interface\n`;
                    config += `add interface=${u.interface} comment="${commentSafe}"\n\n`;

                    // OSPF Interface Template for uplink
                    if (u.ip && u.ip.includes('/')) {
                        const cidr = u.ip.split('/')[1];
                        const networkAddr = calculateNetwork(u.ip);
                        const networkStr = networkAddr + '/' + cidr;
                        config += `/routing ospf interface-template\n`;
                        // Get OSPF/BGP shared key from infrastructure
                        const mplsSharedKey = getInfrastructureValue('sharedKeys.ospfBgpMd5', 'CHANGE_ME');
                        config += `add area=area0 auth=md5 auth-id=1 auth-key=${mplsSharedKey} comment="${commentSafe}" cost=10 disabled=no interfaces=${u.interface} networks=${networkStr} priority=1 type=ptp\n\n`;
                    }
                });
            }

            // OSPF Instance and Area
            config += `/routing ospf instance\n`;
            config += `add disabled=no name=default-v2 router-id=${loopbackIP}\n\n`;
            config += `/routing ospf area\n`;
            config += `add disabled=no instance=default-v2 name=area0 area-id=0.0.0.0\n\n`;

            // System Logging Action (only if syslog server configured)
            config += `/system logging action\n`;
            config += `set 0 memory-lines=100\n`;
            config += `set 1 disk-lines-per-file=10000\n`;
            if (syslogServer) {
                config += `add name=syslog remote=${syslogServer} src-address=${loopbackIP} target=remote\n`;
            }
            config += `\n`;

            // System Logging
            config += `/system logging\n`;
            config += `add action=syslog topics=critical\n`;
            config += `add action=syslog topics=error\n`;
            config += `add action=syslog topics=info\n`;
            config += `add action=syslog topics=warning\n`;
            config += `add disabled=yes topics=debug\n`;
            config += `add action=disk topics=critical\n`;
            config += `add action=disk topics=error\n`;
            config += `add action=disk topics=info\n`;
            config += `add topics=warning\n\n`;

            // IP Address - Loopback
            config += `/ip address\n`;
            const loopbackWithMask = loopbackIPRaw.includes('/') ? loopbackIPRaw : (loopbackIP + '/32');
            config += `add address=${loopbackWithMask} interface=loop0\n\n`;

            // MPLS LDP
            config += `/mpls ldp\n`;
            config += `add afi=ip disabled=no distribute-for-default=no hop-limit=255 loop-detect=no lsr-id=${loopbackIP} path-vector-limit=255 transport-addresses=${loopbackIP} use-explicit-null=no vrf=main\n\n`;

            // OSPF Interface Template for loopback
            config += `/routing ospf interface-template\n`;
            config += `add area=area0 cost=10 disabled=no interfaces=loop0 networks=${loopbackIP}/32 passive priority=1\n\n`;

            updateProgressPercent(70);
            updateProgressStep('Configuring system services (NTP, SNMP, logging)...');
            addProgressLog('info', 'Adding system hardening and monitoring');

            // CLOCK
            config += `# CLOCK\n`;
            config += `/system clock\n`;
            config += `set time-zone-name=America/Chicago\n\n`;
            config += `/system ntp client\n`;
            config += `set enabled=yes\n\n`;
            config += `/system ntp client servers\n`;
            const ntpServers2 = getNTPServer();
            // Always add default NTP servers
            ntpServers2.defaults.forEach(server => {
                config += `add address=${server}\n`;
            });
            // Add custom NTP server if configured
            if (ntpServers2.custom) {
                config += `add address=${ntpServers2.custom}\n`;
            }
            config += `\n`;

            // SNMP
            config += `# SNMP\n`;
            config += `/snmp community\n`;
            config += `set [ find default=yes ] read-access=no\n\n`;
            config += `/snmp community\n`;
            config += `add name=${snmpCommunity} addresses=::/0\n\n`;

            const locationStr = (latitude && longitude) ? `"${latitude}, ${longitude}"` : '';
            config += `/snmp\n`;
            if (locationStr) {
                const snmpContact = getInfrastructureValue('snmp.contact', 'noc@configmaker.local');
                config += `set contact=${snmpContact} enabled=yes location=${locationStr} src-address=${loopbackIP} trap-community=${snmpCommunity}\n\n`;
            } else {
                const snmpContact = getInfrastructureValue('snmp.contact', 'noc@configmaker.local');
                config += `set contact=${snmpContact} enabled=yes src-address=${loopbackIP} trap-community=${snmpCommunity}\n\n`;
            }

            // WATCHDOG TIMER
            config += `# WATCHDOG TIMER\n`;
            config += `/system watchdog\n`;
            config += `set watchdog-timer=yes\n\n`;

            // AUTO UPGRADE
            config += `# AUTO UPGRADE\n`;
            config += `/system routerboard settings\n`;
            config += `set auto-upgrade=yes\n\n`;

            // RADIUS LOGIN SERVERS
            config += `# RADIUS LOGIN SERVERS\n`;
            config += `/radius\n`;
            const radiusLoginServers = getRADIUSLoginServers();
            if (radiusLoginServers.length > 0) {
                radiusLoginServers.forEach(server => {
                    if (server.address && server.secret) {
                        const comment = server.comment || 'RADIUS Login';
                        config += `add address=${server.address} comment="${comment}" secret=${server.secret} service=login src-address=${loopbackIP}\n`;
                    }
                });
                config += `\n`;
            }

            // ========================================
            // BNG CONFIGS SECTION
            // ========================================
            config += `################################\n`;
            config += `###       BNG CONFIGS        ###\n`;
            config += `################################\n`;
            config += `# Copy and Paste these lines into the BNGs removing the leading # sign\n\n`;
            config += `# MT BNG\n`;
            config += `#/interface vpls add name=vpls2000-${deviceName} disabled=no advertised-l2mtu=1580 cisco-style=yes cisco-style-id=${vplsStaticId} comment="VPLS2000-${deviceName}"  remote-peer=${loopbackIP}\n`;
            config += `#/interface bridge port add bridge=bridge2000 interface=vpls2000-${deviceName} horizon=1\n\n`;
            config += `# Nokia BNG\n`;
            config += `#show service sdp     ###Shows used SDP IDs###\n`;
            config += `#/configure service sdp <Next available SdpId> mpls create\n`;
            config += `#/configure service sdp <Next available SdpId> mpls description ${deviceName}     ###Adds tower description###\n`;
            config += `#/configure service sdp <Next available SdpId> mpls far-end ${loopbackIP}           ###Tower Loop###\n`;
            config += `#/configure service sdp <Next available SdpId> mpls ldp                          ###ldp for OMAHA, bgp-tunnel for CHICAGO\n`;
            config += `#/configure service sdp <Next available SdpId> mpls keep-alive shutdown\n`;
            config += `#/configure service sdp <Next available SdpId> mpls no shutdown\n`;
            config += `#/configure service vpls ${vplsStaticId} mesh-sdp <next available>:${vplsStaticId} create restrict-protected-src discard-frame\n`;
            config += `#/configure service vpls ${vplsStaticId} mesh-sdp <next available>:${vplsStaticId} no shutdown\n\n`;

            // Store original config globally for password toggling
            window.mplsEnterpriseConfigOriginal = config;
            window.mplsEnterprisePasswordsVisible = false;

            // Stage 2: Apply RFC-09-10-25 Compliance Standards
            showAIStatus(' Applying RFC-09-10-25 compliance standards...', 'info');

            fetch(`${AI_API_BASE}/apply-compliance`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    config: config,
                    loopback_ip: loopbackIPRaw
                })
            })
                .then(function (r) {
                    if (!r.ok) throw new Error('Compliance application failed');
                    return r.json();
                })
                .then(function (complianceRes) {
                    if (complianceRes && complianceRes.success) {
                        // Update config with compliant version
                        config = complianceRes.config;
                        window.mplsEnterpriseConfigOriginal = config;

                        // Check compliance status
                        const compliance = complianceRes.compliance || {};
                        if (compliance.compliant) {
                            showAIStatus(' RFC-09-10-25 compliance applied successfully!', 'success');
                        } else {
                            const missingCount = (compliance.missing_items || []).length;
                            if (missingCount > 0) {
                                showAIStatus(` Compliance applied but ${missingCount} item(s) may need review.`, 'error');
                            } else {
                                showAIStatus(' Compliance applied successfully!', 'success');
                            }
                        }
                    } else {
                        console.warn('[MPLS Enterprise] Compliance application failed, using original config');
                    }
                })
                .catch(function (error) {
                    console.error('[MPLS Enterprise] Compliance application error:', error);
                    // Continue with original config if compliance fails
                })
                .then(function () {
                    updateProgressPercent(85);
                    updateProgressStep('Validating configuration with AI...');
                    addProgressLog('info', 'Running comprehensive AI validation');

                    // Stage 3: Validate generated config with AI (with timeout and retries)
                    showAIStatus(' Validating generated MPLS Enterprise configuration with AI...', 'info');

                    // Add timeout to validation
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                    return fetch(`${AI_API_BASE}/validate-config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ config: config, type: 'mpls-enterprise' }),
                        signal: controller.signal
                    }).then(function (r) {
                        clearTimeout(timeoutId);
                        if (!r.ok) {
                            addProgressLog('warning', `Validation endpoint returned ${r.status}`);
                            throw new Error(`Validation failed with status ${r.status}`);
                        }
                        return r.json();
                    }).catch(function (err) {
                        clearTimeout(timeoutId);
                        if (err.name === 'AbortError') {
                            addProgressLog('warning', 'Validation timed out after 30s');
                            throw new Error('Validation timed out');
                        }
                        throw err;
                    });
                })
                .then(function (validationRes) {
                    if (validationRes && validationRes.success) {
                        const validation = validationRes.validation || {};
                        const issues = validation.issues || [];
                        const errors = issues.filter(i => i.severity === 'error');
                        const warnings = issues.filter(i => i.severity === 'warning');

                        if (errors.length > 0) {
                            addProgressLog('error', `Validation found ${errors.length} error(s)`);
                            errors.slice(0, 3).forEach(err => addProgressLog('error', err.message || err));
                            showAIStatus(` AI validation found ${errors.length} error(s). Please review the configuration.`, 'error');
                        } else if (warnings.length > 0) {
                            addProgressLog('warning', `Validation found ${warnings.length} warning(s)`);
                            warnings.slice(0, 3).forEach(warn => addProgressLog('warning', warn.message || warn));
                            showAIStatus(` AI validation complete with ${warnings.length} warning(s).`, 'success');
                        } else {
                            addProgressLog('success', 'AI validation passed - no issues found');
                            showAIStatus(' AI validation complete. Configuration generated successfully!', 'success');
                        }
                    } else {
                        addProgressLog('warning', 'Validation response incomplete');
                    }

                    // Display with passwords hidden by default
                    displayMPLSEnterpriseConfig(false);

                    // Re-enable button
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = ' Generate MPLS Enterprise Configuration';
                    }

                    // Auto-save completed config (use current config which includes compliance)
                    saveCompletedConfig({
                        config_type: 'mpls-enterprise',
                        device_name: deviceName,
                        device_type: routerboardDevice,
                        customer_code: customerCode,
                        loopback_ip: loopbackIP,
                        routeros_version: routerosVersion,
                        config_content: config,  // This now includes compliance blocks
                        site_name: '',
                        router_id: loopbackIP,
                        lan_bridge_ip: '',
                        ospf_area: 'area0',
                        bgp_peers: [],
                        uplinks: uplinkData
                    });

                    updateProgressPercent(100);
                    addProgressLog('success', 'MPLS Enterprise configuration completed!');
                    addProgressLog('info', `Config size: ${config.length} characters`);

                    // Track activity for live feed (BEFORE completing tracker)
                    console.log('[MPLS ENTERPRISE] Saving to history:', {
                        type: 'new-config',
                        device: routerboardDevice,
                        siteName: deviceName || customerCode || 'MPLS Enterprise',
                        routeros: routerosVersion,
                        success: true
                    });

                    saveConfigToHistory({
                        type: 'new-config',
                        device: routerboardDevice,
                        siteName: deviceName || customerCode || 'MPLS Enterprise',
                        routeros: routerosVersion,
                        success: true
                    });

                    // Additional update after a delay to ensure backend processed
                    setTimeout(() => {
                        updateDashboardMetrics();
                        updateRecentActivity();
                    }, 1000);

                    completeProgressTracker(true);
                })
                .catch(function (error) {
                    console.error('[MPLS Enterprise] Validation error:', error);
                    addProgressLog('error', 'AI validation failed: ' + (error.message || 'Unknown error'));
                    addProgressLog('warning', 'Configuration generated but not validated - manual review required');

                    // Still track as success (config was generated, just validation failed)
                    console.log('[MPLS ENTERPRISE] Saving to history (validation failed but config generated):', {
                        type: 'new-config',
                        device: routerboardDevice,
                        siteName: deviceName || customerCode || 'MPLS Enterprise',
                        routeros: routerosVersion,
                        success: true
                    });

                    saveConfigToHistory({
                        type: 'new-config',
                        device: routerboardDevice,
                        siteName: deviceName || customerCode || 'MPLS Enterprise',
                        routeros: routerosVersion,
                        success: true  // Config was generated successfully
                    });

                    // Additional update after a delay to ensure backend processed
                    setTimeout(() => {
                        updateDashboardMetrics();
                        updateRecentActivity();
                    }, 1000);

                    completeProgressTracker(true);  // Still success, just no validation

                    // Show more specific error
                    if (error.message && error.message.includes('timed out')) {
                        showAIStatus(' AI validation timed out. Configuration generated but needs manual review.', 'warning');
                    } else if (error.message && (error.message.includes('Failed to fetch') || error.message.includes('NetworkError') || error.message.includes('timeout'))) {
                        showAIStatus(' Network error: Unable to reach backend for validation. Configuration generated but not validated.', 'warning');
                    } else {
                        showAIStatus(' AI validation error: ' + error.message + '. Configuration generated but needs review.', 'warning');
                    }

                    // Display with passwords hidden by default
                    displayMPLSEnterpriseConfig(false);

                    // Re-enable button
                    if (btn) {
                        btn.disabled = false;
                        btn.textContent = ' Generate MPLS Enterprise Configuration';
                    }

                    // Auto-save completed config (config already includes compliance from earlier step)
                    saveCompletedConfig({
                        config_type: 'mpls-enterprise',
                        device_name: deviceName,
                        device_type: routerboardDevice,
                        customer_code: customerCode,
                        loopback_ip: loopbackIPRaw.replace('/32', '').trim(),
                        routeros_version: routerosVersion,
                        config_content: config,  // This includes compliance blocks
                        site_name: '',
                        router_id: loopbackIPRaw.replace('/32', '').trim(),
                        lan_bridge_ip: '',
                        ospf_area: 'area0',
                        bgp_peers: [],
                        uplinks: []
                    });
                });
        }

        function displayMPLSEnterpriseConfig(showPasswords) {
            const config = window.mplsEnterpriseConfigOriginal || '';
            const displayConfig = showPasswords ? config : maskPasswords(config);
            document.getElementById('mplsEnterpriseOutput').textContent = displayConfig;
        }

        function toggleMPLSEnterprisePasswords() {
            if (!window.mplsEnterpriseConfigOriginal) {
                alert('Please generate a configuration first!');
                return;
            }
            window.mplsEnterprisePasswordsVisible = !window.mplsEnterprisePasswordsVisible;
            displayMPLSEnterpriseConfig(window.mplsEnterprisePasswordsVisible);
        }

        function copyMPLSEnterpriseConfig() {
            const config = window.mplsEnterpriseConfigOriginal || document.getElementById('mplsEnterpriseOutput').textContent;
            if (!config) { alert('No configuration to copy!'); return; }
            navigator.clipboard.writeText(config).then(() => alert(' Configuration copied to clipboard (with real passwords)!')).catch(err => alert('Failed to copy: ' + err));
        }
        function downloadMPLSEnterpriseConfig() {
            const config = window.mplsEnterpriseConfigOriginal || document.getElementById('mplsEnterpriseOutput').textContent;
            if (!config) { alert('No configuration to download!'); return; }
            const deviceName = document.getElementById('ent_mpls_deviceName').value || 'mpls-enterprise-config';
            const blob = new Blob([config], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${deviceName}.rsc`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function clearMPLSEnterpriseOutput() {
            document.getElementById('mplsEnterpriseOutput').textContent = '';
            window.mplsEnterpriseConfigOriginal = '';
            window.mplsEnterprisePasswordsVisible = false;
            const btn = document.getElementById('toggleMPLSEntPasswordBtn');
            if (btn) btn.textContent = ' Show Passwords';
        }
        function addMPLSUplink() {
            const container = document.getElementById('ent_mpls_uplinksContainer');
            const deviceSel = document.getElementById('ent_mpls_routerboard_device');
            const device = deviceSel ? deviceSel.value : '';

            const newUplink = document.createElement('div');
            newUplink.className = 'interface-item';
            newUplink.innerHTML = `
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <div>
                        <label>Uplink Interface:</label>
                        <select class="ent_mpls_uplinkInterface">
                            <option value="">Select Interface (Choose Device First)</option>
                        </select>
                        <div class="hint">Ports will populate based on selected RouterBoard device</div>
                    </div>
                    <div>
                        <label>Uplink IP/Net:</label>
                        <input type="text" class="ent_mpls_uplinkIP" placeholder="10.247.57.4/29">
                    </div>
                </div>
                <div style="margin-top: 10px;">
                    <label>Uplink Comment/Location:</label>
                    <input type="text" class="ent_mpls_uplinkComment" placeholder="IL-CARMI-CN-1">
                </div>
                <button type="button" onclick="this.parentElement.remove()" style="background: #f44336; color: white; border: none; padding: 8px 12px; border-radius: 3px; cursor: pointer; margin-top: 10px;">Remove Uplink</button>
            `;
            container.appendChild(newUplink);
            // Re-populate interface dropdown for the new uplink
            updateMPLSEnterpriseInterfaces();
        }

        // ===== NEW TABS JAVASCRIPT FUNCTIONS =====

        // IP helpers for new tabs
        function ipToInt(ip) {
            const p = ip.split('.');
            return (((((+p[0]) << 24) >>> 0) + ((+p[1]) << 16) + ((+p[2]) << 8) + (+p[3])) >>> 0);
        }

        function intToIp(int) {
            return [(int >>> 24) & 255, (int >>> 16) & 255, (int >>> 8) & 255, int & 255].join('.');
        }

        function maskFromPrefix(prefix) {
            return prefix === 0 ? 0 : (~0 << (32 - prefix)) >>> 0;
        }

        function parseCidr(cidr) {
            const s = String(cidr || '').trim();
            if (!s) return null;

            const ix = s.indexOf('/');
            if (ix < 0) {
                // If no slash, assume /32 for single IP
                if (s.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
                    const o = s.split('.').map(function (n) { return parseInt(n, 10); });
                    if (o.length !== 4 || o.some(function (n) { return isNaN(n) || n < 0 || n > 255; })) return null;
                    return { ip: s, prefix: 32, mask: maskFromPrefix(32) };
                }
                return null;
            }

            const ip = s.substring(0, ix);
            const prefixStr = s.substring(ix + 1);

            // Handle trailing slash
            if (prefixStr === '') return null;

            const prefix = parseInt(prefixStr, 10);
            if (isNaN(prefix) || prefix < 0 || prefix > 32) return null;

            const o = ip.split('.').map(function (n) { return parseInt(n, 10); });
            if (o.length !== 4 || o.some(function (n) { return isNaN(n) || n < 0 || n > 255; })) return null;
            return { ip: ip, prefix: prefix, mask: maskFromPrefix(prefix) };
        }

        function derivePoolAfterGateway(c, gatewayInt, offset) {
            const start = gatewayInt + 1 + Math.max(0, offset | 0);
            if (start < c.firstHost) start = c.firstHost;
            if (start > c.lastHost) return null;
            return { start: intToIp(start), end: intToIp(c.lastHost) };
        }

        function setWarning(containerId, type, text) {
            const box = document.getElementById(containerId);
            if (!box) return;
            box.innerHTML = '<div class="warning" style="color: red; font-weight: bold;">' + text + '</div>';
        }

        function setFacts(containerId, c, gwInt) {
            const box = document.getElementById(containerId);
            if (!box) return;
            const html = [];
            function add(k, v) {
                if (v !== null && v !== undefined) html.push('<div><strong>' + k + ':</strong> ' + v + '</div>');
            }
            add('Network', c.ip + '/' + c.prefix);
            add('Gateway', intToIp(gwInt));
            add('First Host', intToIp(c.firstHost));
            add('Last Host', intToIp(c.lastHost));
            add('Broadcast', intToIp(c.broadcast));
            add('Usable IPs', c.lastHost - c.firstHost + 1);
            box.innerHTML = html.join('');
        }

        // Sub-tab toggle function for Tarana (BNG1 vs BNG2)
        function showTaranaSubTab(tab) {
            const bng1Section = document.getElementById('tarana-bng1-section');
            const bng2Section = document.getElementById('tarana-bng2-section');
            const bng1Btn = document.getElementById('tarana-bng1-btn');
            const bng2Btn = document.getElementById('tarana-bng2-btn');

            if (tab === 'bng1') {
                if (bng1Section) bng1Section.style.display = 'block';
                if (bng2Section) bng2Section.style.display = 'none';
                if (bng1Btn) {
                    bng1Btn.style.background = '#9C27B0';
                    bng1Btn.classList.add('active');
                }
                if (bng2Btn) {
                    bng2Btn.style.background = '#6c757d';
                    bng2Btn.classList.remove('active');
                }
            } else if (tab === 'bng2') {
                if (bng1Section) bng1Section.style.display = 'none';
                if (bng2Section) bng2Section.style.display = 'block';
                if (bng1Btn) {
                    bng1Btn.style.background = '#6c757d';
                    bng1Btn.classList.remove('active');
                }
                if (bng2Btn) {
                    bng2Btn.style.background = '#2196F3';
                    bng2Btn.classList.add('active');
                }
            }
        }

        // TARANA SECTORS Generator - Critical function - must always work
        // This function is isolated and self-contained
        async function genTarana() {
            try {
                // Show progress tracker
                window.showProgressTracker('Tarana Sector Configuration Generation');
                window.updateProgressStep('Initializing Tarana sector configuration...');
                window.updateProgressPercent(5);
                window.addProgressLog('info', 'Starting Tarana sector configuration generation');

                await new Promise(resolve => setTimeout(resolve, 300));

                window.updateProgressStep('Validating inputs...');
                window.updateProgressPercent(10);
                window.addProgressLog('info', 'Validating port selections and device configuration');

                const alpha = (document.getElementById('tarana_alphaPort') || document.getElementById('tower_tarana_alpha'))?.value || '';
                const beta = (document.getElementById('tarana_betaPort') || document.getElementById('tower_tarana_beta'))?.value || '';
                const gamma = (document.getElementById('tarana_gammaPort') || document.getElementById('tower_tarana_gamma'))?.value || '';
                const delta = (document.getElementById('tarana_deltaPort') || document.getElementById('tower_tarana_delta'))?.value || '';
                const unicornCidr = (document.getElementById('tarana_mgmtSubnet') || document.getElementById('tarana_unicornmgmt_subnet') || document.getElementById('tower_unicornmgmt_subnet'))?.value?.trim() || '';
                const deviceSel = (document.getElementById('tarana_routerboard_device') || document.getElementById('tarana_device') || document.getElementById('upgradeTargetDevice'));
                const device = deviceSel ? deviceSel.value.toLowerCase() : 'ccr2004';

                // ============================================================
                // BNG1 FORMAT DETECTION - CRITICAL FOR LIVE DEVICES
                // ============================================================
                // BNG1 Format Specification (IMMUTABLE):
                // - Bridge name: bridge3000 (NOT UNICORNMGMT)
                // - Bridge comment: "UNICORN MGMT" (with quotes)
                // - Ethernet comments: "Alpha", "Beta", "Gamma", "Delta" (quoted title case)
                // - NO speed/auto-negotiation on ethernet
                // - NO port-cost-mode on bridges
                // - NO path-cost parameters on bridge ports
                // - IP interface: bridge3000
                // - IP comment: "UNICORN MGMT" (with quotes)
                // - OSPF interface: bridge3000
                // ============================================================

                // Detect if this is BNG1 or BNG2
                // Check if BNG1 tab is active - use multiple checks for reliability
                const bng1Section = document.getElementById('tarana-bng1-section');
                const bng2Section = document.getElementById('tarana-bng2-section');
                const bng1Btn = document.getElementById('tarana-bng1-btn');
                const bng2Btn = document.getElementById('tarana-bng2-btn');

                // Determine active tab with fallback logic
                let isBNG1 = true; // Default to BNG1 for safety
                if (bng1Section && bng2Section) {
                    // Both sections exist - check display style
                    const bng1Visible = window.getComputedStyle(bng1Section).display !== 'none';
                    const bng2Visible = window.getComputedStyle(bng2Section).display !== 'none';
                    isBNG1 = bng1Visible && !bng2Visible;
                } else if (bng1Btn && bng2Btn) {
                    // Check button active state
                    isBNG1 = bng1Btn.classList.contains('active') && !bng2Btn.classList.contains('active');
                } else if (!bng2Section) {
                    // BNG2 section doesn't exist - must be BNG1
                    isBNG1 = true;
                }

                // VALIDATION: Ensure BNG1 format is always consistent
                // BNG1 uses bridge3000 with quoted comments, simple format
                const mgmtBridgeName = 'bridge3000'; // ALWAYS bridge3000 for BNG1
                const mgmtBridgeComment = '"UNICORN MGMT"'; // ALWAYS quoted
                const ipComment = '"UNICORN MGMT"'; // ALWAYS quoted
                const ethernetComments = ['Alpha', 'Beta', 'Gamma', 'Delta']; // ALWAYS title case

                // Log format detection for debugging
                window.addProgressLog('info', `Format: ${isBNG1 ? 'BNG1' : 'BNG2'} - Bridge: ${mgmtBridgeName}`);

                // Restrict to CCR2004/CCR2216 when selector exists
                if (deviceSel && !(device === 'ccr2004' || device === 'ccr2216')) {
                    window.addProgressLog('error', 'Tarana sectors are only supported on CCR2004 and CCR2216');
                    window.completeProgressTracker(false);
                    alert('Tarana sectors are only supported on CCR2004 and CCR2216.');
                    return;
                }

                if (!alpha || !beta || !gamma) {
                    window.addProgressLog('error', 'ALPHA, BETA, and GAMMA ports must be selected');
                    window.completeProgressTracker(false);
                    alert('Select ALPHA, BETA and GAMMA ports (DELTA optional).');
                    return;
                }

                window.updateProgressStep('Generating base configuration...');
                window.updateProgressPercent(20);
                window.addProgressLog('info', `Configuring sectors: ALPHA (${alpha}), BETA (${beta}), GAMMA (${gamma})${delta ? `, DELTA (${delta})` : ''}`);

                const sectorPorts = [alpha, beta, gamma].concat(delta ? [delta] : []);
                let config = '';

                // Get RouterOS version for speed syntax determination
                const routerOSSelect = document.getElementById('tarana_routeros_version');
                const routerOSVersion = routerOSSelect ? routerOSSelect.value : '';

                // Determine speed syntax based on RouterOS version
                // 7.11.2 and earlier: Legacy format (10Gbps)
                // 7.16.2 and later: New format (10G-baseSR-LR)
                let speedSyntax = '10Gbps'; // Default for 7.11.2 and earlier
                if (routerOSVersion === '7.16.2' || routerOSVersion === '7.19.4') {
                    speedSyntax = '10G-baseSR-LR';
                } else if (routerOSVersion === '7.11.2' || !routerOSVersion) {
                    speedSyntax = '10Gbps'; // Legacy format
                }

                window.updateProgressStep('Configuring Ethernet interfaces...');
                window.updateProgressPercent(30);
                window.addProgressLog('info', 'Setting port comments');

                // ============================================================
                // SECTION 1: INTERFACE ETHERNET (FIRST - matches your example)
                // BNG1 Format: Simple comments only, NO speed/auto-negotiation
                // ============================================================
                config += `/interface ethernet\n\n`;
                sectorPorts.forEach((p, i) => {
                    const comment = ethernetComments[i] || 'Sector';
                    // BNG1: ALWAYS quoted title case, NO speed/auto-negotiation
                    config += `set [ find default-name=${p} ] comment="${comment}"\n`;
                });
                config += `\n`;

                window.updateProgressStep('Creating bridges...');
                window.updateProgressPercent(40);
                window.addProgressLog('info', `Creating ${mgmtBridgeName} and bridge2000 bridges`);

                // ============================================================
                // SECTION 2: INTERFACE BRIDGE (SECOND - matches your example)
                // BNG1 Format: bridge3000 with "UNICORN MGMT" comment, NO port-cost-mode
                // ============================================================
                config += `/interface bridge\n\n`;
                // VALIDATION: Ensure bridge3000 is used (not UNICORNMGMT)
                if (mgmtBridgeName !== 'bridge3000') {
                    window.addProgressLog('error', 'CRITICAL: Bridge name must be bridge3000 for BNG1');
                    window.completeProgressTracker(false);
                    throw new Error('Invalid bridge name - must be bridge3000');
                }
                config += `add comment=${mgmtBridgeComment} name=${mgmtBridgeName}\n`;
                config += `add comment=STATIC name=bridge2000\n\n`;

                // IP Address - Add IP to UNICORNMGMT bridge
                if (unicornCidr) {
                    window.updateProgressStep('Configuring IP address and OSPF...');
                    window.updateProgressPercent(70);
                    window.addProgressLog('info', `Calculating network address for ${unicornCidr}`);

                    let networkAddr = '';
                    let routerIp = '';
                    let prefix = '29';
                    let networkCidrForOspf = '';

                    // Extract IP and prefix from user input (dynamically handle any format)
                    const cidrParts = String(unicornCidr).trim().split('/');
                    routerIp = cidrParts[0].trim(); // Use exactly what the user typed for IP
                    prefix = (cidrParts[1] || '29').trim();

                    // Validate routerIp format before proceeding
                    if (!routerIp || !routerIp.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
                        window.addProgressLog('error', 'Invalid IP address format');
                        window.completeProgressTracker(false);
                        alert('Invalid IP address format. Please enter a valid IP address (e.g., 10.32.5.89)');
                        return;
                    }

                    // Calculate network address using Nextlink convention: network = IP - 1
                    // This MUST work correctly every time - no exceptions
                    try {
                        // Convert user's IP to integer using the helper function
                        if (typeof ipToInt === 'function' && typeof intToIp === 'function') {
                            const routerIpInt = ipToInt(routerIp);
                            // Network = IP - 1 (Nextlink convention)
                            const networkInt = (routerIpInt - 1) >>> 0; // Use >>> 0 to handle underflow as unsigned
                            networkAddr = intToIp(networkInt);

                            // Validate network address is valid
                            if (!networkAddr || !networkAddr.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
                                throw new Error('Invalid network address calculated');
                            }

                            networkCidrForOspf = `${networkAddr}/${prefix}`;
                        } else {
                            // Fallback if helper functions not available: manual calculation
                            const parts = routerIp.split('.').map(Number);
                            if (parts.length !== 4 || parts.some(p => isNaN(p) || p < 0 || p > 255)) {
                                throw new Error('Invalid IP address format');
                            }

                            // Calculate network = IP - 1 (handle underflow)
                            let networkParts = [...parts];
                            if (networkParts[3] > 0) {
                                networkParts[3] = networkParts[3] - 1;
                            } else {
                                // Handle .0 case: wrap to previous octet
                                networkParts[3] = 255;
                                if (networkParts[2] > 0) {
                                    networkParts[2] = networkParts[2] - 1;
                                } else {
                                    networkParts[2] = 255;
                                    if (networkParts[1] > 0) {
                                        networkParts[1] = networkParts[1] - 1;
                                    } else {
                                        networkParts[1] = 255;
                                        networkParts[0] = Math.max(0, networkParts[0] - 1);
                                    }
                                }
                            }
                            networkAddr = networkParts.join('.');
                            networkCidrForOspf = `${networkAddr}/${prefix}`;
                        }
                    } catch (e) {
                        console.error('Network address calculation error:', e);
                        window.addProgressLog('error', 'Network address calculation failed: ' + e.message);
                        window.completeProgressTracker(false);
                        alert('Error calculating network address. Please check your IP address format.');
                        return;
                    }

                    // Add IP address line - ONLY ONCE, with validated values
                    // Ensure all values are clean strings with no unexpected characters
                    const cleanRouterIp = String(routerIp).trim();
                    const cleanPrefix = String(prefix).trim();
                    const cleanNetworkAddr = String(networkAddr).trim();

                    // Final validation before adding to config
                    if (!cleanRouterIp.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) ||
                        !cleanNetworkAddr.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/) ||
                        !cleanPrefix.match(/^\d{1,2}$/)) {
                        console.error('[TARANA] Validation failed before adding IP address line:', {
                            routerIp: cleanRouterIp,
                            prefix: cleanPrefix,
                            networkAddr: cleanNetworkAddr
                        });
                        alert('Error: Invalid values calculated for IP address. Please check your input and try again.');
                        return;
                    }

                    // ============================================================
                    // SECTION 3: IP ADDRESS (THIRD - matches your example)
                    // BNG1 Format: interface=bridge3000, comment="UNICORN MGMT"
                    // ============================================================
                    window.updateProgressStep('Configuring IP address...');
                    window.updateProgressPercent(50);
                    window.addProgressLog('info', `Calculating network address for ${unicornCidr}`);
                    config += `/ip address\n\n`;
                    config += `add address=${cleanRouterIp}/${cleanPrefix} comment=${ipComment} interface=${mgmtBridgeName} network=${cleanNetworkAddr}\n\n`;

                    window.updateProgressStep('Creating VLANs...');
                    window.updateProgressPercent(60);
                    window.addProgressLog('info', 'Creating VLANs 1000, 2000, 3000 for each sector');

                    // ============================================================
                    // SECTION 4: INTERFACE VLAN (FOURTH - matches your example)
                    // BNG1 Format: Create VLANs for each sector port
                    // ============================================================
                    config += `/interface vlan\n\n`;
                    sectorPorts.forEach(p => {
                        config += `add interface=${p} name=vlan1000-${p} vlan-id=1000\n`;
                        config += `add interface=${p} name=vlan2000-${p} vlan-id=2000\n`;
                        config += `add interface=${p} name=vlan3000-${p} vlan-id=3000\n`;
                    });
                    config += `\n`;

                    window.updateProgressStep('Configuring bridge ports...');
                    window.updateProgressPercent(70);
                    window.addProgressLog('info', 'Adding VLANs to bridges');

                    // ============================================================
                    // SECTION 5: INTERFACE BRIDGE PORT (FIFTH - matches your example)
                    // BNG1 Format: Simple format, NO path-cost parameters
                    // ============================================================
                    config += `/interface bridge port\n\n`;
                    // First add vlan3000 interfaces to management bridge
                    sectorPorts.forEach(p => {
                        config += `add bridge=${mgmtBridgeName} ingress-filtering=no interface=vlan3000-${p}\n`;
                    });
                    // Then add vlan1000 to lan-bridge
                    sectorPorts.forEach(p => {
                        config += `add bridge=lan-bridge ingress-filtering=no interface=vlan1000-${p}\n`;
                    });
                    // Finally add vlan2000 to bridge2000
                    sectorPorts.forEach(p => {
                        config += `add bridge=bridge2000 ingress-filtering=no interface=vlan2000-${p}\n`;
                    });
                    config += `\n`;

                    // ============================================================
                    // SECTION 6: ROUTING OSPF INTERFACE-TEMPLATE (SIXTH - matches your example)
                    // BNG1 Format: interfaces=bridge3000, comment="UNICORN MGMT"
                    // ============================================================
                    window.updateProgressStep('Configuring OSPF...');
                    window.updateProgressPercent(80);
                    window.addProgressLog('info', 'Adding OSPF interface-template');
                    config += `/routing ospf interface-template add interfaces=${mgmtBridgeName} cost=10 priority=1 area=backbone type=broadcast comment="UNICORN MGMT" network=${networkCidrForOspf}\n`;
                } else {
                    // If no IP address provided, still create VLANs and bridge ports
                    window.updateProgressStep('Creating VLANs...');
                    window.updateProgressPercent(60);
                    window.addProgressLog('info', 'Creating VLANs 1000, 2000, 3000 for each sector');

                    config += `/interface vlan\n\n`;
                    sectorPorts.forEach(p => {
                        config += `add interface=${p} name=vlan1000-${p} vlan-id=1000\n`;
                        config += `add interface=${p} name=vlan2000-${p} vlan-id=2000\n`;
                        config += `add interface=${p} name=vlan3000-${p} vlan-id=3000\n`;
                    });
                    config += `\n`;

                    window.updateProgressStep('Configuring bridge ports...');
                    window.updateProgressPercent(70);
                    window.addProgressLog('info', 'Adding VLANs to bridges');

                    config += `/interface bridge port\n\n`;
                    sectorPorts.forEach(p => {
                        config += `add bridge=${mgmtBridgeName} ingress-filtering=no interface=vlan3000-${p}\n`;
                    });
                    sectorPorts.forEach(p => {
                        config += `add bridge=lan-bridge ingress-filtering=no interface=vlan1000-${p}\n`;
                    });
                    sectorPorts.forEach(p => {
                        config += `add bridge=bridge2000 ingress-filtering=no interface=vlan2000-${p}\n`;
                    });
                    config += `\n`;
                }

                const out = document.getElementById('tarana_output');

                // ============================================================
                // FINAL VALIDATION: Ensure BNG1 format is correct
                // ============================================================
                // Validate IP address line uses bridge3000 (not UNICORNMGMT)
                const ipAddressLineMatch = config.match(/add address=([^\s]+)\s+comment=([^\s]+)\s+interface=bridge3000\s+network=([^\s]+)/);
                if (ipAddressLineMatch) {
                    const addressPart = ipAddressLineMatch[1];
                    const networkPart = ipAddressLineMatch[3]; // network is group 3

                    // Validate format - should be IP/prefix format
                    if (!addressPart.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\/\d{1,2}$/)) {
                        console.error('[TARANA] Invalid address format in config:', addressPart);
                        alert('Error: Invalid IP address format in generated config. Please try again.');
                        return;
                    }

                    // Validate network address format
                    if (!networkPart.match(/^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}$/)) {
                        console.error('[TARANA] Invalid network format in config:', networkPart);
                        alert('Error: Invalid network address format in generated config. Please try again.');
                        return;
                    }
                }

                // Validate OSPF uses bridge3000
                if (unicornCidr && !config.includes('interfaces=bridge3000')) {
                    window.addProgressLog('error', 'VALIDATION FAILED: OSPF must use interfaces=bridge3000');
                    window.completeProgressTracker(false);
                    alert('Configuration validation failed: OSPF must use bridge3000 interface');
                    return;
                }

                // Validate NO UNICORNMGMT references (should use bridge3000)
                if (config.includes('interface=UNICORNMGMT')) {
                    window.addProgressLog('error', 'VALIDATION FAILED: Must use bridge3000, not UNICORNMGMT');
                    window.completeProgressTracker(false);
                    alert('Configuration validation failed: Must use bridge3000 interface name');
                    return;
                }

                // Validate NO path-cost parameters (BNG1 format)
                if (config.includes('path-cost=') || config.includes('internal-path-cost=')) {
                    window.addProgressLog('error', 'VALIDATION FAILED: BNG1 format must not include path-cost parameters');
                    window.completeProgressTracker(false);
                    alert('Configuration validation failed: BNG1 format must not include path-cost parameters');
                    return;
                }

                // Validate NO port-cost-mode (BNG1 format)
                if (config.includes('port-cost-mode=')) {
                    window.addProgressLog('error', 'VALIDATION FAILED: BNG1 format must not include port-cost-mode');
                    window.completeProgressTracker(false);
                    alert('Configuration validation failed: BNG1 format must not include port-cost-mode');
                    return;
                }

                window.addProgressLog('info', ' BNG1 format validation passed');

                window.updateProgressStep('Sending to AI backend for validation...');
                window.updateProgressPercent(80);
                window.addProgressLog('info', 'Validating configuration with AI backend');

                // DO NOT show config yet - wait for AI validation to complete
                // This ensures the progress tracker completes before showing the config

                // Send to AI backend for validation, network calculation correction, and enhancement
                // Reuse deviceSel and routerosSel from above (already defined earlier in function)
                const routerosSel = document.getElementById('tarana_routeros_version');
                const finalDevice = device; // Use device already defined above
                const routerosVersion = routerosSel ? routerosSel.value : '7.19.4';

                // Use AI_API_BASE if defined, otherwise construct it
                const apiBase = resolveApiBase();

                // Prepare activity tracking data (will be used after completion)
                const deviceConfig = DEVICE_CONFIGS[finalDevice];
                const sectors = [alpha, beta, gamma].concat(delta ? [delta] : []).map((p, i) => ['ALPHA', 'BETA', 'GAMMA', 'DELTA'][i]).join(', ');

                // Add timeout to prevent hanging
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

                fetch(`${apiBase}/gen-tarana-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: config,
                        device: finalDevice,
                        routeros_version: routerosVersion
                    }),
                    signal: controller.signal
                })
                    .then(function (response) {
                        clearTimeout(timeoutId);
                        // Backend should ALWAYS return success - even if AI fails
                        if (!response.ok) {
                            // If backend returns error, still try to parse response
                            return response.json().catch(() => {
                                // If can't parse, return success with original config
                                return { success: true, config: config };
                            });
                        }
                        return response.json();
                    })
                    .then(function (data) {
                        window.updateProgressStep('Processing validation results...');
                        window.updateProgressPercent(90);
                        window.addProgressLog('info', 'Backend validation completed');

                        // Backend validates accurately - check success flag
                        let finalConfig = config; // Default to original
                        let validationSuccess = false;
                        let validationErrors = [];
                        let validationWarnings = [];

                        if (data && data.success === true && data.config) {
                            // Backend validated successfully - config is accurate
                            finalConfig = data.config;
                            validationSuccess = true;
                            validationWarnings = data.warnings || [];
                            window.addProgressLog('success', 'Configuration validated and enhanced by backend');

                            if (validationWarnings.length > 0) {
                                window.addProgressLog('warning', `Validation warnings: ${validationWarnings.join(', ')}`);
                            }
                        } else if (data && data.success === false) {
                            // Backend validation failed - config has errors
                            validationErrors = data.errors || [data.error || 'Validation failed'];
                            validationWarnings = data.warnings || [];
                            finalConfig = data.config || config; // Use corrected config if available, otherwise original

                            window.addProgressLog('error', `Validation failed: ${validationErrors.join(', ')}`);
                            if (validationWarnings.length > 0) {
                                window.addProgressLog('warning', `Warnings: ${validationWarnings.join(', ')}`);
                            }
                        } else if (data && data.config) {
                            // Backend returned config but no success flag - use it but warn
                            finalConfig = data.config;
                            window.addProgressLog('warning', 'Backend response unclear - using provided config');
                        } else {
                            // Backend returned but no config - use original
                            window.addProgressLog('warning', 'No config from backend - using generated configuration');
                        }

                        // Now show the config and complete progress tracker
                        if (validationSuccess) {
                            window.updateProgressStep('Configuration validated and ready!');
                            window.updateProgressPercent(100);
                            window.addProgressLog('success', 'Tarana sector configuration validated and ready for device deployment');
                        } else {
                            window.updateProgressStep('Configuration generated with validation issues');
                            window.updateProgressPercent(100);
                            window.addProgressLog('warning', 'Configuration generated but validation found issues - review before deployment');
                        }

                        // Display the final config
                        if (out) {
                            out.value = finalConfig;
                            out.style.opacity = '1';
                        }

                        // Show appropriate message based on validation result
                        const warnBox = document.getElementById('tarana_warn');
                        if (warnBox) {
                            if (validationSuccess) {
                                let message = '<div style="color: #4CAF50; font-weight: bold;"> Configuration validated and ready for device deployment</div>';
                                if (validationWarnings.length > 0) {
                                    message += `<div style="color: #ff9800; margin-top: 5px;"> Warnings: ${validationWarnings.join('; ')}</div>`;
                                }
                                warnBox.innerHTML = message;
                            } else {
                                let message = '<div style="color: #f44336; font-weight: bold;"> Configuration validation failed</div>';
                                if (validationErrors.length > 0) {
                                    message += `<div style="color: #f44336; margin-top: 5px;">Errors: ${validationErrors.join('; ')}</div>`;
                                }
                                if (validationWarnings.length > 0) {
                                    message += `<div style="color: #ff9800; margin-top: 5px;">Warnings: ${validationWarnings.join('; ')}</div>`;
                                }
                                message += '<div style="color: #ff9800; margin-top: 5px;"> Review configuration before deploying to device</div>';
                                warnBox.innerHTML = message;
                            }
                        }

                        // Complete progress tracker
                        window.completeProgressTracker(validationSuccess);

                        // Track activity for analytics (after everything is complete)
                        saveConfigToHistory({
                            type: 'tarana-config',
                            device: deviceConfig ? deviceConfig.name : finalDevice.toUpperCase(),
                            siteName: `Tarana Sectors: ${sectors}`,
                            routeros: routerosVersion,
                            success: validationSuccess
                        });
                    })
                    .catch(function (error) {
                        clearTimeout(timeoutId);
                        console.error('Backend request error:', error);

                        // Even if fetch fails, show the config (it's already generated)
                        window.updateProgressStep('Finalizing configuration...');
                        window.updateProgressPercent(95);
                        window.addProgressLog('info', 'Using generated configuration');

                        // Show the config (it's valid even without backend validation)
                        if (out) {
                            out.value = config;
                            out.style.opacity = '1';
                        }

                        const warnBox = document.getElementById('tarana_warn');
                        if (warnBox) {
                            warnBox.innerHTML = '<div style="color: #4CAF50; font-weight: bold;"> Configuration generated successfully - Ready for device deployment</div>';
                        }

                        // Complete progress tracker
                        window.updateProgressStep('Configuration ready!');
                        window.updateProgressPercent(100);
                        window.addProgressLog('success', 'Tarana sector configuration generated successfully');
                        window.completeProgressTracker(true);

                        // Track activity (config generated successfully)
                        saveConfigToHistory({
                            type: 'tarana-config',
                            device: deviceConfig ? deviceConfig.name : finalDevice.toUpperCase(),
                            siteName: `Tarana Sectors: ${sectors}`,
                            routeros: routerosVersion,
                            success: true
                        });
                    });

            } catch (error) {
                window.addProgressLog('error', 'Configuration generation failed: ' + error.message);
                window.completeProgressTracker(false);
                alert('Error generating configuration: ' + error.message);
                console.error('Tarana generation error:', error);
            }
        }

        // Enterprise Feeding Generator
        async function genEntFeeding() {
            try {
                // Show progress tracker
                window.showProgressTracker('Enterprise Feeding Configuration');
                window.updateProgressStep('Initializing Enterprise Feeding configuration...');
                window.updateProgressPercent(5);
                window.addProgressLog('info', 'Starting Enterprise Feeding configuration generation');

                await new Promise(resolve => setTimeout(resolve, 300));

                window.updateProgressStep('Reading form inputs...');
                window.updateProgressPercent(10);
                window.addProgressLog('info', 'Validating device, RouterOS version, and port selection');

                const device = document.getElementById('ent_feeding_device')?.value;
                const routerOS = document.getElementById('ent_feeding_routeros')?.value;
                const label = document.getElementById('ent_feeding_label')?.value.trim() || 'Customer';
                const port = document.getElementById('ent_feeding_port')?.value.trim();
                const speed = document.getElementById('ent_feeding_speed')?.value || 'auto';
                const loop = document.getElementById('ent_feeding_loop')?.value.trim();
                const uplink = document.getElementById('ent_feeding_uplink')?.value.trim(); // Backhaul /29 subnet
                const publicIP = document.getElementById('ent_feeding_public')?.value.trim(); // Public /30 or /29

                if (!device || !routerOS || !port) {
                    window.addProgressLog('error', 'Missing required fields: device, RouterOS version, or port');
                    window.completeProgressTracker(false);
                    alert('Please select device, RouterOS version, and port!');
                    return;
                }

                if (!uplink) {
                    window.addProgressLog('error', 'Backhaul subnet (/29) is required');
                    window.completeProgressTracker(false);
                    alert('Please provide Backhaul subnet (/29) - this is required for backhaul configuration!');
                    return;
                }

                window.addProgressLog('success', `Device: ${device}, RouterOS: ${routerOS}, Port: ${port}, Label: ${label}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Processing device configuration...');
                window.updateProgressPercent(20);
                window.addProgressLog('info', 'Loading device configuration and RouterOS version type');

                const deviceConfig = DEVICE_CONFIGS[device];
                const versionType = getRouterOSVersionType(routerOS);

                window.updateProgressStep('Parsing backhaul subnet...');
                window.updateProgressPercent(30);
                window.addProgressLog('info', `Parsing uplink subnet: ${uplink}`);

                // Parse uplink subnet (/29) - user enters tower IP like 10.24.252.57/29
                let backhaulIP = ''; // Tower side IP (e.g., 10.24.252.57)
                let backhaulNetwork = ''; // Network address (e.g., 10.24.252.56)
                let gatewayIP = ''; // Customer gateway (e.g., 10.24.252.60)
                let backhaulPrefix = ''; // Prefix length (e.g., 29)

                try {
                    // Validate uplink input before processing - check multiple times
                    if (!uplink) {
                        alert('Please provide Backhaul subnet (/29) - this is required for backhaul configuration!');
                        return;
                    }

                    if (typeof uplink !== 'string') {
                        alert('Invalid uplink input type. Please enter a valid CIDR format (e.g., 10.24.252.57/29)');
                        return;
                    }

                    const uplinkTrimmed = uplink.trim();
                    if (!uplinkTrimmed || uplinkTrimmed === '') {
                        alert('Please provide Backhaul subnet (/29) - this field cannot be empty!');
                        return;
                    }

                    if (!uplinkTrimmed.includes('/')) {
                        alert('Invalid uplink format. Please use CIDR format with / prefix (e.g., 10.24.252.57/29)');
                        return;
                    }

                    // Extract IP and prefix from user input
                    const uplinkParts = uplinkTrimmed.split('/');
                    if (!uplinkParts || uplinkParts.length !== 2) {
                        alert('Invalid uplink format. Please use CIDR format (e.g., 10.24.252.57/29)');
                        return;
                    }

                    const userIP = uplinkParts[0] ? uplinkParts[0].trim() : '';
                    backhaulPrefix = uplinkParts[1] ? uplinkParts[1].trim() : '';

                    if (!userIP || !backhaulPrefix) {
                        alert('Invalid uplink format. Both IP and prefix are required (e.g., 10.24.252.57/29)');
                        return;
                    }

                    // Validate prefix is a number
                    if (isNaN(parseInt(backhaulPrefix, 10))) {
                        alert(`Invalid prefix length: ${backhaulPrefix}. Please use a number (e.g., 29)`);
                        return;
                    }

                    // Calculate network, broadcast, first/last host directly (don't rely on parseCidr format)
                    try {
                        // Validate IP format
                        const ipParts = userIP.split('.');
                        if (ipParts.length !== 4) {
                            alert('Invalid IP address format. Please use format like 10.24.252.57');
                            return;
                        }

                        const ipInt = ipToInt(userIP);
                        const prefixNum = parseInt(backhaulPrefix, 10);

                        if (isNaN(prefixNum) || prefixNum < 0 || prefixNum > 32) {
                            alert(`Invalid prefix length: ${backhaulPrefix}. Must be between 0 and 32.`);
                            return;
                        }

                        // For Enterprise Feeding Side, user enters the network address directly
                        // Example: User enters 10.25.26.52/29 means network = 10.25.26.52 (not canonical 10.25.26.48)
                        // Calculate IP allocation for 2+0 backhaul pattern in /29:
                        // - Network: User's entered IP (e.g., 10.25.26.52)
                        // - First usable (network + 1): 10.25.26.53 = Tower side gateway  USE THIS ON INTERFACE
                        // - Second usable (network + 2): 10.25.26.54 = Feeding backhaul (tower side)
                        // - Third usable (network + 3): 10.25.26.55 = Landing backhaul (customer side)
                        // - Fourth usable (network + 4): 10.25.26.56 = Customer side gateway  USE THIS FOR ROUTES

                        // Use the user's entered IP as the network base (don't calculate canonical network)
                        const networkInt = ipInt; // User's IP is the network address

                        // For /29 subnet: 2^(32-29) = 8 total addresses (network + broadcast + 6 usable)
                        // Usable IPs: 6 (network+1 through network+6, excluding network and broadcast)
                        // Broadcast = network + (total_addresses - 1)
                        const totalAddresses = Math.pow(2, 32 - prefixNum); // For /29: 8 total
                        const usableIPs = prefixNum >= 31 ? totalAddresses : (totalAddresses - 2); // For /29: 6 usable
                        const broadcastInt = (networkInt + (totalAddresses - 1)) >>> 0; // Ensure unsigned 32-bit

                        // Calculate IPs for 2+0 backhaul pattern
                        const towerGatewayInt = (networkInt + 1) >>> 0; // 1st usable = Tower Gateway (interface)
                        const customerGatewayInt = (networkInt + 4) >>> 0; // 4th usable = Customer Gateway (routes)

                        // Validate that we have enough IPs for 2+0 backhaul pattern
                        // For /29: 6 usable IPs (network+1 through network+6)
                        // We need: network+1, network+2, network+3, network+4 = 4 usable IPs
                        // Last usable = broadcast - 1 (for /29 and larger, but /31 and /32 are special cases)
                        const lastUsableInt = prefixNum >= 31 ? broadcastInt : ((broadcastInt - 1) >>> 0);

                        // Debug logging
                        console.log(`[VALIDATION] Network: ${intToIp(networkInt >>> 0)}, Broadcast: ${intToIp(broadcastInt >>> 0)}, Last Usable: ${intToIp(lastUsableInt >>> 0)}`);
                        console.log(`[VALIDATION] Total addresses: ${totalAddresses}, Usable IPs: ${usableIPs}`);
                        console.log(`[VALIDATION] Customer Gateway: ${intToIp(customerGatewayInt >>> 0)}, Comparison: ${customerGatewayInt} <= ${lastUsableInt}`);
                        console.log(`[VALIDATION] Raw values - CustomerGW: ${customerGatewayInt}, LastUsable: ${lastUsableInt}, Result: ${customerGatewayInt <= lastUsableInt}`);

                        // For /29, we need network + 4 <= lastUsableInt
                        // /29 gives 6 usable IPs: network+1, +2, +3, +4, +5, +6 (network and broadcast excluded)
                        // So lastUsable = broadcast - 1 = network + 6
                        // We need network + 4 <= network + 6, which is always true for /29
                        if (customerGatewayInt > lastUsableInt) {
                            alert(`Not enough usable IPs in /${backhaulPrefix} subnet for 2+0 backhaul pattern.\n\nSubnet: ${intToIp(networkInt >>> 0)}/${backhaulPrefix}\nTotal addresses: ${totalAddresses}\nUsable IPs: ${usableIPs}\nLast usable: ${intToIp(lastUsableInt >>> 0)}\nRequired (4th usable): ${intToIp(customerGatewayInt >>> 0)}\n\nFor /29, you have 6 usable IPs, which is sufficient for the 2+0 backhaul pattern (needs 4 usable IPs).`);
                            console.error(`[VALIDATION FAILED] Customer Gateway (${customerGatewayInt}) exceeds Last Usable (${lastUsableInt})`);
                            return;
                        }

                        // Convert to IP strings
                        backhaulIP = intToIp(towerGatewayInt >>> 0); // Tower side gateway = network + 1 (used on interface)
                        backhaulNetwork = intToIp(networkInt >>> 0); // Network address = user's entered IP
                        gatewayIP = intToIp(customerGatewayInt >>> 0); // Customer side gateway = network + 4 (used in routes)

                        console.log(`[ENTERPRISE FEEDING] Input: ${uplinkTrimmed}`);
                        console.log(`[ENTERPRISE FEEDING] Network: ${backhaulNetwork}`);
                        console.log(`[ENTERPRISE FEEDING] Tower Gateway IP (1st usable, interface): ${backhaulIP}`);
                        console.log(`[ENTERPRISE FEEDING] Customer Gateway (4th usable, routes): ${gatewayIP}`);
                        console.log(`[ENTERPRISE FEEDING] Prefix: /${backhaulPrefix}`);
                        console.log(`[ENTERPRISE FEEDING] IP Allocation: ${backhaulNetwork}=Network, ${backhaulIP}=Tower GW (interface), ${intToIp((networkInt + 2) >>> 0)}=Feeding Backhaul, ${intToIp((networkInt + 3) >>> 0)}=Landing Backhaul, ${gatewayIP}=Customer GW (routes)`);

                    } catch (calcError) {
                        alert('Failed to calculate network address. Please verify your CIDR format (e.g., 10.24.252.57/29). Error: ' + (calcError.message || String(calcError)));
                        console.error('Network calculation error:', calcError);
                        console.error('Input values:', { userIP, backhaulPrefix, uplinkTrimmed });
                        return;
                    }

                    // Note: We already use user's IP as network base, so validation is not needed here
                    // The validation above ensures the 4th usable IP is within the subnet range

                } catch (e) {
                    alert('Error parsing uplink subnet: ' + (e.message || String(e)));
                    console.error('Parsing error:', e);
                    console.error('Uplink value was:', uplink, 'Type:', typeof uplink);
                    return;
                }

                // Build network CIDR for OSPF
                const backhaulNetworkCidr = `${backhaulNetwork}/${backhaulPrefix}`;

                window.addProgressLog('success', `Backhaul network: ${backhaulNetworkCidr}, Gateway: ${gatewayIP}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Generating Enterprise Feeding configuration...');
                window.updateProgressPercent(50);
                window.addProgressLog('info', 'Building configuration blocks');

                let config = `# === Enterprise / Commercial Auto-generated ===\n\n`;

                window.updateProgressStep('Configuring interface settings...');
                window.updateProgressPercent(55);
                window.addProgressLog('info', `Configuring Ethernet interface ${port} with speed ${speed}`);

                // Interface Ethernet - combine all settings into one command (no duplicates)
                config += `/interface ethernet\n`;
                const ethernetParts = [`comment=${label}`];
                if (speed === 'auto') {
                    ethernetParts.push('auto-negotiation=yes');
                } else {
                    ethernetParts.push('auto-negotiation=no');
                    // Add speed parameter - already in correct format from dropdown
                    if (speed.includes('duplex=')) {
                        // Legacy: 1Gbps-duplex=full
                        ethernetParts.push(speed);
                    } else {
                        // New: 1G-baseT-full
                        ethernetParts.push(`speed=${speed}`);
                    }
                }
                config += `set [ find default-name=${port} ] ${ethernetParts.join(' ')}\n\n`;

                window.addProgressLog('success', 'Interface Ethernet configured');
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Configuring IP address...');
                window.updateProgressPercent(60);
                window.addProgressLog('info', `Adding IP address ${backhaulIP}/${backhaulPrefix} to interface ${port}`);

                // IP Address - Only backhaul (/29) - Use tower side IP (user's input)
                config += `/ip address\n`;
                // Tower side uses the IP user entered, network parameter is the calculated network address
                config += `add address=${backhaulIP}/${backhaulPrefix} comment="${label}" interface=${port} network=${backhaulNetwork}\n\n`;

                window.addProgressLog('success', 'IP address configured');
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Configuring firewall and routing...');
                window.updateProgressPercent(70);
                window.addProgressLog('info', 'Adding firewall address-list entries');

                // IP Firewall Address List
                config += `/ip firewall address-list\n`;
                if (loop) {
                    const loopIP = loop.includes('/') ? loop.split('/')[0] : loop;
                    config += `add address=${loopIP} comment="${label}" list=bgp-networks\n`;
                    window.addProgressLog('info', `Added loopback ${loopIP} to BGP networks`);
                }
                if (publicIP) {
                    config += `add address=${publicIP} comment="${label}" list=bgp-networks\n`;
                    window.addProgressLog('info', `Added public IP ${publicIP} to BGP networks`);
                }
                config += `\n`;

                window.updateProgressStep('Adding static routes...');
                window.updateProgressPercent(75);
                window.addProgressLog('info', 'Configuring static routes for loopback and public IP');

                // IP Routes
                if (loop || publicIP) {
                    config += `/ip route\n`;
                    if (loop) {
                        const loopIP = loop.includes('/') ? loop.split('/')[0] : loop;
                        config += `add comment="${label}" disabled=no distance=1 dst-address=${loopIP} gateway=${gatewayIP} routing-table=main scope=30 target-scope=10\n`;
                        window.addProgressLog('info', `Route added for loopback ${loopIP} via ${gatewayIP}`);
                    }
                    if (publicIP) {
                        config += `add comment="${label}" disabled=no distance=1 dst-address=${publicIP} gateway=${gatewayIP} routing-table=main scope=30 target-scope=10\n`;
                        window.addProgressLog('info', `Route added for public IP ${publicIP} via ${gatewayIP}`);
                    }
                    config += `\n`;
                }

                window.updateProgressStep('Configuring OSPF...');
                window.updateProgressPercent(85);
                window.addProgressLog('info', 'Adding OSPF interface template');

                // OSPF Interface Template
                // Format: add area=backbone-v2 auth-id=1 comment="..." cost=10 disabled=no networks=X.X.X.X/29 priority=1
                config += `/routing ospf interface-template\n`;
                config += `add area=backbone-v2 auth-id=1 comment="${label}" cost=10 disabled=no networks=${backhaulNetworkCidr} priority=1\n`;

                window.addProgressLog('success', `OSPF interface template configured for ${backhaulNetworkCidr}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                // Show status and validate BEFORE displaying config
                const warnBox = document.getElementById('ent_feeding_warn');
                const out = document.getElementById('ent_feeding_output');

                window.updateProgressStep('Validating configuration with AI...');
                window.updateProgressPercent(90);
                window.addProgressLog('info', 'Sending configuration to AI backend for validation');

                // Show "Generating..." status
                if (warnBox) {
                    warnBox.innerHTML = '<div style="color: #FF9800; font-weight: bold;"> Configuration generated, validating with AI backend...</div>';
                }

                // Clear output initially
                if (out) {
                    out.value = '';
                    out.style.opacity = '0.5';
                }

                // Validate BEFORE showing config (like Non-MPLS Enterprise)
                if (typeof AI_API_BASE === 'undefined') {
                    console.error('AI_API_BASE not defined');
                    window.addProgressLog('warning', 'AI validation skipped (API base not configured)');
                    window.completeProgressTracker(true);

                    // Track activity (config generated, validation skipped)
                    const device = document.getElementById('ent_feeding_device')?.value || 'Unknown';
                    const routerOS = document.getElementById('ent_feeding_routeros')?.value || 'Unknown';
                    const label = document.getElementById('ent_feeding_label')?.value.trim() || 'Customer';
                    saveConfigToHistory({
                        type: 'enterprise-feeding-config',
                        device: device,
                        siteName: `Enterprise Feeding: ${label}`,
                        routeros: routerOS,
                        success: true
                    });

                    // Show config anyway if backend unavailable
                    if (out) {
                        out.value = config;
                        out.style.opacity = '1';
                    }
                    if (warnBox) {
                        warnBox.innerHTML = '<div style="color: #6c757d; font-style: italic;"> Configuration generated. AI validation skipped (API base not configured).</div>';
                    }
                    return;
                }

                // Validate config with AI backend
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout for AI validation (AI can be slow)

                fetch(`${AI_API_BASE}/validate-config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        config: config,
                        type: 'enterprise-feeding'
                    }),
                    signal: controller.signal
                })
                    .then(function (response) {
                        clearTimeout(timeoutId);

                        if (response.ok) {
                            return response.json().then(function (validation) {
                                window.updateProgressPercent(95);
                                window.addProgressLog('info', 'AI validation response received');

                                // Show config after validation
                                if (out) {
                                    out.value = config;
                                    out.style.opacity = '1';
                                }

                                if (validation && validation.validation && validation.validation.issues && validation.validation.issues.length > 0) {
                                    window.addProgressLog('warning', `Validation found ${validation.validation.issues.length} issue(s)`);
                                    window.completeProgressTracker(true);

                                    // Track activity for analytics (still success, just with warnings)
                                    const device = document.getElementById('ent_feeding_device')?.value || 'Unknown';
                                    const routerOS = document.getElementById('ent_feeding_routeros')?.value || 'Unknown';
                                    const label = document.getElementById('ent_feeding_label')?.value.trim() || 'Customer';
                                    saveConfigToHistory({
                                        type: 'enterprise-feeding-config',
                                        device: device,
                                        siteName: `Enterprise Feeding: ${label}`,
                                        routeros: routerOS,
                                        success: true
                                    });

                                    if (warnBox) {
                                        warnBox.innerHTML = '<div style="color: #FF9800; font-weight: bold;"> Configuration validated with warnings. Review before deployment.</div>';
                                    }
                                } else {
                                    window.updateProgressPercent(100);
                                    window.updateProgressStep('Configuration validated successfully!');
                                    window.addProgressLog('success', 'AI validation passed - no issues found');
                                    window.completeProgressTracker(true);

                                    // Track activity for analytics
                                    const device = document.getElementById('ent_feeding_device')?.value || 'Unknown';
                                    const routerOS = document.getElementById('ent_feeding_routeros')?.value || 'Unknown';
                                    const label = document.getElementById('ent_feeding_label')?.value.trim() || 'Customer';
                                    saveConfigToHistory({
                                        type: 'enterprise-feeding-config',
                                        device: device,
                                        siteName: `Enterprise Feeding: ${label}`,
                                        routeros: routerOS,
                                        success: true
                                    });

                                    if (warnBox) {
                                        warnBox.innerHTML = '<div style="color: #4CAF50; font-weight: bold;"> Configuration validated successfully by AI backend!</div>';
                                    }
                                }
                            });
                        } else {
                            // Show config anyway if validation fails
                            if (out) {
                                out.value = config;
                                out.style.opacity = '1';
                            }

                            const errorText = response.text().catch(() => '');
                            console.warn('AI validation returned status:', response.status);
                            if (warnBox) {
                                if (response.status === 404) {
                                    warnBox.innerHTML = '<div style="color: #6c757d; font-style: italic;"> Configuration generated. AI validation endpoint not found (backend may need update).</div>';
                                } else if (response.status >= 500) {
                                    warnBox.innerHTML = '<div style="color: #6c757d; font-style: italic;"> Configuration generated. AI validation temporarily unavailable (server error).</div>';
                                } else {
                                    warnBox.innerHTML = '<div style="color: #6c757d; font-style: italic;"> Configuration generated. AI validation returned error (status: ' + response.status + ').</div>';
                                }
                            }
                        }
                    })
                    .catch(function (aiError) {
                        clearTimeout(timeoutId);

                        window.addProgressLog('warning', 'AI validation failed or timed out');

                        // Show config even if validation fails
                        if (out) {
                            out.value = config;
                            out.style.opacity = '1';
                        }

                        // Track activity even if validation fails (config was still generated)
                        const device = document.getElementById('ent_feeding_device')?.value || 'Unknown';
                        const routerOS = document.getElementById('ent_feeding_routeros')?.value || 'Unknown';
                        const label = document.getElementById('ent_feeding_label')?.value.trim() || 'Customer';

                        if (aiError.name === 'AbortError') {
                            window.addProgressLog('warning', 'AI validation timeout after 30 seconds');
                            window.completeProgressTracker(true);
                            console.warn('AI validation timeout after 30 seconds');

                            // Track activity (config generated, validation timeout)
                            saveConfigToHistory({
                                type: 'enterprise-feeding-config',
                                device: device,
                                siteName: `Enterprise Feeding: ${label}`,
                                routeros: routerOS,
                                success: true
                            });

                            if (warnBox) {
                                warnBox.innerHTML = '<div style="color: #6c757d; font-style: italic;"> Configuration generated. AI validation timeout (Ollama may be processing - check backend console).</div>';
                            }
                        } else if (aiError.message && (aiError.message.includes('Failed to fetch') || aiError.message.includes('NetworkError'))) {
                            window.addProgressLog('warning', 'Cannot reach AI backend');
                            window.completeProgressTracker(true);
                            console.warn('AI validation network error:', aiError);

                            // Track activity (config generated, backend unavailable)
                            const device = document.getElementById('ent_feeding_device')?.value || 'Unknown';
                            const routerOS = document.getElementById('ent_feeding_routeros')?.value || 'Unknown';
                            const label = document.getElementById('ent_feeding_label')?.value.trim() || 'Customer';
                            saveConfigToHistory({
                                type: 'enterprise-feeding-config',
                                device: device,
                                siteName: `Enterprise Feeding: ${label}`,
                                routeros: routerOS,
                                success: true
                            });

                            if (warnBox) {
                                warnBox.innerHTML = '<div style="color: #6c757d; font-style: italic;"> Configuration generated. AI validation skipped (cannot reach backend - check if api_server.py is running on port 5000).</div>';
                            }
                        } else {
                            window.addProgressLog('warning', 'AI validation error: ' + (aiError.message || 'Unknown'));
                            window.completeProgressTracker(true);
                            console.warn('AI validation error:', aiError);

                            // Track activity (config generated, validation error)
                            const device = document.getElementById('ent_feeding_device')?.value || 'Unknown';
                            const routerOS = document.getElementById('ent_feeding_routeros')?.value || 'Unknown';
                            const label = document.getElementById('ent_feeding_label')?.value.trim() || 'Customer';
                            saveConfigToHistory({
                                type: 'enterprise-feeding-config',
                                device: device,
                                siteName: `Enterprise Feeding: ${label}`,
                                routeros: routerOS,
                                success: true
                            });

                            if (warnBox) {
                                warnBox.innerHTML = '<div style="color: #6c757d; font-style: italic;"> Configuration generated. AI validation error: ' + (aiError.message || 'Unknown error') + '</div>';
                            }
                        }
                    });

            } catch (error) {
                window.addProgressLog('error', 'Configuration generation failed: ' + error.message);
                window.completeProgressTracker(false);
                alert('Error generating configuration: ' + error.message);
                console.error('Enterprise Feeding Generation Error:', error);
            }
        }

        // Copy functions for new tabs
        function copyCCR() {
            try {
                const config = document.getElementById('ccr_output').textContent;
                if (!config) {
                    alert('No configuration to copy!');
                    return;
                }
                navigator.clipboard.writeText(config).then(() => alert(' Configuration copied to clipboard!')).catch(err => alert('Failed to copy: ' + err));
            } catch (error) {
                alert('Error copying configuration: ' + error.message);
            }
        }

        function copyTarana() {
            try {
                const output = document.getElementById('tarana_output');
                if (!output) {
                    alert('No configuration output found!');
                    return;
                }

                const config = output.value || output.textContent || '';
                if (!config || config.trim() === '') {
                    alert('No configuration to copy! Please generate a configuration first.');
                    return;
                }

                // Use modern clipboard API with proper error handling
                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(config).then(() => {
                        alert(' Configuration copied to clipboard!');
                    }).catch(() => {
                        // Fallback to execCommand
                        output.select();
                        output.setSelectionRange(0, 99999); // For mobile
                        document.execCommand('copy');
                        alert(' Configuration copied to clipboard!');
                    });
                } else {
                    // Fallback for older browsers
                    output.select();
                    output.setSelectionRange(0, 99999); // For mobile
                    document.execCommand('copy');
                    alert(' Configuration copied to clipboard!');
                }
            } catch (error) {
                alert('Error copying configuration: ' + error.message);
                console.error('Copy error:', error);
            }
        }

        // TARANA SECTORS BNG2 Generator - Critical function - must always work
        // This function is isolated and self-contained
        function genTaranaBNG2() {
            try {
                const deviceSel = document.getElementById('tarana_bng2_device');
                const device = deviceSel ? deviceSel.value.toLowerCase() : 'ccr2004';
                const sectorCount = parseInt(document.getElementById('tarana_bng2_sector_count')?.value || '3', 10);

                const alphaPort = document.getElementById('tarana_bng2_alphaPort')?.value || 'sfp-sfpplus8';
                const betaPort = document.getElementById('tarana_bng2_betaPort')?.value || 'sfp-sfpplus9';
                const gammaPort = document.getElementById('tarana_bng2_gammaPort')?.value || 'sfp-sfpplus10';
                const deltaPort = sectorCount === 4 ? (document.getElementById('tarana_bng2_deltaPort')?.value || 'sfp-sfpplus6') : null;

                // Validate required ports
                if (!alphaPort || !betaPort || !gammaPort) {
                    alert('Please select ALPHA, BETA, and GAMMA ports.');
                    return;
                }

                if (sectorCount === 4 && !deltaPort) {
                    alert('Please select DELTA port for 4-sector configuration.');
                    return;
                }

                // Build sector ports array
                const sectorPorts = [alphaPort, betaPort, gammaPort];
                if (deltaPort) sectorPorts.push(deltaPort);

                const sectorNames = ['Alpha', 'Beta', 'Gamma', 'Delta'];

                // Get RouterOS version for speed syntax determination
                const routerOSSelect = document.getElementById('tarana_bng2_routeros_version') || document.getElementById('tarana_routeros_version');
                const routerOSVersion = routerOSSelect ? routerOSSelect.value : '';

                // Determine speed syntax based on RouterOS version
                // 7.11.2 and earlier: Legacy format (10Gbps)
                // 7.16.2 and later: New format (10G-baseSR-LR)
                let speedSyntax = '10Gbps'; // Default for 7.11.2 and earlier
                if (routerOSVersion === '7.16.2' || routerOSVersion === '7.19.4') {
                    speedSyntax = '10G-baseSR-LR';
                } else if (routerOSVersion === '7.11.2' || !routerOSVersion) {
                    speedSyntax = '10Gbps'; // Legacy format
                }

                let config = `###################################\n###       TARANA CONFIG         ###\n###################################\n\n`;

                // Interface Ethernet - Set port comments and speed (matches example format)
                config += `/interface ethernet\n`;
                sectorPorts.forEach((port, i) => {
                    config += `set [ find default-name="${port}" ] auto-negotiation=no comment="${sectorNames[i]}" speed=${speedSyntax}\n`;
                });
                config += `\n`;

                // Interface VLAN - Create VLANs for each sector port (VLANs 1000, 2000, 3000 only)
                config += `/interface vlan\n`;
                sectorPorts.forEach(port => {
                    config += `add interface="${port}" name="vlan1000-${port}" vlan-id="1000"\n`;
                    config += `add interface="${port}" name="vlan2000-${port}" vlan-id="2000"\n`;
                    config += `add interface="${port}" name="vlan3000-${port}" vlan-id="3000"\n`;
                });
                config += `\n\n`;

                // Interface Bridge Port - Add VLANs to bridges
                // Order matches example: bridge3000 (VLAN 3000), bridge1000 (VLAN 1000), bridge2000 (VLAN 2000)
                config += `/interface bridge port\n`;
                // First add vlan3000 to bridge3000 (all sectors)
                sectorPorts.forEach(port => {
                    config += `add bridge=bridge3000 interface=vlan3000-${port}\n`;
                });
                // Then add vlan1000 to bridge1000 (all sectors)
                sectorPorts.forEach(port => {
                    config += `add bridge=bridge1000 interface=vlan1000-${port}\n`;
                });
                // Finally add vlan2000 to bridge2000 (all sectors)
                sectorPorts.forEach(port => {
                    config += `add bridge=bridge2000 interface=vlan2000-${port}\n`;
                });

                // Display config
                const output = document.getElementById('tarana_bng2_output');
                if (output) {
                    output.value = config;
                }

                const warnBox = document.getElementById('tarana_bng2_warn');
                if (warnBox) {
                    warnBox.innerHTML = `<div style="color: #4CAF50; font-weight: bold;"> BNG2 Configuration generated successfully! (${sectorCount} sectors)</div>`;
                }

            } catch (error) {
                alert('Error generating BNG2 configuration: ' + error.message);
                console.error('BNG2 Generation Error:', error);
            }
        }

        function copyTaranaBNG2() {
            try {
                const output = document.getElementById('tarana_bng2_output');
                if (!output) {
                    alert('No configuration output found!');
                    return;
                }

                const config = output.value;
                if (!config || config.trim() === '') {
                    alert('No configuration to copy! Please generate a configuration first.');
                    return;
                }

                if (navigator.clipboard && navigator.clipboard.writeText) {
                    navigator.clipboard.writeText(config).then(() => {
                        alert(' BNG2 Configuration copied to clipboard!');
                    }).catch(err => {
                        // Fallback to execCommand
                        output.select();
                        document.execCommand('copy');
                        alert(' BNG2 Configuration copied to clipboard!');
                    });
                } else {
                    // Fallback for older browsers
                    output.select();
                    document.execCommand('copy');
                    alert(' BNG2 Configuration copied to clipboard!');
                }
            } catch (error) {
                alert('Error copying configuration: ' + error.message);
                console.error('Copy error:', error);
            }
        }

        function copyEntFeeding() {
            try {
                const output = document.getElementById('ent_feeding_output');
                if (!output) {
                    alert('No configuration output found!');
                    return;
                }

                const config = output.value;
                if (!config || config.trim() === '') {
                    alert('No configuration to copy! Please generate a configuration first.');
                    return;
                }

                // Use modern clipboard API with fallback
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(config).then(() => {
                        alert(' Configuration copied to clipboard!');
                    }).catch(() => {
                        // Fallback to compatibility method
                        output.select();
                        output.setSelectionRange(0, 99999); // For mobile
                        document.execCommand('copy');
                        alert(' Configuration copied to clipboard!');
                    });
                } else {
                    // Fallback for older browsers
                    output.select();
                    output.setSelectionRange(0, 99999); // For mobile
                    document.execCommand('copy');
                    alert(' Configuration copied to clipboard!');
                }
            } catch (error) {
                alert('Error copying configuration: ' + error.message);
                console.error('Copy error:', error);
            }
        }

        // Enterprise Feeding Out-of-State Generator
        async function genEntFeedingOutState() {
            try {
                // Show progress tracker
                window.showProgressTracker('Enterprise Feeding Out-of-State Configuration');
                window.updateProgressStep('Initializing Out-of-State BNG configuration...');
                window.updateProgressPercent(5);
                window.addProgressLog('info', 'Starting Out-of-State BNG configuration generation');

                await new Promise(resolve => setTimeout(resolve, 300));

                window.updateProgressStep('Reading form inputs...');
                window.updateProgressPercent(10);
                window.addProgressLog('info', 'Validating state, loopback, and username');

                const state = document.getElementById('ent_feeding_outstate_state')?.value;
                const loopback = document.getElementById('ent_feeding_outstate_loopback')?.value.trim();
                const username = document.getElementById('ent_feeding_outstate_username')?.value.trim();

                if (!state) {
                    window.addProgressLog('error', 'State selection is required');
                    window.completeProgressTracker(false);
                    alert('Please select a state!');
                    return;
                }

                if (!loopback) {
                    window.addProgressLog('error', 'Router loopback is required');
                    window.completeProgressTracker(false);
                    alert('Please provide Router Loopback /32 (10.x)!');
                    return;
                }

                // Validate loopback format
                if (!loopback.includes('/')) {
                    window.addProgressLog('error', 'Invalid loopback format');
                    window.completeProgressTracker(false);
                    alert('Invalid loopback format. Please use CIDR format (e.g., 10.247.72.34/32)');
                    return;
                }

                // Extract IP from loopback (remove /32)
                const loopbackIP = loopback.split('/')[0].trim();

                if (!username) {
                    window.addProgressLog('error', 'Username/Customer Code is required');
                    window.completeProgressTracker(false);
                    alert('Please provide Username/Customer Code (e.g., NX-537853)!');
                    return;
                }

                window.addProgressLog('success', `State: ${state}, Loopback: ${loopbackIP}, Username: ${username}`);
                await new Promise(resolve => setTimeout(resolve, 200));

                window.updateProgressStep('Generating BNG configurations...');
                window.updateProgressPercent(30);
                window.addProgressLog('info', 'Building BNG configs for MT and Nokia');

                // State-specific BNG peer IPs (Loaded dynamically from /api/app-config)
                const bngPeers = window.APP_CONFIG?.bng_peers || {
                    'NE': '10.254.247.3', 'IL': '10.247.72.34', 'IA': '10.254.247.3', 'KS': '10.249.0.200', 'IN': '10.254.247.3'
                }; // Fallback defaults in case Global Config failed

                const bngPeer = bngPeers[state] || window.APP_CONFIG?.default_bng_peer || '10.254.247.3';

                // Determine tunnel type based on state (IL uses bgp-tunnel, others use ldp)
                const tunnelType = state === 'IL' ? 'bgp-tunnel' : 'ldp';

                window.updateProgressStep('Formatting BNG output...');
                window.updateProgressPercent(80);
                window.addProgressLog('info', 'Formatting MT and Nokia BNG configs');

                // Generate BNG configuration
                let config = `################################\n`;
                config += `###       BNG CONFIGS        ###\n`;
                config += `################################\n`;
                config += `# Copy and Paste these lines into the BNGs removing the leading # sign\n\n`;
                config += `# MT BNG\n`;
                config += `#/interface vpls add name=vpls2000-${username} disabled=no advertised-l2mtu=1580 cisco-style=yes cisco-style-id=2245 comment="VPLS2000-${username}"  remote-peer=${loopbackIP}\n`;
                config += `#/interface bridge port add bridge=bridge2000 interface=vpls2000-${username} horizon=1\n\n`;
                config += `# Nokia BNG\n`;
                config += `#show service sdp     ###Shows used SDP IDs###\n`;
                config += `#/configure service sdp <Next available SdpId> mpls create\n`;
                config += `#/configure service sdp <Next available SdpId> mpls description ${username}     ###Adds tower description###\n`;
                config += `#/configure service sdp <Next available SdpId> mpls far-end ${loopbackIP}           ###Tower Loop###\n`;
                config += `#/configure service sdp <Next available SdpId> mpls ${tunnelType}                          ###${tunnelType} for ${state === 'IL' ? 'CHICAGO' : 'OMAHA'}, bgp-tunnel for CHICAGO\n`;
                config += `#/configure service sdp <Next available SdpId> mpls keep-alive shutdown\n`;
                config += `#/configure service sdp <Next available SdpId> mpls no shutdown\n`;
                config += `#/configure service vpls 2245 mesh-sdp <next available>:2245 create restrict-protected-src discard-frame\n`;
                config += `#/configure service vpls 2245 mesh-sdp <next available>:2245 no shutdown\n`;

                window.updateProgressStep('Finalizing configuration...');
                window.updateProgressPercent(95);
                window.addProgressLog('success', 'BNG configuration generated successfully');

                await new Promise(resolve => setTimeout(resolve, 200));

                // Display configuration
                const output = document.getElementById('ent_feeding_outstate_output');
                const warnBox = document.getElementById('ent_feeding_outstate_warn');

                if (output) {
                    output.value = config;
                    output.style.opacity = '1';
                }

                if (warnBox) {
                    warnBox.innerHTML = '<div style="color: #4CAF50;"> BNG configuration generated successfully!</div>';
                }

                window.completeProgressTracker(true);

                // Track activity
                saveConfigToHistory({
                    type: 'enterprise-feeding-outstate-config',
                    device: 'BNG',
                    siteName: `Out-of-State ${state}: ${username}`,
                    routeros: 'N/A',
                    success: true
                });

            } catch (error) {
                window.addProgressLog('error', 'Configuration generation failed: ' + error.message);
                window.completeProgressTracker(false);
                alert('Error generating BNG configuration: ' + error.message);
                console.error('Enterprise Feeding Out-of-State generation error:', error);
            }
        }

        function copyEntFeedingOutState() {
            try {
                const output = document.getElementById('ent_feeding_outstate_output');
                if (!output) {
                    alert('No configuration output found!');
                    return;
                }

                const config = output.value;
                if (!config || config.trim() === '') {
                    alert('No configuration to copy! Please generate a configuration first.');
                    return;
                }

                // Use modern clipboard API with fallback
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(config).then(() => {
                        alert(' BNG configuration copied to clipboard!');
                    }).catch(() => {
                        // Fallback to compatibility method
                        output.select();
                        output.setSelectionRange(0, 99999); // For mobile
                        document.execCommand('copy');
                        alert(' BNG configuration copied to clipboard!');
                    });
                } else {
                    // Fallback for older browsers
                    output.select();
                    output.setSelectionRange(0, 99999); // For mobile
                    document.execCommand('copy');
                    alert(' BNG configuration copied to clipboard!');
                }
            } catch (error) {
                alert('Error copying configuration: ' + error.message);
                console.error('Copy error:', error);
            }
        }

        // Small helper to produce the Tarana block used in Tower generator
        function generateTowerTaranaBlock(opts, deviceConfig) {
            const alpha = opts.alpha || '';
            const beta = opts.beta || '';
            const gamma = opts.gamma || '';
            const delta = opts.delta || '';
            const unicornSubnet = opts.unicornSubnet || '';

            let out = '';

            // Bridges - Create UNICORNMGMT and bridge2000
            out += `/interface bridge\n`;
            out += `add comment=UNICORN name=UNICORNMGMT port-cost-mode=short\n`;
            out += `add comment=STATIC name=bridge2000 port-cost-mode=short\n`;

            // Ethernet sets (force 10G-baseCR)
            function emitEthSet(port, comment, speedInputId, mtuInputId) {
                if (!port) return '';
                const speedVal = '10G-baseCR';
                const mtuVal = '';
                const autoNeg = ' auto-negotiation=no';
                const speedPart = ` speed=${speedVal}`;
                return `/interface ethernet\nset [ find default-name=${port} ]${autoNeg} comment=${comment}${speedPart}${mtuVal}\n`;
            }

            if (alpha) out += emitEthSet(alpha, 'ALPHA', 'tower_tarana_alpha_speed', 'tower_tarana_alpha_mtu');
            if (beta) out += emitEthSet(beta, 'BETA', 'tower_tarana_beta_speed', 'tower_tarana_beta_mtu');
            if (gamma) out += emitEthSet(gamma, 'GAMMA', 'tower_tarana_gamma_speed', 'tower_tarana_gamma_mtu');
            if (delta) out += emitEthSet(delta, 'DELTA', 'tower_tarana_delta_speed', 'tower_tarana_delta_mtu');

            // VLANs on each sector port
            const sectorPorts = [alpha, beta, gamma].concat(delta ? [delta] : []);
            if (sectorPorts.length) {
                out += `/interface vlan\n`;
                sectorPorts.forEach(p => {
                    out += `add interface=${p} name=vlan1000-${p} vlan-id=1000\n`;
                    out += `add interface=${p} name=vlan2000-${p} vlan-id=2000\n`;
                    out += `add interface=${p} name=vlan3000-${p} vlan-id=3000\n`;
                });
            }

            // Bridge port assignments
            out += `/interface bridge port\n`;
            sectorPorts.forEach(p => {
                out += `add bridge=lan-bridge interface=vlan1000-${p}\n`;
                out += `add bridge=bridge2000 interface=vlan2000-${p}\n`;
                out += `add bridge=UNICORNMGMT interface=vlan3000-${p}\n`;
            });

            // UNICORN management
            if (unicornSubnet) {
                let network = unicornSubnet;
                try {
                    if (typeof calculateNetworkAddress === 'function') {
                        network = calculateNetworkAddress(unicornSubnet);
                    } else if (typeof calculateNetwork === 'function') {
                        const base = calculateNetwork(unicornSubnet);
                        network = base + '/' + (unicornSubnet.split('/')[1] || '32');
                    }
                } catch (e) { }

                let firstUsable = unicornSubnet;
                try {
                    const parsed = parseCidr(unicornSubnet);
                    const netInt = ipToInt(parsed.ip) & parsed.mask;
                    const usableInt = netInt + 1;
                    firstUsable = intToIp(usableInt) + '/' + parsed.prefix;
                } catch (e) { }

                out += `/ip address\n`;
                out += `add address=${firstUsable} interface=UNICORNMGMT comment=UNICORN network=${calculateNetwork(unicornSubnet)}\n`;
                out += `/routing ospf interface-template\n`;
                out += `add area=backbone-v2 disabled=no interfaces=UNICORNMGMT networks=${calculateNetwork(unicornSubnet)} priority=1\n`;
            }

            return out;
        }

        // ========================================
        // ========================================
        // MODE SWITCHING & FILE HANDLING
        // ========================================

        // ========================================
        // DYNAMIC APPLICATION CONFIGURATION
        // ========================================
        // Default configuration (fallback)
        window.APP_CONFIG = {
            bng_peers: {
                'NE': '10.254.247.3',
                'IL': '10.247.72.34',
                'IA': '10.254.247.3',
                'KS': '10.249.0.200',
                'IN': '10.254.247.3'
            },
            default_bng_peer: '10.254.247.3'
        };

        // Fetch dynamic config from backend
        (async function fetchAppConfig() {
            try {
                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                const response = await fetch(`${apiBase}/app-config`);
                if (response.ok) {
                    const config = await response.json();
                    window.APP_CONFIG = { ...window.APP_CONFIG, ...config };
                    console.log('[CONFIG] Loaded dynamic app config:', window.APP_CONFIG);
                    if (config.ftth_template_hash) {
                        console.log('[FTTH] Template hash:', config.ftth_template_hash);
                    }
                }
            } catch (e) {
                console.warn('[CONFIG] Failed to load app config, using defaults:', e);
            }
        })();

        // Note: AI_API_BASE is now defined at the top of the script block
        let uploadedConfigContent = '';

        // Switch between NEW and UPGRADE modes
        function switchMode(mode) {
            const mainForm = document.getElementById('mainForm');
            const upgradeMode = document.getElementById('upgradeMode');
            const newModeHint = document.getElementById('newModeHint');
            const generateBtn = document.getElementById('generateBtn');

            if (mode === 'new') {
                mainForm.style.display = 'block';
                upgradeMode.style.display = 'none';
                newModeHint.style.display = 'block';
                if (generateBtn) generateBtn.textContent = 'Generate Configuration';
            } else {
                mainForm.style.display = 'none';
                upgradeMode.style.display = 'block';
                newModeHint.style.display = 'none';
                uploadedConfigContent = '';
                document.getElementById('uploadedFileName').style.display = 'none';
                document.getElementById('upgradeTargetSelection').style.display = 'none';
                if (generateBtn) generateBtn.textContent = 'Upgrade Configuration';
            }

            // If a progress tracker is active, keep it scoped to the visible mode.
            if (typeof window.repositionProgressTracker === 'function') {
                window.repositionProgressTracker();
            }
        }

        // Drag & Drop File Handling
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');

        if (dropZone) {
            // Prevent default drag behaviors
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });

            // Highlight drop zone when item is dragged over it
            ['dragenter', 'dragover'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.borderColor = '#FF9800';
                    dropZone.style.background = '#fff3e0';
                }, false);
            });

            ['dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, () => {
                    dropZone.style.borderColor = '#ccc';
                    dropZone.style.background = 'white';
                }, false);
            });

            // Handle dropped files
            dropZone.addEventListener('drop', handleDrop, false);
            dropZone.addEventListener('click', () => fileInput.click());
        }

        if (fileInput) {
            fileInput.addEventListener('change', handleFileSelect, false);
        }

        function preventDefaults(e) {
            e.preventDefault();
            e.stopPropagation();
        }

        function handleDrop(e) {
            const dt = e.dataTransfer;
            const files = dt.files;
            handleFiles(files);
        }

        // Toggle between file upload and SSH fetch methods
        function toggleUpgradeMethod() {
            const method = document.querySelector('input[name="upgradeMethod"]:checked')?.value || 'ssh';
            const fileMethod = document.getElementById('fileUploadMethod');
            const sshMethod = document.getElementById('sshFetchMethod');

            if (method === 'file') {
                fileMethod.style.display = 'block';
                sshMethod.style.display = 'none';
                // Clear SSH status
                document.getElementById('sshStatus').style.display = 'none';
                uploadedConfigContent = null;
                document.getElementById('uploadedFileName').style.display = 'none';
                document.getElementById('upgradeTargetSelection').style.display = 'none';
            } else {
                fileMethod.style.display = 'none';
                sshMethod.style.display = 'block';
                // Clear file upload status
                uploadedConfigContent = null;
                document.getElementById('uploadedFileName').style.display = 'none';
                document.getElementById('upgradeTargetSelection').style.display = 'none';
            }
        }

        // Update export command options based on RouterOS version
        function updateSSHExportCommand() {
            const rosVersion = document.getElementById('sshRouterOSVersion')?.value;
            const exportSelect = document.getElementById('sshExportCommand');

            if (!exportSelect || !rosVersion) return;

            exportSelect.innerHTML = '';
            if (rosVersion === '7') {
                exportSelect.innerHTML = '<option value="export">export (default)</option><option value="export show-sensitive">export show-sensitive (includes passwords)</option>';
            } else {
                exportSelect.innerHTML = '<option value="export">export (default)</option><option value="export hide-sensitive">export hide-sensitive (excludes passwords)</option>';
            }
        }

        // Alias for consistency
        window.updateSSHExportCommand = updateSSHExportCommand;

        // Normalize line breaks (remove RouterOS \ continuation characters) with token-safe joining
        function normalizeLineBreaks(text) {
            if (!text) return text;

            const lines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
            const normalized = [];
            let i = 0;
            let inQuote = false;

            const tokenChars = new Set('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789._-'.split(''));

            function toggleInQuote(prev, segment) {
                let inQ = prev;
                let escape = false;
                for (const ch of segment) {
                    if (escape) {
                        escape = false;
                        continue;
                    }
                    if (ch === '\\') {
                        escape = true;
                        continue;
                    }
                    if (ch === '"') {
                        inQ = !inQ;
                    }
                }
                return inQ;
            }

            function joinContinuation(left, right, inQ) {
                const r = (right || '').replace(/^\s+/, '');
                if (!left) return r;
                if (!r) return left;

                const last = left[left.length - 1];
                const first = r[0];

                if (inQ) return left + r;
                if (/\s/.test(last)) return left + r;
                if (tokenChars.has(last) && tokenChars.has(first)) return left + r;
                if (',.;:)]}'.includes(first)) return left + r;
                if (last === '=') return left + r;
                return left + ' ' + r;
            }

            while (i < lines.length) {
                let line = lines[i];
                while (line.endsWith('\\') && i + 1 < lines.length) {
                    const prefix = line.slice(0, -1);
                    const nextLine = lines[i + 1] || '';
                    line = joinContinuation(prefix, nextLine, inQuote);
                    i += 1;
                }
                normalized.push(line.replace(/\s+$/, ''));
                inQuote = toggleInQuote(inQuote, line);
                i += 1;
            }

            return normalized.join('\n');
        }

        function formatRouterOSConfigForOutput(text) {
            let t = normalizeLineBreaks(text || '');
            t = t
                // Fix common RouterOS export token wrapping (usually inside quoted rules).
                .replace(/\bdst-le\s+n\b/g, 'dst-len')
                .replace(/\bblackh\s+ole\b/g, 'blackhole')
                .replace(/\bbgp-communit\s+ies\b/g, 'bgp-communities')
                .replace(/\bbgp-local-\s+pref\b/g, 'bgp-local-pref');

            const out = [];
            const seen = new Set();

            function fixOutsideQuotes(line) {
                // Best-effort: normalize spacing outside quoted strings without touching quoted content.
                const parts = String(line).split('"');
                for (let i = 0; i < parts.length; i += 2) {
                    parts[i] = parts[i]
                        .replace(/(^|\s)([A-Za-z0-9_.-]+)=\s+/g, '$1$2=')
                        .replace(/\s+/g, ' ')
                        .trim();
                }
                return parts.join('"');
            }

            for (const raw of t.replace(/\r/g, '').split('\n')) {
                const line = String(raw || '').replace(/\s+$/, '');
                if (!line.trim()) {
                    if (out.length && out[out.length - 1] !== '') out.push('');
                    continue;
                }

                // Remove RouterOS visual separators that shouldn't be applied as config.
                if (/\bchain=break\b/i.test(line)) continue;
                if (/\bBREAK\b/i.test(line) && /-{5,}/.test(line)) continue;

                let fixed = fixOutsideQuotes(line);

                // Fix broken /user group policy quote wrapping, e.g. "sensitiv e" -> "sensitive"
                if (/^\s*(set\s+read\s+policy=|add\s+name=\S+\s+policy=)/i.test(fixed) && fixed.includes('policy="')) {
                    fixed = fixed.replace(/policy="([^"]*)"/gi, (_, p1) => `policy="${String(p1).replace(/\s+/g, '')}"`);
                }

                // Drop exact duplicate lines (common after merges), but never touch embedded script sources.
                const isHeader = fixed.startsWith('/');
                const containsScriptSource = /\bsource\s*=\s*"/i.test(fixed);
                if (!isHeader && !containsScriptSource) {
                    const key = fixed.trim();
                    if (seen.has(key)) continue;
                    seen.add(key);
                }

                if (fixed.startsWith('/') && out.length && out[out.length - 1] !== '') out.push('');
                out.push(fixed);
            }

            while (out.length && out[out.length - 1] === '') out.pop();
            return out.join('\n') + '\n';
        }

        function parseSshPorts(raw) {
            const defaultPorts = [22, 5022];
            const text = (raw || '').trim();
            if (!text) return defaultPorts;

            const ports = [];
            for (const token of text.split(/[\s,]+/)) {
                const t = token.trim();
                if (!t) continue;
                const p = Number.parseInt(t, 10);
                if (!Number.isFinite(p) || p < 1 || p > 65535) continue;
                if (!ports.includes(p)) ports.push(p);
            }

            // Always include defaults as fallback, but keep user order first.
            for (const p of defaultPorts) {
                if (!ports.includes(p)) ports.push(p);
            }

            return ports;
        }

        // Fetch config via SSH with live progress tracking
        async function fetchConfigViaSSH() {
            const deviceIP = document.getElementById('sshDeviceIP').value.trim();
            const rosVersion = document.getElementById('sshRouterOSVersion').value;
            const exportCommand = document.getElementById('sshExportCommand').value;
            const sshUsername = document.getElementById('sshUsername')?.value?.trim();
            const sshPassword = document.getElementById('sshPassword')?.value || '';
            const sshPorts = parseSshPorts(document.getElementById('sshPorts')?.value || '');
            const sshStatus = document.getElementById('sshStatus');
            const sshFetchBtn = document.getElementById('sshFetchBtn');

            // Validation
            if (!deviceIP) {
                showUpgradeStatus('Please enter device IP address.', 'error');
                return;
            }

            // Basic IP validation
            const ipPattern = /^(\d{1,3}\.){3}\d{1,3}$/;
            if (!ipPattern.test(deviceIP)) {
                showUpgradeStatus('Invalid IP address format.', 'error');
                return;
            }

            if (!sshUsername || !sshPassword) {
                showUpgradeStatus('Enter SSH username and password.', 'error');
                return;
            }

            // Show MUSHU-style progress tracker
            showProgressTracker('SSH Config Fetch');
            updateProgressStep('Connecting to device...');
            updateProgressPercent(5);
            addProgressLog('info', `Connecting to ${deviceIP} via SSH`);

            // Disable button and show loading
            sshFetchBtn.disabled = true;
            sshFetchBtn.style.opacity = '0.6';
            sshFetchBtn.style.cursor = 'not-allowed';
            sshFetchBtn.innerHTML = ' Connecting...';

            sshStatus.style.display = 'block';
            sshStatus.style.background = '#2196F3';
            sshStatus.style.color = 'white';
            sshStatus.innerHTML = ' Connecting to device...';

            try {
                updateProgressPercent(20);
                updateProgressStep('Establishing SSH connection...');
                addProgressLog('info', `Trying ports: ${sshPorts.join(', ')}`);

                const response = await fetch(`${AI_API_BASE}/fetch-config-ssh`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        host: deviceIP,
                        ros_version: rosVersion,
                        command: exportCommand,
                        username: sshUsername,
                        password: sshPassword,
                        ports: sshPorts
                    })
                });

                updateProgressPercent(60);
                updateProgressStep('Processing configuration...');
                addProgressLog('info', 'Normalizing line breaks and formatting');

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                    throw new Error(errorData.error || `HTTP ${response.status}`);
                }

                const data = await response.json();

                if (!data.config || !data.config.trim()) {
                    throw new Error('Device returned empty configuration');
                }

                // Normalize line breaks (remove \ continuations)
                const normalizedConfig = normalizeLineBreaks(data.config);

                updateProgressPercent(80);
                updateProgressStep('Finalizing...');
                addProgressLog('success', `Config normalized: ${normalizedConfig.length} characters`);

                // Store config content (same as file upload)
                uploadedConfigContent = normalizedConfig;

                updateProgressPercent(100);
                updateProgressStep('Config fetched successfully!');
                addProgressLog('success', `Ready for upgrade: ${deviceIP}`);
                completeProgressTracker(true);

                // Show success with port info
                const portInfo = data.port ? ` (port ${data.port})` : '';
                sshStatus.style.background = '#4CAF50';
                sshStatus.innerHTML = ` Config fetched successfully from ${deviceIP}${portInfo}<br><small>Config size: ${normalizedConfig.length} characters</small>`;

                // Show file name (using device IP as identifier)
                document.getElementById('fileName').textContent = `SSH-${deviceIP}-export.rsc`;
                document.getElementById('uploadedFileName').style.display = 'block';

                // Show target selection
                document.getElementById('upgradeTargetSelection').style.display = 'block';

                // Show ready message
                showUpgradeStatus(' Config loaded. Select target device/version and click "Start Upgrade" button.', 'success');

            } catch (error) {
                completeProgressTracker(false);
                sshStatus.style.background = '#f44336';
                sshStatus.innerHTML = ` Error: ${error.message}`;
                showUpgradeStatus(`SSH fetch failed: ${error.message}`, 'error');
                addProgressLog('error', `SSH fetch failed: ${error.message}`);
            } finally {
                // Re-enable button
                sshFetchBtn.disabled = false;
                sshFetchBtn.style.opacity = '1';
                sshFetchBtn.style.cursor = 'pointer';
                sshFetchBtn.innerHTML = ' Fetch Config via SSH';
            }
        }

        function handleFileSelect(e) {
            const files = e.target.files;
            handleFiles(files);
        }

        function handleFiles(files) {
            if (files.length === 0) return;

            const file = files[0];
            const fileName = file.name;

            // Check file extension
            if (!fileName.endsWith('.rsc') && !fileName.endsWith('.txt')) {
                showUpgradeStatus('Invalid file type. Please upload .rsc or .txt file.', 'error');
                return;
            }

            // Read file content
            const reader = new FileReader();
            reader.onload = function (e) {
                // Normalize line breaks (remove RouterOS \ continuation characters)
                const rawContent = e.target.result;
                const normalizedContent = normalizeLineBreaks(rawContent);

                uploadedConfigContent = normalizedContent;

                // Show file name
                document.getElementById('fileName').textContent = fileName;
                document.getElementById('uploadedFileName').style.display = 'block';

                // Show target selection
                document.getElementById('upgradeTargetSelection').style.display = 'block';

                // Show ready message
                showUpgradeStatus(' Config loaded. Select target device/version and click "Start Upgrade" button.', 'success');
            };
            reader.readAsText(file);
        }

        // Perform upgrade using AI backend
        async function performUpgrade() {
            if (!uploadedConfigContent) {
                showUpgradeStatus('No config file loaded.', 'error');
                return;
            }

            // Show MUSHU-style progress tracker
            showProgressTracker('Configuration Migration/Upgrade');
            updateProgressStep('Initializing upgrade process...');
            updateProgressPercent(2);
            addProgressLog('info', 'Migration started');

            // Disable button during processing
            const upgradeBtn = document.getElementById('upgradeBtn');
            upgradeBtn.disabled = true;
            upgradeBtn.style.opacity = '0.6';
            upgradeBtn.style.cursor = 'not-allowed';
            upgradeBtn.innerHTML = ' Upgrading...';

            // Initialize progress bar
            updateUpgradeProgress(5, 'Initializing translation...');
            showUpgradeStatus('Detecting source version and translating...', 'info');

            // Slight delay to show initialization
            await new Promise(resolve => setTimeout(resolve, 500));

            try {
                // Extract source device (prefer export header model, then identity MT#### token, then filename).
                const uploadedFileName = document.getElementById('fileName')?.textContent || '';
                let sourceDevice = 'unknown';

                function normalizeDeviceKey(raw) {
                    const t = String(raw || '').toLowerCase();
                    const m = t.match(/\b(ccr|crs|rb)\s*([0-9]{3,4})\b/);
                    if (m) return `${m[1]}${m[2]}`;
                    const mt = t.match(/\bmt([0-9]{3,4})\b/);
                    if (mt) return `ccr${mt[1]}`;
                    const simple = t.match(/\b(hap|cap|hex)\b/);
                    if (simple) return simple[1];
                    return 'unknown';
                }

                const modelMatch = uploadedConfigContent.match(/^\s*#\s*model\s*=\s*([^\s#]+)\s*$/mi);
                if (modelMatch) {
                    sourceDevice = normalizeDeviceKey(modelMatch[1]);
                }

                if (sourceDevice === 'unknown') {
                    const idMatch = uploadedConfigContent.match(/\/system identity[\s\S]*?\bset\s+name=([^\n]+)/i);
                    if (idMatch) {
                        sourceDevice = normalizeDeviceKey(idMatch[1]);
                    }
                }

                if (sourceDevice === 'unknown' && uploadedFileName) {
                    sourceDevice = normalizeDeviceKey(uploadedFileName);
                }

                // Detect source version - multiple patterns
                let sourceVersion = 'unknown';
                const patterns = [
                    /by RouterOS\s+([\d.]+)/,
                    /RouterOS\s+([\d.]+)/,
                    /version\s+([\d.]+)/,
                    /ros7/i,
                    /interface-template/,
                    /default-v2/
                ];

                for (const pattern of patterns) {
                    const match = uploadedConfigContent.match(pattern);
                    if (match) {
                        if (pattern.source.includes('ros7') || pattern.source.includes('interface-template') || pattern.source.includes('default-v2')) {
                            sourceVersion = '7.x';
                        } else {
                            sourceVersion = match[1] || '7.x';
                        }
                        break;
                    }
                }

                // Get target selections
                const targetDevice = document.getElementById('upgradeTargetDevice').value;
                const targetVersion = document.getElementById('upgradeTargetVersion').value;

                updateProgressPercent(10);
                updateProgressStep(`Detected source RouterOS ${sourceVersion}`);
                addProgressLog('success', `Detected RouterOS version: ${sourceVersion}`);
                await new Promise(resolve => setTimeout(resolve, 300));

                updateProgressPercent(15);
                updateProgressStep(`Target: ${targetDevice} (RouterOS ${targetVersion})`);
                addProgressLog('info', `Upgrading to: ${targetDevice} (RouterOS ${targetVersion})`);
                updateUpgradeProgress(15, `Detected RouterOS ${sourceVersion}  ${targetVersion}`);
                showUpgradeStatus(`Upgrading from RouterOS ${sourceVersion} to ${targetVersion} (${targetDevice})... This may take 1-3 minutes for large configs.`, 'info');
                await new Promise(resolve => setTimeout(resolve, 300));

                // Check backend
                updateProgressPercent(20);
                updateProgressStep('Checking backend service availability...');
                addProgressLog('info', 'Verifying unified backend service (api_server.py)');
                updateUpgradeProgress(20, 'Checking backend service...');
                const backendRunning = await checkAIBackend();
                if (!backendRunning) {
                    // Check if backend was previously online (cached status)
                    if (window.BACKEND_ONLINE === true) {
                        console.warn('[UPGRADE] Backend health check failed but was previously online, continuing anyway...');
                        addProgressLog('warning', 'Backend health check had issues, but continuing with upgrade...');
                    } else {
                        addProgressLog('error', 'Backend service (api_server.py) appears offline after multiple retry attempts');
                        completeProgressTracker(false);
                        showUpgradeStatus(' Unable to reach backend (api_server.py) after multiple attempts. Please verify the service is running on the VM.', 'error');

                        // Re-enable button
                        upgradeBtn.disabled = false;
                        upgradeBtn.style.opacity = '1';
                        upgradeBtn.style.cursor = 'pointer';
                        upgradeBtn.innerHTML = ' Start Upgrade';
                        upgradeBtn.style.cursor = 'pointer';
                        upgradeBtn.style.background = '#FF9800';
                        return;
                    }
                }

                addProgressLog('success', 'Unified backend service (api_server.py) online and ready');

                // Create timeout controller for large configs (15 minutes max)
                const controller = new AbortController();
                const timeoutId = setTimeout(() => controller.abort(), 900000); // 15 minutes

                try {
                    // Call backend
                    updateProgressPercent(30);
                    updateProgressStep('Sending configuration to AI translator...');
                    addProgressLog('info', `Config size: ${uploadedConfigContent.length} characters`);
                    addProgressLog('info', 'Calling AI backend for intelligent translation');
                    updateUpgradeProgress(30, 'Sending config to AI translator...');
                    await new Promise(resolve => setTimeout(resolve, 500));

                    // Simulate progress during AI translation (30%  70%) - slower updates
                    let currentPercent = 35;
                    const progressInterval = setInterval(() => {
                        if (currentPercent < 70) {
                            currentPercent += 3;
                            updateProgressPercent(currentPercent);
                            updateProgressStep('AI analyzing and translating configuration...');
                            updateUpgradeProgress(currentPercent, 'AI translating configuration...');
                            if (currentPercent % 15 === 0) {
                                addProgressLog('info', `Translation progress: ${currentPercent}%`);
                            }
                        }
                    }, 1500);  // Update every 1.5 seconds (slower, more visible)

                    const response = await fetch(`${AI_API_BASE}/translate-config`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            source_config: uploadedConfigContent,
                            target_device: targetDevice,
                            target_version: targetVersion,
                            strict_preserve: true,
                            apply_compliance: false
                        }),
                        signal: controller.signal
                    });

                    clearInterval(progressInterval);  // Stop simulated progress
                    updateProgressPercent(75);
                    updateProgressStep('Translation received from AI, validating...');
                    addProgressLog('success', 'AI translation completed');
                    updateUpgradeProgress(75, 'Translation received, validating...');
                    clearTimeout(timeoutId);
                    await new Promise(resolve => setTimeout(resolve, 400));

                    if (!response.ok) {
                        const error = await response.json();
                        addProgressLog('error', 'Backend returned error: ' + (error.error || 'Unknown'));
                        throw new Error(error.error || 'Backend returned error');
                    }
                    const data = await response.json();

                    if (data.success) {
                        updateProgressPercent(85);
                        updateProgressStep('Validating translation quality...');
                        addProgressLog('info', 'Running post-translation validation');
                        updateUpgradeProgress(85, 'Validating translation quality...');
                        await new Promise(resolve => setTimeout(resolve, 500));

                        // Check validation FIRST - missing IPs = FAILURE
                        const validation = data.validation || {};
                        const missingIPs = validation.missing_ips || [];

                        if (missingIPs.length > 0) {
                            addProgressLog('warning', `Detected ${missingIPs.length} missing IP addresses`);
                            missingIPs.slice(0, 5).forEach(ip => {
                                addProgressLog('warning', `Missing IP: ${ip}`);
                            });
                        } else {
                            addProgressLog('success', 'All IP addresses preserved');
                        }

                        updateProgressPercent(95);
                        updateProgressStep('Validation complete, finalizing output...');
                        updateUpgradeProgress(95, 'Validation complete, finalizing...');
                        await new Promise(resolve => setTimeout(resolve, 300));

                        updateProgressPercent(100);

                        if (missingIPs.length > 10) {
                            // Too many missing IPs = translation failed catastrophically
                            addProgressLog('error', `CRITICAL: ${missingIPs.length} IP addresses lost!`);
                            completeProgressTracker(false);
                            hideUpgradeProgress();
                            throw new Error(`CRITICAL FAILURE: ${missingIPs.length} IP addresses lost in translation. AI failed to preserve network config. This is unusable.`);
                        } else if (missingIPs.length > 0) {
                            // Some missing IPs = partial success (warning)
                            updateProgressStep(` Warning: ${missingIPs.length} IPs missing - review required`);
                            addProgressLog('warning', `Translation completed with ${missingIPs.length} missing IPs`);
                            updateUpgradeProgress(100, ` Warning: ${missingIPs.length} IPs missing!`);
                            showUpgradeStatus(` WARNING: ${missingIPs.length} IPs missing. Review carefully before deploying!`, 'warning');
                            // Still counts as success but with warnings
                        } else {
                            // Perfect translation
                            updateProgressStep('Migration completed successfully!');
                            addProgressLog('success', 'All IP addresses preserved successfully');
                            updateUpgradeProgress(100, ' Translation complete!');
                            showUpgradeStatus(` Translation successful! All IPs preserved.`, 'success');
                        }

                        // Apply final UI-side speed syntax fix based on target RouterOS
                        let finalTranslatedConfig = data.translated_config || '';
                        try {
                            const versionType = getRouterOSVersionType(targetVersion);
                            if (versionType === 'new') {
                                // Ensure we are using new speed format for 7.16.2+ (defensive, even if backend already converted)
                                finalTranslatedConfig = finalTranslatedConfig.replace(/speed=1Gbps\b/g, 'speed=1G-baseT-full');
                                finalTranslatedConfig = finalTranslatedConfig.replace(/speed=10Gbps\b/g, 'speed=10G-baseSR-LR');
                            }
                        } catch (e) {
                            console.warn('Speed syntax post-fix failed:', e);
                        }

                        // Final display/clipboard formatting (no semantic changes)
                        finalTranslatedConfig = formatRouterOSConfigForOutput(finalTranslatedConfig);

                        // Display upgraded config in NEW dedicated section
                        document.getElementById('upgradeOutput').value = finalTranslatedConfig;
                        document.getElementById('upgradeOutputSection').style.display = 'block';

                        // Also put in main output for compatibility
                        document.getElementById('output').value = finalTranslatedConfig;

                        // Extract site name from the TRANSLATED config identity (must reflect target device)
                        let siteName = 'Unknown Site';
                        const identityMatch = finalTranslatedConfig.match(/\/system identity[\s\S]*?\n\s*set\s+name=("[^"]+"|[^\s\r\n]+)/i);
                        if (identityMatch) {
                            siteName = identityMatch[1].replace(/^["']|["']$/g, '').trim();
                        } else if (data.target_info?.model || data.target_info?.type) {
                            // Build deterministic fallback identity based on target model/type
                            const tgtModel = (data.target_info.model || data.target_info.type || '').toUpperCase();
                            const digitsMatch = tgtModel.match(/(\d{3,4})/);
                            const digits = digitsMatch ? digitsMatch[1] : null;
                            const modelShort = (tgtModel.split('-')[0] || tgtModel).replace(/[^A-Z0-9]/g, '');
                            if (modelShort.startsWith('MT') || /MT\d{3,4}/.test(tgtModel)) {
                                siteName = `RTR-MT${digits || 'UNKNOWN'}-AUTO`;
                            } else {
                                siteName = `RTR-${modelShort}${digits ? `-${digits}` : '-UNKNOWN'}`;
                            }
                        }

                        // Track migration in history
                        const migrationSuccess = missingIPs.length === 0;
                        saveConfigToHistory({
                            type: 'migration',
                            device: `${sourceDevice} -> ${targetDevice}`,
                            siteName: siteName,
                            routeros: `${sourceVersion} -> ${targetVersion}`,
                            success: migrationSuccess
                        });

                        // Bind copy/download buttons (once)
                        const copyBtn = document.getElementById('upgradeCopyBtn');
                        const dlBtn = document.getElementById('upgradeDownloadBtn');
                        // Safe bindings: fall back to inline implementations if globals are not yet defined
                        if (copyBtn && !copyBtn.dataset.bound) {
                            const copyHandler = (window.copyUpgradeOutput) ? window.copyUpgradeOutput : function () {
                                const ta = document.getElementById('upgradeOutput');
                                const text = ta ? ta.value : '';
                                if (!text) { alert('No configuration to copy!'); return; }
                                if (navigator.clipboard && window.isSecureContext) {
                                    navigator.clipboard.writeText(text).then(() => alert(' Configuration copied to clipboard')).catch(() => {
                                        ta.select(); document.execCommand('copy'); alert('Copied to clipboard.');
                                    });
                                } else {
                                    ta.select(); document.execCommand('copy'); alert('Copied to clipboard.');
                                }
                            };
                            copyBtn.addEventListener('click', copyHandler);
                            copyBtn.dataset.bound = '1';
                        }
                        if (dlBtn && !dlBtn.dataset.bound) {
                            const dlHandler = (window.downloadUpgradeOutput) ? window.downloadUpgradeOutput : function () {
                                const ta = document.getElementById('upgradeOutput');
                                const config = ta ? ta.value : '';
                                if (!config) { alert('No configuration to download!'); return; }
                                const targetDevice = (document.getElementById('upgradeTargetDevice') || {}).value || 'device';
                                const targetVersion = (document.getElementById('upgradeTargetVersion') || {}).value || '7.x';
                                const ts = new Date().toISOString().split('T')[0];
                                const blob = new Blob([config.replace(/\r?\n/g, '\n')], { type: 'text/plain;charset=utf-8' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `upgraded-${targetDevice}-v${targetVersion}-${ts}.rsc`;
                                document.body.appendChild(a);
                                a.click();
                                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 0);
                            };
                            dlBtn.addEventListener('click', dlHandler);
                            dlBtn.dataset.bound = '1';
                        }

                        // Re-enable button
                        upgradeBtn.disabled = false;
                        upgradeBtn.style.opacity = '1';
                        upgradeBtn.style.cursor = 'pointer';
                        upgradeBtn.innerHTML = ' Upgrade Complete - Run Again?';
                        upgradeBtn.style.background = '#4CAF50';

                        // Auto-save completed config after successful translation
                        if (typeof saveCompletedConfig === 'function') {
                            const extractSystemIdentity = (cfg) => {
                                const text = cfg || '';
                                const m = text.match(/\/system identity[\s\S]*?\n\s*set\s+name=("[^"]+"|[^\s\r\n]+)/i);
                                if (!m) return '';
                                return String(m[1] || '').trim().replace(/^"|"$/g, '');
                            };
                            const extractLoopback = (cfg) => {
                                const text = cfg || '';
                                const m = text.match(/^\s*add\s+address=([0-9.]+)(?:\/[0-9]+)?[^\n]*\binterface=loop0\b/m);
                                return m ? m[1] : '';
                            };

                            const identityName = extractSystemIdentity(finalTranslatedConfig);
                            const loopbackIp = extractLoopback(finalTranslatedConfig);
                            const deviceName = identityName || (loopbackIp ? `RTR-${targetDevice}-${loopbackIp}` : `migrated-${targetDevice}`);

                            const configData = {
                                config_type: 'migration',
                                device_name: deviceName,
                                device_type: targetDevice,
                                customer_code: '',
                                loopback_ip: loopbackIp,
                                routeros_version: targetVersion,
                                config_content: finalTranslatedConfig,
                                site_name: '',
                                router_id: loopbackIp,
                                lan_bridge_ip: '',
                                ospf_area: '',
                                bgp_peers: [],
                                uplinks: [],
                                created_by: 'user'
                            };

                            // Add migration metadata to the metadata object (will be JSON stringified by backend)
                            configData.metadata = {
                                source_device: sourceDevice || 'unknown',
                                target_device: targetDevice,
                                source_version: sourceVersion || (data.source_info?.version) || 'unknown',
                                target_version: targetVersion,
                                migration_timestamp: getCSTTimestamp(),
                                validation: data.validation || {},
                                compliance: data.compliance || {}
                            };

                            saveCompletedConfig(configData);
                            console.log('[TRANSLATE] Auto-saving migrated config to completed configs');
                        } else {
                            console.warn('[TRANSLATE] saveCompletedConfig function not available');
                        }

                        // Scroll to output
                        document.getElementById('upgradeOutputSection').scrollIntoView({ behavior: 'smooth' });
                    } else {
                        throw new Error(data.error || 'Translation failed');
                    }
                } catch (fetchError) {
                    clearTimeout(timeoutId);
                    if (fetchError.name === 'AbortError') {
                        throw new Error('Request took too long (>5 minutes). Config may be too large or system is slow.');
                    }
                    throw fetchError;
                }

            } catch (error) {
                hideUpgradeProgress();  // Hide progress bar on error
                showUpgradeStatus(` Upgrade failed: ${error.message}. Check that backend is running with enough resources.`, 'error');

                // Re-enable button (error)
                upgradeBtn.disabled = false;
                upgradeBtn.style.opacity = '1';
                upgradeBtn.style.cursor = 'pointer';
                upgradeBtn.innerHTML = ' Start Upgrade';
                upgradeBtn.style.background = '#FF9800';
            }
        }

        function updateUpgradeProgress(percent, label) {
            const container = document.getElementById('upgradeProgressContainer');
            const bar = document.getElementById('upgradeProgressBar');
            const labelDiv = document.getElementById('upgradeProgressLabel');

            container.style.display = 'block';
            bar.style.width = percent + '%';
            bar.textContent = percent + '%';
            labelDiv.textContent = label;

            // Change color based on progress
            if (percent < 30) {
                bar.style.background = 'linear-gradient(90deg, #FF9800, #FFC107)';
            } else if (percent < 70) {
                bar.style.background = 'linear-gradient(90deg, #2196F3, #03A9F4)';
            } else {
                bar.style.background = 'linear-gradient(90deg, #4CAF50, #8BC34A)';
            }
        }

        function hideUpgradeProgress() {
            document.getElementById('upgradeProgressContainer').style.display = 'none';
        }

        function showUpgradeStatus(message, type) {
            const statusDiv = document.getElementById('upgradeStatus');
            statusDiv.style.display = 'block';
            statusDiv.textContent = message;

            const colors = {
                success: '#d4edda',
                error: '#f8d7da',
                warning: '#fff3cd',
                info: '#d1ecf1'
            };

            const textColors = {
                success: '#155724',
                error: '#721c24',
                warning: '#856404',
                info: '#0c5460'
            };

            statusDiv.style.background = colors[type] || colors.info;
            statusDiv.style.color = textColors[type] || textColors.info;
            statusDiv.style.border = `1px solid ${textColors[type]}`;
        }


        // Check if backend is running - unified through api_server.py
        // api_server.py handles all AI internally (Ollama/OpenAI), so we just check if the main backend is online
        async function checkAIBackend() {
            // Use the same robust health check as the main backend check
            // api_server.py is the unified backend that handles everything
            for (let attempt = 1; attempt <= 3; attempt++) {
                try {
                    const response = await robustFetch(`${AI_API_BASE}/health`, {
                        method: 'GET'
                    }, 2, 2000); // 2 retries per attempt, 2 second delay

                    if (response.ok) {
                        const data = await response.json();

                        // If api_server.py is online, it's ready - it handles AI internally
                        // Don't fail if Ollama isn't available - api_server.py will handle fallbacks
                        if (data.status === 'online') {
                            console.log('[BACKEND]  Unified backend (api_server.py) is online and ready');
                            // Store backend status globally
                            window.BACKEND_ONLINE = true;
                            return true;
                        }
                        console.warn(`[BACKEND] Backend responded but status is not 'online':`, data.status);
                    } else {
                        console.warn(`[BACKEND] Health check returned HTTP ${response.status}`);
                    }
                } catch (error) {
                    if (attempt < 3) {
                        console.warn(`[BACKEND] Attempt ${attempt}/3 failed, retrying...:`, error.message);
                        await new Promise(resolve => setTimeout(resolve, 2000 * attempt)); // Exponential backoff
                    } else {
                        console.error('[BACKEND]  All health check attempts failed:', error.message);
                    }
                }
            }
            window.BACKEND_ONLINE = false;
            return false;
        }

        // Simple backend API wrapper (no key handling in browser) - with robust retry logic
        async function callAI(endpoint, body) {
            const response = await robustFetch(`${AI_API_BASE}/${endpoint}`, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(body)
            });

            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'AI Backend error');
            }

            // --- Enterprise tab mode toggle (AI vs Advanced manual) ---
            (function initEnterpriseModeToggle() {
                const adv = document.getElementById('ent_advanced_toggle');
                const hideable = [
                    document.getElementById('ent_manual_interfaces'),
                    document.getElementById('ent_manual_uplinks'),
                    document.getElementById('ent_manual_optional'),
                    document.getElementById('ent_row_public_pool'),
                    document.getElementById('ent_row_private_pair'),
                    document.getElementById('ent_row_gateway')
                ];
                const groups = hideable;
                const simpleBh = document.getElementById('ent_bh_cidr_simple');

                function setMode(manual) {
                    // Show/hide big manual sections
                    groups.forEach(el => { if (!el) return; el.style.display = manual ? '' : 'none'; });
                    // Simple BH row toggled inverse
                    const bhRow = document.getElementById('ent_bh_simple_row');
                    if (bhRow) bhRow.style.display = manual ? 'none' : '';
                }

                if (adv) {
                    adv.addEventListener('change', function () { setMode(adv.checked); });
                }
                // Default: AI mode (manual=false)
                setMode(false);

                // Keep simple BH in sync with first uplink field when switching
                window.entSyncBhCidr = function () {
                    const ta = document.querySelector('#ent_uplinksContainer .ent_uplinkIP');
                    if (!ta || !simpleBh) return;
                    if (simpleBh.value && ta.value !== simpleBh.value) ta.value = simpleBh.value;
                }
            })();

            function copyTextFallback(text) {
                const hidden = document.createElement('textarea');
                hidden.value = text;
                hidden.setAttribute('readonly', '');
                hidden.style.position = 'absolute';
                hidden.style.left = '-9999px';
                document.body.appendChild(hidden);
                hidden.select();
                try {
                    document.execCommand('copy');
                    alert(' Configuration copied to clipboard');
                } catch (e) {
                    alert('Failed to copy. You can manually select and copy the text.');
                }
                document.body.removeChild(hidden);
            }

            // Removed duplicate downloadUpgradeOutput() - using main function at line 5211

            return await response.json();
        }

        // AI Config Validation (can be called from any tab)
        async function validateConfigWithAI(config, configType = 'tower') {
            const keyInput = document.getElementById('llm_api_key');
            const key = keyInput.value.trim();

            if (!key) {
                updateApiKeyStatus(' Please enter an API key', 'error');
                return;
            }

            if (!key.startsWith('sk-')) {
                updateApiKeyStatus(' Warning: API key should start with "sk-"', 'warning');
            }

            // Store in localStorage ONLY (client-side)
            localStorage.setItem('openai_api_key', key);
            updateApiKeyStatus(' API Key saved securely (local storage only)', 'success');
        }

        function clearApiKey() {
            localStorage.removeItem('openai_api_key');
            document.getElementById('llm_api_key').value = '';
            updateApiKeyStatus(' API Key cleared', 'info');
        }

        function toggleApiKeyVisibility() {
            const input = document.getElementById('llm_api_key');
            const btn = document.getElementById('toggleApiKeyBtn');
            if (input.type === 'password') {
                input.type = 'text';
                btn.textContent = ' Hide';
            } else {
                input.type = 'password';
                btn.textContent = ' Show';
            }
        }

        function updateApiKeyStatus(message, type) {
            const status = document.getElementById('apiKeyStatus');
            const colors = {
                success: '#4CAF50',
                error: '#f44336',
                warning: '#ff9800',
                info: '#2196F3'
            };
            status.textContent = message;
            status.style.color = colors[type] || '#666';
            status.style.fontWeight = 'bold';
        }
        // Call OpenAI API (Secure - No Hardcoded Keys)
        async function callOpenAI(messages, options = {}) {
            const apiKey = localStorage.getItem('openai_api_key');

            if (!apiKey) {
                throw new Error('API key not found. Please save your OpenAI API key first.');
            }

            const endpoint = 'https://api.openai.com/v1/chat/completions';

            const requestBody = {
                model: options.model || 'gpt-4o', // Using GPT-4o for best quality
                messages: messages,
                temperature: options.temperature || 0.1, // Low temp for deterministic output
                max_tokens: options.maxTokens || 4000
            };

            try {
                const response = await fetch(endpoint, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}` // API key from localStorage
                    },
                    body: JSON.stringify(requestBody)
                });

                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(`OpenAI API Error: ${errorData.error?.message || response.statusText}`);
                }

                const data = await response.json();
                return data.choices[0].message.content;
            } catch (error) {
                console.error('OpenAI API call failed:', error);
                throw error;
            }
        }

        // Parse RouterOS Config
        function parseRouterOSConfig(configText) {
            const sections = {
                system: [],
                interfaces: [],
                ip: [],
                routing: [],
                mpls: [],
                security: [],
                other: []
            };

            const lines = configText.split('\n');
            let currentSection = 'other';
            let currentBlock = [];

            lines.forEach(line => {
                const trimmed = line.trim();

                // Detect section headers
                if (trimmed.startsWith('/system')) currentSection = 'system';
                else if (trimmed.startsWith('/interface')) currentSection = 'interfaces';
                else if (trimmed.startsWith('/ip')) currentSection = 'ip';
                else if (trimmed.startsWith('/routing')) currentSection = 'routing';
                else if (trimmed.startsWith('/mpls')) currentSection = 'mpls';
                else if (trimmed.startsWith('/snmp') || trimmed.startsWith('/user')) currentSection = 'security';

                // Add line to current section
                if (trimmed.startsWith('/') && currentBlock.length > 0) {
                    sections[currentSection].push(currentBlock.join('\n'));
                    currentBlock = [];
                }

                if (trimmed) {
                    currentBlock.push(line);
                }
            });

            if (currentBlock.length > 0) {
                sections[currentSection].push(currentBlock.join('\n'));
            }

            // Extract critical data that MUST be preserved
            const preserveData = {
                ips: extractIPs(configText),
                vlans: extractVLANs(configText),
                firewallRules: countFirewallRules(configText)
            };

            return { sections, preserveData, rawConfig: configText };
        }

        // Extract IPs from config
        function extractIPs(configText) {
            const ipRegex = /\b(?:\d{1,3}\.){3}\d{1,3}(?:\/\d{1,2})?\b/g;
            const matches = configText.match(ipRegex) || [];
            return [...new Set(matches)]; // Unique IPs
        }

        // Extract VLANs from config
        function extractVLANs(configText) {
            const vlanRegex = /vlan-id=(\d+)|vlan(\d+)|VLAN[\s_]?(\d+)/gi;
            const matches = [];
            let match;
            while ((match = vlanRegex.exec(configText)) !== null) {
                matches.push(match[1] || match[2] || match[3]);
            }
            return [...new Set(matches)];
        }

        // Count firewall rules
        function countFirewallRules(configText) {
            const firewallLines = configText.split('\n').filter(line =>
                line.includes('/ip firewall') || line.includes('add action=')
            );
            return firewallLines.length;
        }

        // Detect RouterOS version from config
        function detectRouterOSVersion(configText) {
            const versionMatch = configText.match(/by RouterOS\s+([\d.]+)/);
            return versionMatch ? versionMatch[1] : null;
        }

        // Build LLM Translation Prompt
        function buildTranslationPrompt(configSection, context) {
            const systemPrompt = `You are an expert RouterOS configuration translator. Your task is to translate MikroTik RouterOS configurations from one firmware version to another while strictly preserving all critical data.

CRITICAL RULES:
1. PRESERVE ALL IP addresses, subnets, and CIDR notations EXACTLY as provided
2. PRESERVE ALL firewall rules, NAT rules, and security settings
3. PRESERVE ALL VLANs, bridges, and interface names
4. TRANSLATE ONLY syntax changes (speed formats, routing protocol commands)
5. Follow RFC standards: OSPF (RFC 2328), BGP (RFC 4271), MPLS (RFC 3031), IPv4 (RFC 791)
6. Flag any features unsupported in target firmware
7. Output ONLY valid RouterOS commands (no explanations)
8. Maintain command order and structure
9. Preserve comments when present`;

            const userPrompt = `TRANSLATION REQUEST:
Source: RouterOS ${context.sourceVersion || 'Unknown'}
Target: RouterOS ${context.targetVersion} on ${context.targetDevice}

TARGET DEVICE PORTS AVAILABLE: ${context.targetPorts.join(', ')}

CRITICAL DATA TO PRESERVE (DO NOT MODIFY):
- IP Addresses: ${context.preserveData.ips.slice(0, 10).join(', ')}${context.preserveData.ips.length > 10 ? '...' : ''}
- VLANs: ${context.preserveData.vlans.join(', ') || 'None detected'}
- Firewall Rules Count: ${context.preserveData.firewallRules}

SYNTAX CHANGES FOR TARGET VERSION ${context.targetVersion}:
${getSyntaxChangeRules(context.targetVersion)}

SOURCE CONFIGURATION TO TRANSLATE:
\`\`\`
${configSection}
\`\`\`

Translate this configuration section to RouterOS ${context.targetVersion} syntax for ${context.targetDevice}. Output ONLY the translated RouterOS commands.`;

            return { systemPrompt, userPrompt };
        }

        // Get syntax change rules
        function getSyntaxChangeRules(targetVersion) {
            if (targetVersion.startsWith('7.16') || targetVersion.startsWith('7.19')) {
                return `RouterOS 7.16+ uses NEW SYNTAX:
- Ethernet speed: Use "speed=1G-baseT-full" instead of "speed=1Gbps duplex=full"
  Examples: 10G-baseCR, 10G-baseSR-LR, 1G-baseT-full, 100M-baseT-full
- OSPF: Use "/routing ospf interface-template" instead of "/routing ospf interface"
  Use "interfaces=" and "area=" parameters
- BGP: Use "/routing bgp connection" instead of "/routing bgp peer"
  Use "/routing bgp template" for common settings
- SFP ports: Use "sfp-sfpplus#" format (e.g., sfp-sfpplus1, sfp-sfpplus2)`;
            } else if (targetVersion.startsWith('7.')) {
                return `RouterOS 7.x (Pre-7.12 Syntax):
- Ethernet speed: Use "speed=1Gbps duplex=full" format
- OSPF: Use "/routing ospf interface" (v6 syntax)
- BGP: Use "/routing bgp peer" (v6 syntax)`;
            }
            return 'RouterOS 6.x: Use RouterOS v6 syntax for all commands';
        }

        // Validate Translated Config
        function validateTranslatedConfig(translatedConfig, context) {
            const issues = [];

            // 1. Verify all source IPs are preserved
            const sourceIPs = context.preserveData.ips;
            const translatedIPs = extractIPs(translatedConfig);
            const missingIPs = sourceIPs.filter(ip => !translatedIPs.includes(ip));

            if (missingIPs.length > 0) {
                issues.push({
                    severity: 'error',
                    message: `Missing IP addresses: ${missingIPs.slice(0, 5).join(', ')}${missingIPs.length > 5 ? '...' : ''}`
                });
            }

            // 2. Verify firewall rules count
            const translatedFirewallRules = countFirewallRules(translatedConfig);
            if (translatedFirewallRules < context.preserveData.firewallRules) {
                issues.push({
                    severity: 'warning',
                    message: `Firewall rule count decreased: ${context.preserveData.firewallRules}  ${translatedFirewallRules}`
                });
            }

            // 3. Verify VLANs preserved
            const translatedVLANs = extractVLANs(translatedConfig);
            const missingVLANs = context.preserveData.vlans.filter(vlan => !translatedVLANs.includes(vlan));
            if (missingVLANs.length > 0) {
                issues.push({
                    severity: 'warning',
                    message: `Missing VLANs: ${missingVLANs.join(', ')}`
                });
            }

            // 4. Check for invalid ports on target device
            const usedPorts = extractUsedPorts(translatedConfig);
            const invalidPorts = usedPorts.filter(port => !context.targetPorts.includes(port));
            if (invalidPorts.length > 0) {
                issues.push({
                    severity: 'error',
                    message: `Invalid ports for ${context.targetDevice}: ${invalidPorts.join(', ')}. Available: ${context.targetPorts.slice(0, 5).join(', ')}...`
                });
            }

            // 5. RFC 1918 validation (private IP ranges)
            const publicIPs = sourceIPs.filter(ip => !isPrivateIP(ip));
            if (publicIPs.length > 0 && context.validateRFC) {
                issues.push({
                    severity: 'info',
                    message: `Public IPs detected (RFC 791): ${publicIPs.slice(0, 3).join(', ')}${publicIPs.length > 3 ? '...' : ''}`
                });
            }

            return { valid: issues.filter(i => i.severity === 'error').length === 0, issues };
        }

        // Extract used ports from config
        function extractUsedPorts(configText) {
            const portRegex = /interface[=\s]+([\w\-]+\d+)/g;
            const matches = [];
            let match;
            while ((match = portRegex.exec(configText)) !== null) {
                matches.push(match[1]);
            }
            return [...new Set(matches)];
        }

        // Check if IP is private (RFC 1918)
        function isPrivateIP(ip) {
            const ipOnly = ip.split('/')[0];
            const parts = ipOnly.split('.').map(Number);
            if (parts.length !== 4) return false;

            // 10.0.0.0/8
            if (parts[0] === 10) return true;
            // 172.16.0.0/12
            if (parts[0] === 172 && parts[1] >= 16 && parts[1] <= 31) return true;
            // 192.168.0.0/16
            if (parts[0] === 192 && parts[1] === 168) return true;

            return false;
        }

        // Generate Diff View
        function generateDiff(beforeConfig, afterConfig) {
            const beforeLines = beforeConfig.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));
            const afterLines = afterConfig.split('\n').map(l => l.trim()).filter(l => l && !l.startsWith('#'));

            // Find syntax changes (simplified diff)
            const removed = beforeLines.filter(line => {
                // Look for lines that changed syntax
                if (line.includes('speed=') && line.includes('Gbps')) return true;
                if (line.includes('/routing ospf interface') && !line.includes('template')) return true;
                if (line.includes('/routing bgp peer')) return true;
                return false;
            });

            const added = afterLines.filter(line => {
                // Look for new syntax lines
                if (line.includes('speed=') && line.includes('baseT')) return true;
                if (line.includes('/routing ospf interface-template')) return true;
                if (line.includes('/routing bgp connection')) return true;
                return false;
            });

            document.getElementById('diff_before').value = removed.join('\n') || '(No major syntax removals)';
            document.getElementById('diff_after').value = added.join('\n') || '(No major syntax additions)';
            document.getElementById('diff_viewer').style.display = 'block';
        }

        // Update Progress Bar
        function updateProgress(percent, message) {
            const bar = document.getElementById('progress_bar');
            const text = document.getElementById('progress_text');
            bar.style.width = percent + '%';
            bar.textContent = percent + '%';
            text.textContent = message;
        }

        // Display Validation Issues
        function displayValidationIssues(issues) {
            const issuesList = document.getElementById('issues_list');
            issuesList.innerHTML = '';

            if (issues.length === 0) {
                issuesList.innerHTML = '<li style="color: #4CAF50;"> No issues detected!</li>';
            } else {
                issues.forEach(issue => {
                    const li = document.createElement('li');
                    const icon = issue.severity === 'error' ? '' : issue.severity === 'warning' ? '' : '';
                    li.textContent = `${icon} [${issue.severity.toUpperCase()}] ${issue.message}`;
                    li.style.color = issue.severity === 'error' ? '#f44336' : issue.severity === 'warning' ? '#ff9800' : '#2196F3';
                    li.style.marginBottom = '8px';
                    issuesList.appendChild(li);
                });
            }

            document.getElementById('validation_issues').style.display = 'block';
        }

        // Main Translation Function
        async function translateConfig() {
            const sourceConfig = document.getElementById('source_config').value;
            const targetDevice = document.getElementById('target_device_llm').value;
            const targetRouterOS = document.getElementById('target_routeros_llm').value;
            const preserveComments = document.getElementById('translate_preserve_comments').checked;
            const validateRFC = document.getElementById('translate_validate_rfc').checked;

            // Validation
            if (!sourceConfig || !targetDevice || !targetRouterOS) {
                alert(' Please fill in all required fields:\n- Source configuration\n- Target device\n- Target RouterOS version');
                return;
            }

            if (!localStorage.getItem('openai_api_key')) {
                alert(' Please save your OpenAI API key first!');
                return;
            }

            // Show MUSHU-style live progress tracker
            showProgressTracker('Configuration Migration/Upgrade');
            updateProgressStep('Initializing upgrade process...');
            updateProgressPercent(5);
            addProgressLog('info', 'Starting configuration translation');
            addProgressLog('info', `Target: ${targetDevice}  RouterOS ${targetRouterOS}`);

            // Reset UI
            document.getElementById('translation_progress').style.display = 'block';
            document.getElementById('validation_issues').style.display = 'none';
            document.getElementById('diff_viewer').style.display = 'none';
            document.getElementById('translation_output_section').style.display = 'none';

            try {
                updateProgress(5, 'Parsing source configuration...');
                updateProgressStep('Parsing source configuration...');
                addProgressLog('info', 'Analyzing source config structure');

                // 1. Parse config
                const parsedConfig = parseRouterOSConfig(sourceConfig);
                const detectedVersion = detectRouterOSVersion(sourceConfig);

                updateProgress(15, `Detected RouterOS ${detectedVersion || 'Unknown'}. Preparing translation...`);
                updateProgressPercent(15);
                addProgressLog('success', `Detected RouterOS version: ${detectedVersion || 'Unknown'}`);

                // 2. Get device context
                const targetDeviceConfig = DEVICE_CONFIGS[targetDevice];
                const context = {
                    sourceConfig: sourceConfig,
                    sourceVersion: detectedVersion,
                    targetDevice: targetDeviceConfig.name,
                    targetVersion: targetRouterOS,
                    targetPorts: [...targetDeviceConfig.ports, ...targetDeviceConfig.sfpPorts],
                    preserveData: parsedConfig.preserveData,
                    validateRFC: validateRFC
                };

                updateProgress(25, 'Translating configuration via AI...');
                updateProgressPercent(25);
                updateProgressStep('Building translation prompt with device context...');
                addProgressLog('info', 'Preparing AI translation prompt');

                // 3. Build prompt and call LLM
                const prompt = buildTranslationPrompt(sourceConfig, context);

                const messages = [
                    { role: 'system', content: prompt.systemPrompt },
                    { role: 'user', content: prompt.userPrompt }
                ];

                updateProgress(35, 'Calling OpenAI API (this may take 30-60 seconds)...');
                updateProgressPercent(35);
                updateProgressStep('Calling OpenAI API - this may take 30-60 seconds...');
                addProgressLog('info', 'Sending translation request to OpenAI GPT-4');

                const translatedConfig = await callOpenAI(messages, {
                    model: 'gpt-4o',
                    maxTokens: 6000,
                    temperature: 0.1
                });

                updateProgress(75, 'Translation complete. Validating...');
                updateProgressPercent(75);
                updateProgressStep('Translation received. Running validation checks...');
                addProgressLog('success', 'AI translation completed successfully');
                addProgressLog('info', `Translated config size: ${translatedConfig.length} characters`);

                // 4. Validate
                const validation = validateTranslatedConfig(translatedConfig, context);
                displayValidationIssues(validation.issues);
                if (validation.issues.length > 0) {
                    addProgressLog('warning', `Validation found ${validation.issues.length} issues to review`);
                } else {
                    addProgressLog('success', 'Validation passed - no issues found');
                }

                updateProgress(90, 'Generating diff view...');
                updateProgressPercent(90);
                updateProgressStep('Generating side-by-side diff comparison...');
                addProgressLog('info', 'Creating diff viewer');

                // 5. Generate diff
                generateDiff(sourceConfig, translatedConfig);

                updateProgress(100, ' Translation complete!');
                updateProgressPercent(100);
                updateProgressStep('Migration complete - displaying results');
                addProgressLog('success', 'Configuration migration completed successfully!');

                // 6. Display results
                document.getElementById('translated_output').value = translatedConfig;
                document.getElementById('translation_output_section').style.display = 'block';

                // Track in history BEFORE completing progress tracker
                saveConfigToHistory({
                    type: 'migration',
                    device: `${targetDevice} (${targetRouterOS})`,
                    siteName: 'Migrated Configuration',
                    routeros: targetRouterOS,
                    success: true
                });

                // Complete progress tracker (this should happen AFTER saving to history)
                setTimeout(() => {
                    completeProgressTracker(true);
                }, 500);

                // Auto-hide translation progress bar after 2 seconds
                setTimeout(() => {
                    document.getElementById('translation_progress').style.display = 'none';
                }, 2000);

            } catch (error) {
                console.error('Translation error:', error);
                updateProgress(0, '');
                document.getElementById('translation_progress').style.display = 'none';
                addProgressLog('error', `Translation failed: ${error.message}`);

                // Track failure
                saveConfigToHistory({
                    type: 'migration',
                    device: targetDevice || 'Unknown',
                    siteName: 'Migrated Configuration',
                    routeros: targetRouterOS || 'Unknown',
                    success: false
                });

                completeProgressTracker(false);
                alert(`Translation Error:\n\n${error.message}\n\nPlease check:\n1. API key is valid\n2. You have OpenAI API credits\n3. Source config is valid RouterOS format`);
            }
        }

        // Validate Only (No Translation)
        async function validateOnly() {
            const sourceConfig = document.getElementById('source_config').value;
            const targetDevice = document.getElementById('target_device_llm').value;

            if (!sourceConfig) {
                alert(' Please paste a source configuration first!');
                return;
            }

            const parsedConfig = parseRouterOSConfig(sourceConfig);
            const detectedVersion = detectRouterOSVersion(sourceConfig);

            alert(` Configuration Analysis:

Detected RouterOS: ${detectedVersion || 'Unknown'}
IP Addresses: ${parsedConfig.preserveData.ips.length}
VLANs: ${parsedConfig.preserveData.vlans.length}
Firewall Rules: ${parsedConfig.preserveData.firewallRules}
Sections Detected:
- System: ${parsedConfig.sections.system.length} blocks
- Interfaces: ${parsedConfig.sections.interfaces.length} blocks
- IP: ${parsedConfig.sections.ip.length} blocks
- Routing: ${parsedConfig.sections.routing.length} blocks
- MPLS: ${parsedConfig.sections.mpls.length} blocks
Ready for translation!`);
        }

        // Target Device Info Display
        function updateTargetDeviceInfo() {
            const targetDevice = document.getElementById('target_device_llm').value;
            const infoDiv = document.getElementById('targetDeviceInfo');
            const detailsDiv = document.getElementById('targetDeviceDetails');

            if (!targetDevice) {
                infoDiv.style.display = 'none';
                return;
            }

            const deviceConfig = DEVICE_CONFIGS[targetDevice];
            detailsDiv.innerHTML = `
        <div style="margin-top: 8px;">
            <strong>${deviceConfig.name}</strong><br>
            Ethernet Ports: ${deviceConfig.ports.join(', ')}<br>
            SFP Ports: ${deviceConfig.sfpPorts.join(', ') || 'None'}<br>
            Features: ${deviceConfig.features.join(', ')}<br>
            RouterOS: ${deviceConfig.routerOS.join(', ')}
        </div>
    `;
            infoDiv.style.display = 'block';
        }

        // Copy/Download Functions
        function copyTranslatedConfig() {
            const config = document.getElementById('translated_output').value;
            if (!config) {
                alert(' No configuration to copy!');
                return;
            }
            navigator.clipboard.writeText(config).then(() => {
                alert(' Translated configuration copied to clipboard!');
            }).catch(err => {
                alert(' Failed to copy: ' + err);
            });
        }

        function downloadTranslatedConfig() {
            const config = document.getElementById('translated_output').value;
            if (!config) {
                alert(' No configuration to download!');
                return;
            }

            const targetDevice = document.getElementById('target_device_llm').value;
            const targetVersion = document.getElementById('target_routeros_llm').value;
            const filename = `translated_${targetDevice}_${targetVersion}_${Date.now()}.rsc`;

            const blob = new Blob([config], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);
        }

        function resetTranslator() {
            document.getElementById('source_config').value = '';
            document.getElementById('translated_output').value = '';
            document.getElementById('translation_output_section').style.display = 'none';
            document.getElementById('validation_issues').style.display = 'none';
            document.getElementById('diff_viewer').style.display = 'none';
            document.getElementById('source_device_llm').value = '';
            document.getElementById('source_routeros_llm').value = '';
            document.getElementById('target_device_llm').value = '';
            document.getElementById('target_routeros_llm').value = '';
            updateTargetDeviceInfo();
        }

        // AI Integration Functions for Tower Tab
        async function validateWithAI(tabType) {
            const config = document.getElementById('output').textContent;
            if (!config) {
                showAIStatus('Please generate a configuration first!', 'error');
                return;
            }

            try {
                showAIStatus(' Validating configuration with AI...', 'info');

                const result = await callAI('validate-config', {
                    config: config,
                    type: tabType
                });

                const validation = result.validation;
                const issues = validation.issues || [];

                if (issues.length === 0) {
                    showAIStatus(' No issues found! Configuration looks good.', 'success');
                } else {
                    let issuesHtml = '<strong style="color: #ff9800;"> Issues Found:</strong><ul>';
                    issues.forEach(issue => {
                        issuesHtml += `<li style="color: ${issue.severity === 'error' ? '#f44336' : '#ff9800'}">${issue.message}</li>`;
                    });
                    issuesHtml += '</ul>';
                    showAIStatus(issuesHtml, 'warning');
                }
            } catch (error) {
                showAIStatus(` Error: ${error.message}<br>Make sure api_server.py is running!`, 'error');
            }
        }

        async function suggestWithAI(tabType) {
            const config = document.getElementById('output').textContent;
            if (!config) {
                showAIStatus('Please generate a configuration first!', 'error');
                return;
            }

            try {
                showAIStatus(' Getting AI suggestions...', 'info');

                const result = await callAI('suggest-config', {
                    config: config,
                    type: tabType
                });

                const suggestions = result.suggestions || [];

                if (suggestions.length === 0) {
                    showAIStatus(' No suggestions available. Configuration looks optimal!', 'success');
                } else {
                    let suggestionsHtml = '<strong style="color: #2196F3;"> AI Suggestions:</strong><ul>';
                    suggestions.forEach(suggestion => {
                        suggestionsHtml += `<li style="color: #1976D2;">${suggestion}</li>`;
                    });
                    suggestionsHtml += '</ul>';
                    showAIStatus(suggestionsHtml, 'info');
                }
            } catch (error) {
                showAIStatus(` Error: ${error.message}`, 'error');
            }
        }

        async function autoFillFromExport(tabType) {
            const exportedConfig = prompt('Paste your /export config here:');
            if (!exportedConfig) return;

            try {
                showAIStatus(' Parsing configuration with AI...', 'info');

                const result = await callAI('autofill-from-export', {
                    exported_config: exportedConfig,
                    target_form: tabType
                });

                const fields = result.fields;

                // Auto-fill form fields based on tab type
                if (tabType === 'tower') {
                    if (fields.site_name) document.getElementById('siteName').value = fields.site_name;
                    if (fields.router_id) document.getElementById('routerId').value = fields.router_id;
                    if (fields.loopback_ip) document.getElementById('loopbackIP').value = fields.loopback_ip;
                    if (fields.asn) document.getElementById('asn').value = fields.asn;
                }

                showAIStatus(' Form auto-filled! Review and generate config.', 'success');
            } catch (error) {
                showAIStatus(` Error: ${error.message}`, 'error');
            }
        }

        async function translateWithAI(tabType) {
            const config = document.getElementById('output').textContent;
            if (!config) {
                showAIStatus('Please generate a configuration first!', 'error');
                return;
            }

            try {
                showAIStatus(' Translating configuration with AI...', 'info');

                const result = await callAI('translate-config', {
                    config: config,
                    target_version: '7',
                    target_device: 'ccr2004'
                });

                const translatedConfig = result.translated_config;

                // Show translated config in a modal or replace current output
                document.getElementById('output').value = translatedConfig;
                showAIStatus(' Configuration translated to RouterOS v7!', 'success');
            } catch (error) {
                showAIStatus(` Error: ${error.message}`, 'error');
            }
        }

        function showAIStatus(message, type) {
            const statusDiv = document.getElementById('aiStatus');
            const statusText = document.getElementById('aiStatusText');

            if (statusDiv && statusText) {
                statusDiv.style.display = 'block';
                statusText.innerHTML = message;

                // Update colors based on type
                statusDiv.style.background = type === 'error' ? '#ffebee' :
                    type === 'warning' ? '#fff3e0' :
                        type === 'success' ? '#e8f5e9' : '#e3f2fd';
                statusDiv.style.color = type === 'error' ? '#c62828' :
                    type === 'warning' ? '#ef6c00' :
                        type === 'success' ? '#2e7d32' : '#1976D2';
            }
        }

        // Auto-generate device name based on router type and customer code
        function updateDeviceName() {
            const deviceType = document.getElementById('ent_routerboard_device').value;
            const customerCode = document.getElementById('ent_customerCode').value;
            const deviceNameField = document.getElementById('ent_deviceName');

            if (deviceType && customerCode) {
                let devicePrefix = '';
                switch (deviceType) {
                    case 'ccr2004':
                        devicePrefix = 'RTR-MTCCR-2004';
                        break;
                    case 'rb5009':
                        devicePrefix = 'RTR-MTRB-5009';
                        break;
                    case 'ccr1036':
                        devicePrefix = 'RTR-MTCCR1036';
                        break;
                    case 'rb1009':
                        devicePrefix = 'RTR-MTRB1009';
                        break;
                    case 'rb2011':
                        devicePrefix = 'RTR-MTRB2011';
                        break;
                    case 'ccr1072':
                        devicePrefix = 'RTR-MTCCR1072';
                        break;
                    case 'ccr2216':
                        devicePrefix = 'RTR-MTCCR2216';
                        break;
                    default:
                        devicePrefix = 'RTR-MT';
                }

                deviceNameField.value = `${devicePrefix}.${customerCode}`;
            } else {
                deviceNameField.value = '';
            }
        }

        // Auto-fill Public DHCP Pool based on Public IP CIDR
        // IMPORTANT: The user enters the GATEWAY IP, not the network address
        // For /30: 4 total IPs = network, gateway, customer, broadcast (2 usable: gateway + customer)
        // We need to calculate the customer IP (gateway + 1) for the DHCP pool
        function updatePublicPoolFromPublicIp() {
            const publicIP = document.getElementById('ent_publicIP').value.trim();
            const publicPoolField = document.getElementById('ent_publicPool');

            if (!publicIP || !publicPoolField) return;

            try {
                const info = parseCidr(publicIP);
                if (!info) return;

                // Extract the gateway IP from user input (the IP part before /)
                const gatewayIP = info.ip; // This is what the user typed (gateway, not network)
                const gatewayInt = ipToInt(gatewayIP);

                // Calculate network address (gateway IP & mask)
                const networkInt = ipToInt(gatewayIP) & info.mask;
                const broadcastInt = networkInt | (~info.mask >>> 0);

                // For /30 networks: exactly 4 total IPs, 2 usable
                // IPs: network, gateway, customer, broadcast
                // Gateway = user input (network + 1)
                // Customer = gateway + 1 (this is what we want for DHCP pool)
                // Broadcast = network + 3
                if (info.prefix === 30) {
                    // /30 has exactly 4 IPs: network, gateway, customer, broadcast
                    // Total: 2^2 = 4 IPs
                    // Usable: 2 IPs (gateway and customer)
                    // Customer IP = gateway + 1 (the only IP left for DHCP pool)
                    const customerInt = gatewayInt + 1;

                    // For /30: broadcast = network + 3, customer = broadcast - 1
                    // Show single IP without dash format (cleaner)
                    if (customerInt < broadcastInt) {
                        const customerIP = intToIp(customerInt);
                        publicPoolField.value = customerIP; // Single IP, no dash format
                    } else {
                        // Safety check - shouldn't happen but handle gracefully
                        console.warn('Invalid /30 calculation: customer IP >= broadcast');
                        publicPoolField.value = '';
                    }
                } else if (info.prefix === 29) {
                    // /29 has 8 IPs: network, gateway, then 5 more usable, broadcast
                    // Customer pool = gateway + 1 to lastUsable (broadcast - 1)
                    const startInt = gatewayInt + 1;
                    const lastUsable = broadcastInt - 1;
                    if (startInt <= lastUsable) {
                        publicPoolField.value = `${intToIp(startInt)}-${intToIp(lastUsable)}`;
                    } else {
                        publicPoolField.value = '';
                    }
                } else if (info.prefix >= 28) {
                    // /28 has 16 IPs, /27 has 32, etc.
                    // Start from gateway + 1, use a reasonable range
                    const startInt = gatewayInt + 1;
                    const lastUsable = broadcastInt - 1;
                    const endInt = Math.min(startInt + 9, lastUsable); // Use up to 10 IPs or until lastUsable
                    if (startInt <= endInt) {
                        publicPoolField.value = `${intToIp(startInt)}-${intToIp(endInt)}`;
                    } else {
                        publicPoolField.value = '';
                    }
                } else {
                    // For larger networks (/27 or smaller): start from gateway + 1
                    const startInt = gatewayInt + 1;
                    const lastUsable = broadcastInt - 1;
                    const endInt = Math.min(startInt + 19, lastUsable); // Use up to 20 IPs or until lastUsable
                    if (startInt <= endInt) {
                        publicPoolField.value = `${intToIp(startInt)}-${intToIp(endInt)}`;
                    } else {
                        publicPoolField.value = '';
                    }
                }
            } catch (e) {
                console.log('Error calculating public pool:', e);
                publicPoolField.value = '';
            }
        }

        // Auto-fill Network Address based on Backhaul IP CIDR
        function updateGatewayFromBackhaul() {
            const backhaulIP = document.getElementById('ent_backhaulIP').value.trim();
            const networkField = document.getElementById('ent_gatewayIP');

            if (!backhaulIP || !networkField) return;

            try {
                const info = parseCidr(backhaulIP);
                if (!info) return;

                // Calculate network address (IP & mask)
                const networkInt = ipToInt(info.ip) & info.mask;
                const networkIP = intToIp(networkInt);
                const networkAddress = `${networkIP}/${info.prefix}`;

                networkField.value = networkAddress;
            } catch (e) {
                console.log('Error calculating network address:', e);
            }
        }

        // ===== AUTO-SAVE COMPLETED CONFIGS =====
        // Track recent saves to prevent duplicates
        const recentSaves = new Map();
        const SAVE_DEDUP_WINDOW = 5000; // 5 seconds

        function saveCompletedConfig(configData) {
            // Check if we're in file:// protocol (CORS will block)
            if (window.location.protocol === 'file:') {
                console.warn('[AUTO-SAVE] Cannot save config: HTML file opened via file:// protocol. CORS blocks requests. Please serve via HTTP server.');
                return;
            }

            // Validate config data
            if (!configData || !configData.config_content) {
                console.warn('[AUTO-SAVE] Invalid config data:', configData);
                return;
            }

            // Create a unique key for this config to prevent duplicates
            const saveKey = `${configData.config_type}-${configData.device_name}-${configData.customer_code}-${configData.loopback_ip}-${configData.config_content.substring(0, 100)}`;
            const now = Date.now();

            // Check if we've saved this exact config recently
            if (recentSaves.has(saveKey)) {
                const lastSaveTime = recentSaves.get(saveKey);
                if (now - lastSaveTime < SAVE_DEDUP_WINDOW) {
                    console.log('[AUTO-SAVE]  Skipping duplicate save (saved', Math.round((now - lastSaveTime) / 1000), 'seconds ago)');
                    return;
                }
            }

            // Mark this config as saved
            recentSaves.set(saveKey, now);

            // Clean up old entries (older than 1 minute)
            for (const [key, time] of recentSaves.entries()) {
                if (now - time > 60000) {
                    recentSaves.delete(key);
                }
            }

            console.log('[AUTO-SAVE] Attempting to save config:', {
                type: configData.config_type,
                device: configData.device_name,
                customer: configData.customer_code
            });

            // Save config to backend asynchronously (don't block UI)
            fetch(`${AI_API_BASE}/save-completed-config`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify(configData)
            })
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.success) {
                        console.log('[AUTO-SAVE]  Configuration saved successfully! ID:', data.config_id);
                    } else {
                        console.warn('[AUTO-SAVE]  Failed to save config:', data.error);
                    }
                })
                .catch(error => {
                    console.error('[AUTO-SAVE]  Error saving config:', error);
                    console.error('[AUTO-SAVE] Make sure backend server is running: python api_server.py');
                });
        }

        // ===== POLICY REFERENCE FUNCTIONS =====
        function togglePolicyReference() {
            const section = document.getElementById('policyReferenceSection');
            const btn = document.getElementById('policyToggleBtn');
            if (section.style.display === 'none' || !section.style.display) {
                section.style.display = 'block';
                if (btn) btn.textContent = ' Close Policy';
            } else {
                section.style.display = 'none';
                if (btn) btn.textContent = ' View Policy';
            }
        }

        // ===== COMPLETED CONFIGS FUNCTIONS =====
        function loadCompletedConfigs() {
            const listContainer = document.getElementById('completedConfigsList');
            if (!listContainer) return;

            // Check if we're in file:// protocol (CORS will block)
            if (window.location.protocol === 'file:') {
                listContainer.innerHTML = '<div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; text-align: center;"><strong> CORS Issue Detected</strong><br><br>The HTML file is opened via <code>file://</code> protocol, which blocks API requests.<br><br><strong>Solution:</strong> Serve the HTML file via HTTP server:<br><br><code style="background: #f5f5f5; padding: 5px 10px; border-radius: 3px;">python -m http.server 8000</code><br><br>Then open: <code style="background: #f5f5f5; padding: 5px 10px; border-radius: 3px;">http://localhost:8000/NOC-configMaker.html</code></div>';
                return;
            }

            listContainer.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary); padding: 20px;">Loading...</p>';

            // Use AI_API_BASE if defined, otherwise construct it
            const apiBase = resolveApiBase();

            fetch(`${apiBase}/get-completed-configs`)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(data => {
                    if (data.error) {
                        listContainer.innerHTML = `<p style="color: red; text-align: center; padding: 20px;">Error: ${data.error}</p>`;
                        return;
                    }

                    displayConfigsList(data.configs || []);
                    populateYearFilter(data.years || []);
                })
                .catch(error => {
                    console.error('Error loading configs:', error);
                    listContainer.innerHTML = `<div style="background: #f8d7da; border: 2px solid #dc3545; border-radius: 8px; padding: 20px; text-align: center;"><strong> Failed to load configurations</strong><br><br>${error.message}<br><br><strong>Make sure:</strong><br>1. Backend server is running: <code style="background: #f5f5f5; padding: 5px 10px; border-radius: 3px;">python api_server.py</code><br>2. HTML is served via HTTP (not file://)</div>`;
                });
        }

        function searchCompletedConfigs() {
            const searchTerm = document.getElementById('configSearch')?.value || '';
            const yearFilter = document.getElementById('configYearFilter')?.value || '';
            const typeFilter = document.getElementById('configTypeFilter')?.value || '';

            const listContainer = document.getElementById('completedConfigsList');
            if (!listContainer) return;

            listContainer.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary); padding: 20px;">Searching...</p>';

            const params = new URLSearchParams();
            if (searchTerm) params.append('search', searchTerm);
            if (yearFilter) params.append('year', yearFilter);
            if (typeFilter) params.append('type', typeFilter);

            fetch(`${AI_API_BASE}/get-completed-configs?${params.toString()}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        listContainer.innerHTML = `<p style="color: red; text-align: center; padding: 20px;">Error: ${data.error}</p>`;
                        return;
                    }
                    displayConfigsList(data.configs || []);
                })
                .catch(error => {
                    console.error('Error searching configs:', error);
                    listContainer.innerHTML = '<p style="color: red; text-align: center; padding: 20px;">Search failed. Make sure the backend server is running.</p>';
                });
        }

        function displayConfigsList(configs) {
            const listContainer = document.getElementById('completedConfigsList');
            if (!listContainer) return;

            if (configs.length === 0) {
                listContainer.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary); padding: 50px;">No configurations found.</p>';
                return;
            }

            // Group by year
            const groupedByYear = {};
            configs.forEach(config => {
                const year = new Date(config.created_at).getFullYear();
                if (!groupedByYear[year]) groupedByYear[year] = [];
                groupedByYear[year].push(config);
            });

            // Sort years descending
            const years = Object.keys(groupedByYear).sort((a, b) => b - a);

            let html = '';
            years.forEach(year => {
                html += `<div style="margin-bottom: 30px;">`;
                html += `<h3 style="color: var(--text-color); border-bottom: 2px solid var(--border-color); padding-bottom: 10px; margin-bottom: 15px;">${year} Configs (${groupedByYear[year].length})</h3>`;

                groupedByYear[year].forEach(config => {
                    const date = formatCSTTimestamp(config.created_at);
                    html += `<div style="background: var(--output-bg); border: 1px solid var(--border-color); border-radius: 5px; padding: 15px; margin-bottom: 10px; cursor: pointer;" onclick="viewCompletedConfig(${config.id})">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: start;">`;
                    html += `<div style="flex: 1;">`;
                    html += `<strong style="color: var(--text-color); font-size: 16px;">${config.config_type === 'tower' ? '' : config.config_type === 'enterprise' ? '' : ''} ${config.device_name || config.customer_code || 'Unnamed Config'}</strong>`;
                    html += `<div style="color: var(--text-color-secondary); font-size: 14px; margin-top: 5px;">`;
                    html += `<span>Type: ${config.config_type}</span> | `;
                    html += `<span>Device: ${config.device_type || 'N/A'}</span> | `;
                    html += `<span>Created: ${date}</span>`;
                    html += `</div>`;
                    if (config.customer_code) {
                        html += `<div style="color: var(--text-color-secondary); font-size: 13px; margin-top: 5px;">Customer: ${config.customer_code}</div>`;
                    }
                    if (config.loopback_ip) {
                        html += `<div style="color: var(--text-color-secondary); font-size: 13px;">Loopback: ${config.loopback_ip}</div>`;
                    }
                    html += `</div>`;
                    html += `<div>`;
                    html += `<button onclick="event.stopPropagation(); downloadCompletedConfig(${config.id})" style="background: #4CAF50; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; margin-right: 5px;"> Download</button>`;
                    html += `<button onclick="event.stopPropagation(); downloadPortMap(${config.id})" style="background: #FF9800; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer; margin-right: 5px;" title="Download Port Map"> Port Map</button>`;
                    html += `<button onclick="event.stopPropagation(); viewCompletedConfig(${config.id})" style="background: #2196F3; color: white; border: none; padding: 8px 15px; border-radius: 3px; cursor: pointer;"> View</button>`;
                    html += `</div>`;
                    html += `</div>`;
                    html += `</div>`;
                });

                html += `</div>`;
            });

            listContainer.innerHTML = html;
        }

        function populateYearFilter(years) {
            const yearSelect = document.getElementById('configYearFilter');
            if (!yearSelect) return;

            // Keep "All Years" option
            const allYearsOption = yearSelect.querySelector('option[value=""]');
            yearSelect.innerHTML = '';
            if (allYearsOption) yearSelect.appendChild(allYearsOption);

            // Add year options
            years.sort((a, b) => b - a).forEach(year => {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                yearSelect.appendChild(option);
            });
        }

        function viewCompletedConfig(configId) {
            fetch(`${AI_API_BASE}/get-completed-config/${configId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert('Error: ' + data.error);
                        return;
                    }

                    // Show config in modal or new window
                    const modal = document.createElement('div');
                    modal.style.cssText = 'position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.8); z-index: 10000; display: flex; align-items: center; justify-content: center;';

                    // Format port mapping display
                    let portMapDisplay = '';
                    if (data.port_mapping_text) {
                        portMapDisplay = `
                    <div style="background: #1e3a5f; padding: 20px; border-radius: 5px; margin-bottom: 20px; border: 1px solid #3a5f8f;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="color: #4a9eff; margin: 0; font-size: 18px;">BH IPs/Port Map</h3>
                            <a href="${AI_API_BASE}/download-port-map/${configId}" 
                               download 
                               style="background: #4CAF50; color: white; padding: 8px 16px; border-radius: 5px; text-decoration: none; font-size: 14px; font-weight: bold;">
                                 Download Port Map
                            </a>
                        </div>
                        <pre style="white-space: pre-wrap; font-family: 'Courier New', monospace; font-size: 13px; color: #e0e0e0; margin: 0; line-height: 1.6; background: #0d1b2a; padding: 15px; border-radius: 3px; overflow-x: auto;">${data.port_mapping_text}</pre>
                    </div>
                `;
                    } else if (data.port_mapping && Object.keys(data.port_mapping).length > 0) {
                        // Fallback to JSON if formatted text not available
                        portMapDisplay = `
                    <div style="background: #1e3a5f; padding: 20px; border-radius: 5px; margin-bottom: 20px; border: 1px solid #3a5f8f;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h3 style="color: #4a9eff; margin: 0; font-size: 18px;">Port Mapping</h3>
                            <a href="${AI_API_BASE}/download-port-map/${configId}" 
                               download 
                               style="background: #4CAF50; color: white; padding: 8px 16px; border-radius: 5px; text-decoration: none; font-size: 14px; font-weight: bold;">
                                 Download Port Map
                            </a>
                        </div>
                        <pre style="white-space: pre-wrap; font-family: monospace; font-size: 12px; color: #e0e0e0;">${JSON.stringify(data.port_mapping, null, 2)}</pre>
                    </div>
                `;
                    }

                    modal.innerHTML = `
                <div style="background: var(--bg-color); border-radius: 8px; padding: 30px; max-width: 90%; max-height: 90%; overflow-y: auto; position: relative;">
                    <button onclick="this.parentElement.parentElement.remove()" style="position: absolute; top: 10px; right: 10px; background: #dc3545; color: white; border: none; padding: 8px 15px; border-radius: 5px; cursor: pointer; font-weight: bold;"> Close</button>
                    <h2 style="color: var(--text-color); margin-bottom: 20px;">${data.device_name || 'Configuration'}</h2>
                    ${portMapDisplay}
                    <h3 style="color: var(--text-color); margin-top: 20px;">Configuration</h3>
                    <pre style="background: var(--output-bg); padding: 20px; border-radius: 5px; overflow-x: auto; white-space: pre-wrap; font-family: monospace; font-size: 12px; max-height: 60vh; overflow-y: auto;">${data.config_content || ''}</pre>
                    <div style="margin-top: 20px;">
                        <button onclick="navigator.clipboard.writeText(\`${(data.config_content || '').replace(/`/g, '\\`')}\`) && alert(' Copied!')" style="background: #2196F3; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer; margin-right: 10px;"> Copy Config</button>
                        <button onclick="downloadCompletedConfig(${configId})" style="background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;"> Download</button>
                    </div>
                </div>
            `;
                    document.body.appendChild(modal);
                })
                .catch(error => {
                    console.error('Error loading config:', error);
                    alert('Failed to load configuration. Make sure the backend server is running.');
                });
        }

        function downloadCompletedConfig(configId) {
            fetch(`${AI_API_BASE}/get-completed-config/${configId}`)
                .then(response => response.json())
                .then(data => {
                    if (data.error) {
                        alert('Error: ' + data.error);
                        return;
                    }

                    const blob = new Blob([data.config_content || ''], { type: 'text/plain' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${data.device_name || 'config'}_${new Date(data.created_at).toISOString().split('T')[0]}.rsc`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                })
                .catch(error => {
                    console.error('Error downloading config:', error);
                    alert('Failed to download configuration.');
                });
        }

        function downloadPortMap(configId) {
            // Direct download from API endpoint
            const url = `${AI_API_BASE}/download-port-map/${configId}`;
            const a = document.createElement('a');
            a.href = url;
            a.download = `port_map_${configId}.txt`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            // Show success notification
            setTimeout(() => {
                const notification = document.createElement('div');
                notification.textContent = ' Port Map downloaded!';
                notification.style.cssText = 'position: fixed; top: 20px; right: 20px; background: #4CAF50; color: white; padding: 12px 20px; border-radius: 5px; z-index: 10001; box-shadow: 0 4px 6px rgba(0,0,0,0.3);';
                document.body.appendChild(notification);
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 2000);
            }, 100);
        }

        // ========================================
        // AUTHENTICATION & USER MANAGEMENT
        // ========================================
        function handleLogout() {
            if (confirm('Are you sure you want to log out?')) {
                localStorage.removeItem('auth_token');
                localStorage.removeItem('user_info');
                window.location.href = 'login.html';
            }
        }

        function updateUserDisplay() {
            const userInfoStr = localStorage.getItem('user_info');
            const userEmailDisplay = document.getElementById('userEmailDisplay');

            if (userInfoStr && userEmailDisplay) {
                try {
                    const userInfo = JSON.parse(userInfoStr);
                    userEmailDisplay.textContent = userInfo.email || '';
                    window.currentUser = userInfo;
                } catch (e) {
                    console.error('[AUTH] Failed to parse user info:', e);
                }
            }
        }

        // Load log history
        // Admin Panel Functions
        async function checkAdminAccess() {
            const adminBtn = document.getElementById('adminNavBtn');
            const token = localStorage.getItem('auth_token');

            if (!adminBtn) {
                console.warn('[ADMIN] Admin button element not found');
                return false;
            }

            if (!token) {
                adminBtn.style.display = 'none';
                return false;
            }

            // Show the button for authenticated users; the admin panel will display an access message if unauthorized.
            adminBtn.style.display = 'inline-block';
            adminBtn.style.opacity = '0.7';
            adminBtn.title = 'Admin access required';

            try {
                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                const response = await fetch(`${apiBase}/admin/feedback?limit=1`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (response.ok) {
                    adminBtn.style.display = 'inline-block';
                    adminBtn.style.opacity = '1';
                    adminBtn.title = '';
                    return true;
                }

                // Keep visible, but mark as restricted.
                if (response.status === 403) {
                    adminBtn.style.opacity = '0.7';
                    adminBtn.title = 'Admin access required';
                    return false;
                }

                adminBtn.style.opacity = '0.7';
                return false;
            } catch (e) {
                console.warn('[ADMIN] Admin check failed:', e);
                // Keep visible if logged in; backend may be temporarily unavailable.
                adminBtn.style.display = 'inline-block';
                adminBtn.style.opacity = '0.7';
                adminBtn.title = 'Admin check unavailable';
                return false;
            }
        }

        // Make admin functions globally accessible
        window.loadAdminFeedback = async function () {
            try {
                const token = localStorage.getItem('auth_token');
                if (!token) {
                    const feedbackList = document.getElementById('adminFeedbackList');
                    if (feedbackList) {
                        feedbackList.innerHTML = '<p style="text-align: center; color: #ff4444; padding: 50px;">Please log in to access admin panel</p>';
                    }
                    return;
                }

                const statusFilter = document.getElementById('adminFeedbackStatusFilter')?.value || 'all';
                const typeFilter = document.getElementById('adminFeedbackTypeFilter')?.value || 'all';

                const feedbackList = document.getElementById('adminFeedbackList');
                if (feedbackList) {
                    feedbackList.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary); padding: 50px;">Loading feedback...</p>';
                }

                // Use relative URL so it works through the launcher proxy
                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                const response = await fetch(`${apiBase}/admin/feedback?status=${statusFilter}&type=${typeFilter}&limit=100`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 403) {
                        if (feedbackList) {
                            feedbackList.innerHTML = '<p style="text-align: center; color: #ff4444; padding: 50px;">Admin access required. You do not have permission to view feedback.</p>';
                        }
                        return;
                    }
                    throw new Error(`HTTP ${response.status}`);
                }

                const data = await response.json();

                if (!data.success || !data.feedback || data.feedback.length === 0) {
                    feedbackList.innerHTML = '<p style="text-align: center; color: var(--text-color-secondary); padding: 50px;">No feedback found</p>';
                    return;
                }

                feedbackList.innerHTML = data.feedback.map(fb => {
                    const statusBadge = fb.status === 'new' ? '<span style="background: #ff4444; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">NEW</span>' :
                        fb.status === 'reviewed' ? '<span style="background: #ffaa00; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">REVIEWED</span>' :
                            fb.status === 'resolved' ? '<span style="background: #4CAF50; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">RESOLVED</span>' :
                                '<span style="background: #888; color: white; padding: 4px 8px; border-radius: 4px; font-size: 11px;">CLOSED</span>';

                    return `
                        <div style="border: 1px solid var(--border-color); border-radius: 8px; padding: 15px; margin-bottom: 15px; background: var(--container-bg);">
                            <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">
                                <div>
                                    <h3 style="margin: 0 0 5px 0; color: var(--text-color);">${fb.subject || 'No Subject'}</h3>
                                    <div style="font-size: 12px; color: var(--text-color-secondary);">
                                        <strong>Type:</strong> ${fb.feedback_type || 'N/A'} | 
                                        <strong>From:</strong> ${fb.name || 'Anonymous'} ${fb.email ? `(${fb.email})` : ''} | 
                                        <strong>Date:</strong> ${formatCSTTimestamp(fb.timestamp)}
                                    </div>
                                </div>
                                <div>
                                    ${statusBadge}
                                </div>
                            </div>
                            <div style="margin: 10px 0;">
                                <strong>Category:</strong> ${fb.category || 'N/A'} | 
                                <strong>Experience:</strong> ${fb.experience || 'N/A'}
                            </div>
                            <div style="background: var(--output-bg); padding: 10px; border-radius: 4px; margin: 10px 0; white-space: pre-wrap; font-family: monospace; font-size: 13px;">
                                ${fb.details || 'No details'}
                            </div>
                            ${fb.admin_notes ? `<div style="background: #fff3cd; padding: 10px; border-radius: 4px; margin: 10px 0; border-left: 3px solid #ffaa00;"><strong>Admin Notes:</strong> ${fb.admin_notes}</div>` : ''}
                            <div style="margin-top: 10px;">
                                <select id="statusSelect_${fb.id}" style="padding: 5px; margin-right: 10px;">
                                    <option value="new" ${fb.status === 'new' ? 'selected' : ''}>New</option>
                                    <option value="reviewed" ${fb.status === 'reviewed' ? 'selected' : ''}>Reviewed</option>
                                    <option value="resolved" ${fb.status === 'resolved' ? 'selected' : ''}>Resolved</option>
                                    <option value="closed" ${fb.status === 'closed' ? 'selected' : ''}>Closed</option>
                                </select>
                                <input type="text" id="adminNotes_${fb.id}" placeholder="Admin notes..." style="padding: 5px; width: 300px; margin-right: 10px;">
                                <button onclick="updateFeedbackStatus(${fb.id})" style="background: #2196F3; color: white; padding: 5px 15px; border: none; border-radius: 4px; cursor: pointer;">Update Status</button>
                            </div>
                        </div>
                    `;
                }).join('');

            } catch (error) {
                console.error('Error loading feedback:', error);
                document.getElementById('adminFeedbackList').innerHTML = `<p style="text-align: center; color: #ff4444; padding: 50px;">Error loading feedback: ${error.message}</p>`;
            }
        }

        window.updateFeedbackStatus = async function (feedbackId) {
            try {
                const token = localStorage.getItem('auth_token');
                const status = document.getElementById(`statusSelect_${feedbackId}`)?.value;
                const notes = document.getElementById(`adminNotes_${feedbackId}`)?.value;

                // Use relative URL so it works through the launcher proxy
                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                const response = await fetch(`${apiBase}/admin/feedback/${feedbackId}/status`, {
                    method: 'PUT',
                    headers: {
                        'Authorization': `Bearer ${token}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ status, admin_notes: notes })
                });

                if (!response.ok) {
                    throw new Error('Failed to update status');
                }

                alert('Feedback status updated successfully');
                loadAdminFeedback();
            } catch (error) {
                alert('Error updating feedback status: ' + error.message);
            }
        }

        window.exportAdminFeedback = async function () {
            try {
                const token = localStorage.getItem('auth_token');
                // Use relative URL so it works through the launcher proxy
                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                const response = await fetch(`${apiBase}/admin/feedback/export`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                if (!response.ok) {
                    if (response.status === 403) {
                        alert('Admin access required');
                        return;
                    }
                    throw new Error('Export failed');
                }

                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `feedback_export_${new Date().toISOString().split('T')[0]}.xlsx`;
                document.body.appendChild(a);
                a.click();
                window.URL.revokeObjectURL(url);
                document.body.removeChild(a);
            } catch (error) {
                alert('Error exporting feedback: ' + error.message);
            }
        }

        // Check admin access on page load and after login
        function checkAdminOnLoad() {
            // Check if user is logged in
            const token = localStorage.getItem('auth_token');
            if (token) {
                // Check immediately and also after a short delay
                checkAdminAccess();
                setTimeout(checkAdminAccess, 1000);
                setTimeout(checkAdminAccess, 3000); // Check again after 3 seconds in case backend is still starting
            }
        }

        // Make checkAdminAccess globally accessible
        window.checkAdminAccess = checkAdminAccess;

        if (typeof window !== 'undefined') {
            window.addEventListener('DOMContentLoaded', checkAdminOnLoad);
            // Also check when user info is updated (after login)
            const originalSetItem = Storage.prototype.setItem;
            Storage.prototype.setItem = function (key, value) {
                originalSetItem.call(this, key, value);
                if (key === 'auth_token' || key === 'user_info') {
                    // Check immediately and after delay
                    setTimeout(() => {
                        if (typeof checkAdminAccess === 'function') {
                            checkAdminAccess();
                        }
                    }, 500);
                    setTimeout(() => {
                        if (typeof checkAdminAccess === 'function') {
                            checkAdminAccess();
                        }
                    }, 2000);
                }
            };
        }

        function parseActivityDate(activity) {
            const unix = activity?.timestamp_unix ?? activity?.timestampUnix ?? null;
            if (Number.isFinite(unix)) {
                // Support seconds or milliseconds since epoch.
                const ms = unix < 1e12 ? unix * 1000 : unix;
                const du = new Date(ms);
                if (Number.isFinite(du.getTime())) return du;
            }

            let raw = activity?.timestamp || activity?.timestamp_iso || activity?.formattedTime || '';
            if (!raw) return null;
            raw = String(raw).trim().replace(/\s*\n\s*/g, ' ');

            // Backend emits ISO UTC in `timestamp` (preferred).
            const d1 = new Date(raw);
            if (Number.isFinite(d1.getTime())) return d1;

            // Fallbacks for non-ISO display timestamps.
            // Supported examples:
            // - 12/30/2025 11:38PM
            // - 12/30/2025 11:38 PM
            // - 12/30/2025 11:38:02 PM
            // - 12/30/2025 23:38
            const m = raw.match(/^(\d{1,2})\/(\d{1,2})\/(\d{4})\s+(\d{1,2}):(\d{2})(?::(\d{2}))?\s*(AM|PM)?$/i);
            if (m) {
                const month = Number.parseInt(m[1], 10);
                const day = Number.parseInt(m[2], 10);
                const year = Number.parseInt(m[3], 10);
                let hh = Number.parseInt(m[4], 10);
                const min = Number.parseInt(m[5], 10);
                const sec = m[6] ? Number.parseInt(m[6], 10) : 0;
                const ap = (m[7] || '').toUpperCase();
                if (ap) {
                    if (ap === 'PM' && hh < 12) hh += 12;
                    if (ap === 'AM' && hh === 12) hh = 0;
                }
                const d2 = new Date(year, month - 1, day, hh, min, sec, 0);
                if (Number.isFinite(d2.getTime())) return d2;
            }

            return null;
        }

        function formatYyyyMmDdLocal(date) {
            const yyyy = date.getFullYear();
            const mm = String(date.getMonth() + 1).padStart(2, '0');
            const dd = String(date.getDate()).padStart(2, '0');
            return `${yyyy}-${mm}-${dd}`;
        }

        function renderMonthlyTracker(activities) {
            const container = document.getElementById('logMonthlyTracker');
            const updated = document.getElementById('logMonthlyUpdated');
            const summary = document.getElementById('logMonthlySummary');
            if (updated) updated.textContent = new Date().toLocaleString();
            if (!container) return;

            const groups = new Map(); // key: YYYY-MM
            for (const a of activities || []) {
                const d = parseActivityDate(a);
                if (!d) continue;
                const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
                const g = groups.get(key) || { year: d.getFullYear(), monthIndex: d.getMonth(), success: 0, fail: 0, total: 0 };
                g.total += 1;
                const ok = !(a?.success === false || a?.success === 0);
                if (ok) g.success += 1;
                else g.fail += 1;
                groups.set(key, g);
            }

            if (groups.size === 0) {
                container.innerHTML = '<div class="monthly-help">No monthly activity data available for the current filters yet.</div>';
                if (summary) summary.textContent = '';
                return;
            }

            const rows = Array.from(groups.entries())
                .map(([key, g]) => ({ key, ...g }))
                .sort((a, b) => b.key.localeCompare(a.key))
                .slice(0, 12);

            const maxTotal = Math.max(...rows.map(r => r.total), 1);
            const scaleTotal = Math.max(100, maxTotal);
            const monthFmt = new Intl.DateTimeFormat(undefined, { month: 'short', year: 'numeric' });
            if (summary && rows[0]) {
                const latestLabel = monthFmt.format(new Date(rows[0].year, rows[0].monthIndex, 1));
                summary.textContent = `Latest: ${latestLabel}  Total ${rows[0].total}  Success ${rows[0].success}  Fail ${rows[0].fail}`;
            }

            container.innerHTML = '';
            for (const r of rows) {
                const label = monthFmt.format(new Date(r.year, r.monthIndex, 1));
                const successPct = r.total ? (r.success / r.total) * 100 : 0;
                const failPct = r.total ? (r.fail / r.total) * 100 : 0;
                const rowWidthPct = Math.min(100, Math.max(2, (r.total / scaleTotal) * 100));

                const rowEl = document.createElement('div');
                rowEl.className = 'monthly-row';
                rowEl.title = `Click to filter: ${label} (Success ${r.success}, Fail ${r.fail})`;
                rowEl.style.cursor = 'pointer';
                rowEl.addEventListener('click', () => window.applyLogMonthFilter?.(r.year, r.monthIndex));

                rowEl.innerHTML = `
                    <div class="monthly-label">${label}</div>
                    <div class="bar-track">
                        <div class="bar-fill" style="width: ${rowWidthPct}%;">
                            <div class="bar-success" style="width: ${successPct}%;"></div>
                            <div class="bar-fail" style="width: ${failPct}%;"></div>
                        </div>
                    </div>
                    <div class="monthly-count">${r.total}</div>
                `;
                container.appendChild(rowEl);
            }
        }

        function renderHomeMonthlyTracker(activities) {
            const container = document.getElementById('homeMonthlyTracker');
            const updated = document.getElementById('homeMonthlyUpdated');
            const summary = document.getElementById('homeMonthlySummary');
            if (updated) updated.textContent = new Date().toLocaleString();
            if (!container) return;

            const groups = new Map(); // key: YYYY-MM
            for (const a of activities || []) {
                const d = parseActivityDate(a);
                if (!d) continue;
                const key = `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`;
                const g = groups.get(key) || { year: d.getFullYear(), monthIndex: d.getMonth(), success: 0, fail: 0, total: 0 };
                g.total += 1;
                const ok = !(a?.success === false || a?.success === 0);
                if (ok) g.success += 1;
                else g.fail += 1;
                groups.set(key, g);
            }

            if (groups.size === 0) {
                container.innerHTML = '<div class="monthly-help">No monthly activity data available yet.</div>';
                if (summary) summary.textContent = '';
                return;
            }

            const rows = Array.from(groups.entries())
                .map(([key, g]) => ({ key, ...g }))
                .sort((a, b) => b.key.localeCompare(a.key))
                .slice(0, 12);

            const maxTotal = Math.max(...rows.map(r => r.total), 1);
            const scaleTotal = Math.max(100, maxTotal);
            const monthFmt = new Intl.DateTimeFormat(undefined, { month: 'short', year: 'numeric' });
            if (summary && rows[0]) {
                const latestLabel = monthFmt.format(new Date(rows[0].year, rows[0].monthIndex, 1));
                summary.textContent = `Latest: ${latestLabel}  Total ${rows[0].total}  Success ${rows[0].success}  Fail ${rows[0].fail}`;
            }

            container.innerHTML = '';
            for (const r of rows) {
                const label = monthFmt.format(new Date(r.year, r.monthIndex, 1));
                const successPct = r.total ? (r.success / r.total) * 100 : 0;
                const failPct = r.total ? (r.fail / r.total) * 100 : 0;
                const rowWidthPct = Math.min(100, Math.max(2, (r.total / scaleTotal) * 100));

                const rowEl = document.createElement('div');
                rowEl.className = 'monthly-row';
                rowEl.title = `Click to filter log history: ${label} (Success ${r.success}, Fail ${r.fail})`;
                rowEl.style.cursor = 'pointer';
                rowEl.addEventListener('click', () => {
                    try {
                        if (typeof window.navigateToTab === 'function') window.navigateToTab('log-history');
                        setTimeout(() => window.applyLogMonthFilter?.(r.year, r.monthIndex), 150);
                    } catch (e) {
                        console.error('[MONTHLY] Failed to navigate to Log History', e);
                    }
                });

                rowEl.innerHTML = `
                    <div class="monthly-label">${label}</div>
                    <div class="bar-track">
                        <div class="bar-fill" style="width: ${rowWidthPct}%;">
                            <div class="bar-success" style="width: ${successPct}%;"></div>
                            <div class="bar-fail" style="width: ${failPct}%;"></div>
                        </div>
                    </div>
                    <div class="monthly-count">${r.total}</div>
                `;
                container.appendChild(rowEl);
            }
        }

        window.applyLogMonthFilter = function (year, monthIndex) {
            const from = document.getElementById('logDateFrom');
            const to = document.getElementById('logDateTo');
            if (!from || !to) return;

            const first = new Date(year, monthIndex, 1);
            const last = new Date(year, monthIndex + 1, 0);
            from.value = formatYyyyMmDdLocal(first);
            to.value = formatYyyyMmDdLocal(last);
            if (typeof window.loadLogHistory === 'function') window.loadLogHistory();
        };

        window.loadLogHistory = async function () {
            try {
                const tableBody = document.getElementById('logHistoryTableBody');
                if (!tableBody) {
                    console.warn('[LOG HISTORY] Table body not found');
                    return;
                }

                tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 20px; color: var(--text-color-secondary);">Loading log history...</td></tr>';

                console.log('[LOG HISTORY] Fetching activity logs from backend...');
                // Use AI_API_BASE if defined, otherwise construct it
                const apiBase = resolveApiBase();
                const response = await fetch(`${apiBase}/get-activity?limit=1000&all=true`);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[LOG HISTORY] Response received:', data);

                if (data.success && data.activities && Array.isArray(data.activities)) {
                    const userFilter = (document.getElementById('logUserFilter')?.value || '').toLowerCase();
                    const typeFilter = document.getElementById('logTypeFilter')?.value || '';
                    const dateFrom = document.getElementById('logDateFrom')?.value || '';
                    const dateTo = document.getElementById('logDateTo')?.value || '';

                    // Base filters (used for both tracker + table).
                    let baseFiltered = data.activities;
                    if (userFilter) {
                        baseFiltered = baseFiltered.filter(a => (a?.username || '').toLowerCase().includes(userFilter));
                    }
                    if (typeFilter) {
                        baseFiltered = baseFiltered.filter(a => a?.type === typeFilter);
                    }

                    // Render monthly overview (ignores dateFrom/dateTo so it remains useful as a filter tool).
                    renderMonthlyTracker(baseFiltered);

                    // Date range filter (table only).
                    let tableFiltered = baseFiltered;
                    const fromDate = dateFrom ? new Date(`${dateFrom}T00:00:00`) : null;
                    const toDate = dateTo ? new Date(`${dateTo}T23:59:59`) : null;

                    if (fromDate && Number.isFinite(fromDate.getTime())) {
                        tableFiltered = tableFiltered.filter(a => {
                            const d = parseActivityDate(a);
                            return d ? d >= fromDate : true;
                        });
                    }
                    if (toDate && Number.isFinite(toDate.getTime())) {
                        tableFiltered = tableFiltered.filter(a => {
                            const d = parseActivityDate(a);
                            return d ? d <= toDate : true;
                        });
                    }

                    if (tableFiltered.length === 0) {
                        tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 50px; color: var(--text-color-secondary);">No logs found matching filters</td></tr>';
                        return;
                    }

                      tableBody.innerHTML = tableFiltered.map(activity => {
                          const successFlag = activity.success === true;
                          const failureFlag = activity.success === false;
                          const statusIcon = successFlag ? 'OK' : (failureFlag ? 'X' : '-');
                          const statusColor = successFlag ? '#4CAF50' : (failureFlag ? '#dc3545' : '#888');

                          return `
                      <tr style="border-bottom: 1px solid var(--border-color);">
                          <td style="padding: 12px;">${activity.formattedTime || activity.timestamp}</td>
                          <td style="padding: 12px; font-weight: 600;">${formatUsernameDisplay(activity.username)}</td>
                          <td style="padding: 12px;">${sanitizeActivityText(activity.message || `${activity.type} - ${activity.siteName || 'N/A'}`)}</td>
                          <td style="padding: 12px;">${activity.siteName || 'N/A'} ${activity.device ? `(${activity.device})` : ''}</td>
                          <td style="padding: 12px;">${activity.routeros || 'N/A'}</td>
                          <td style="padding: 12px; text-align: center; color: ${statusColor}; font-weight: bold;">${statusIcon}</td>
                      </tr>
                  `;
                      }).join('');
                } else {
                    console.warn('[LOG HISTORY] No activities in response or invalid format:', data);
                    tableBody.innerHTML = '<tr><td colspan="6" style="text-align: center; padding: 50px; color: var(--text-color-secondary);">No activity logs found. Activities will appear here as you generate configurations.</td></tr>';
                }
            } catch (error) {
                console.error('[LOG HISTORY] Error loading logs:', error);
                const tableBody = document.getElementById('logHistoryTableBody');
                if (tableBody) {
                    tableBody.innerHTML = `<tr><td colspan="6" style="text-align: center; padding: 50px; color: #dc3545;">Error loading log history: ${error.message}<br><small style="color: #888; margin-top: 10px; display: block;">Make sure the backend server is running on port 5000</small></td></tr>`;
                }
            }
        };

        window.exportLogHistory = async function () {
            try {
                const apiBase = resolveApiBase();
                const response = await fetch(`${apiBase}/get-activity?limit=10000&all=true`);
                const data = await response.json();

                if (data.success && data.activities) {
                    // Convert to CSV
                      const headers = ['Timestamp', 'User', 'Type', 'Site/Device', 'Firmware', 'Status'];
                    const rows = data.activities.map(a => [
                        a.timestamp,
                        a.username,
                        a.type,
                        `${a.siteName || ''} ${a.device || ''}`.trim(),
                        a.routeros || '',
                        a.success ? 'Success' : 'Failed'
                    ]);

                    const csv = [
                        headers.join(','),
                        ...rows.map(r => r.map(cell => `"${cell}"`).join(','))
                    ].join('\n');

                    // Download
                    const blob = new Blob([csv], { type: 'text/csv' });
                    const url = window.URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `noc-activity-logs-${new Date().toISOString().split('T')[0]}.csv`;
                    a.click();
                    window.URL.revokeObjectURL(url);
                }
            } catch (error) {
                console.error('[LOG HISTORY] Export error:', error);
                alert('Failed to export log history');
            }
        };

        // Password Change Modal Functions
        function openPasswordChangeModal() {
            const modal = document.getElementById('passwordChangeModal');
            if (modal) {
                modal.style.display = 'block';
                // Clear form
                document.getElementById('passwordChangeForm').reset();
                document.getElementById('passwordChangeError').style.display = 'none';
                document.getElementById('passwordChangeSuccess').style.display = 'none';
            }
        }

        function closePasswordChangeModal() {
            const modal = document.getElementById('passwordChangeModal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        async function handlePasswordChangeFromSettings(event) {
            event.preventDefault();

            const currentPassword = document.getElementById('settingsCurrentPassword').value;
            const newPassword = document.getElementById('settingsNewPassword').value;
            const confirmPassword = document.getElementById('settingsConfirmPassword').value;
            const errorDiv = document.getElementById('passwordChangeError');
            const successDiv = document.getElementById('passwordChangeSuccess');
            const submitBtn = document.getElementById('passwordChangeSubmitBtn');

            // Validation
            if (newPassword.length < 8) {
                errorDiv.textContent = 'Password must be at least 8 characters long';
                errorDiv.style.display = 'block';
                successDiv.style.display = 'none';
                return;
            }

            if (newPassword !== confirmPassword) {
                errorDiv.textContent = 'New passwords do not match';
                errorDiv.style.display = 'block';
                successDiv.style.display = 'none';
                return;
            }

            submitBtn.disabled = true;
            submitBtn.textContent = 'Changing password...';
            errorDiv.style.display = 'none';
            successDiv.style.display = 'none';

            try {
                const token = localStorage.getItem('auth_token');
                if (!token) {
                    throw new Error('Not authenticated. Please log in again.');
                }

                const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                const response = await fetch(`${apiBase}/auth/change-password`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${token}`
                    },
                    body: JSON.stringify({
                        currentPassword: currentPassword,
                        newPassword: newPassword
                    })
                });

                const data = await response.json();

                if (response.ok && data.success) {
                    successDiv.textContent = 'Password changed successfully!';
                    successDiv.style.display = 'block';
                    document.getElementById('passwordChangeForm').reset();

                    setTimeout(() => {
                        closePasswordChangeModal();
                    }, 2000);
                } else {
                    throw new Error(data.error || 'Failed to change password');
                }
            } catch (error) {
                console.error('Password Change Error:', error);
                errorDiv.textContent = error.message || 'Failed to change password. Please try again.';
                errorDiv.style.display = 'block';
            } finally {
                submitBtn.disabled = false;
                submitBtn.textContent = 'Change Password';
            }
        }

        // Auto-load configs when Completed Configs tab is opened
        document.addEventListener('DOMContentLoaded', function () {
            // Update user display
            updateUserDisplay();

            // Wait for tab system to initialize
            setTimeout(() => {
                const completedConfigsTab = document.querySelector('.nav-item[data-tab="completed-configs"]');
                if (completedConfigsTab) {
                    completedConfigsTab.addEventListener('click', function () {
                        setTimeout(loadCompletedConfigs, 100);
                    });
                }

                // Set up log history tab auto-load
                const logHistoryTab = document.querySelector('.nav-item[data-tab="log-history"]');
                if (logHistoryTab) {
                    logHistoryTab.addEventListener('click', function () {
                        setTimeout(() => {
                            if (typeof window.loadLogHistory === 'function') {
                                window.loadLogHistory();
                            }
                        }, 100);
                    });
                }

                // If log-history pane is already visible, load it
                const logHistoryPane = document.getElementById('log-history-pane');
                if (logHistoryPane && logHistoryPane.classList.contains('active')) {
                    setTimeout(() => {
                        if (typeof window.loadLogHistory === 'function') {
                            window.loadLogHistory();
                        }
                    }, 200);
                }

                // Initialize dashboard metrics and recent activity on page load
                setTimeout(() => {
                    if (typeof window.updateDashboardMetrics === 'function') {
                        window.updateDashboardMetrics();
                    }
                    if (typeof window.updateRecentActivity === 'function') {
                        window.updateRecentActivity();
                    }
                }, 600);

                // Set up home tab auto-refresh
                const homeTab = document.querySelector('.nav-item[data-tab="home"]');
                if (homeTab) {
                    homeTab.addEventListener('click', function () {
                        setTimeout(() => {
                            if (typeof window.updateDashboardMetrics === 'function') {
                                window.updateDashboardMetrics();
                            }
                            if (typeof window.updateRecentActivity === 'function') {
                                window.updateRecentActivity();
                            }
                        }, 100);
                    });
                }
            }, 500);

            // ========================================
            // LIVE PROGRESS TRACKER (MUSHU-STYLE)
            // ========================================

            let progressTrackerStartTime = null;
            let progressTrackerInterval = null;

            function resolveProgressTrackerRoot() {
                const activePane = document.querySelector('.content-pane.active');
                if (!activePane) return null;

                if (activePane.id === 'tower-pane') {
                    const upgradeMode = document.getElementById('upgradeMode');
                    const mainForm = document.getElementById('mainForm');
                    const upgradeVisible = upgradeMode && window.getComputedStyle(upgradeMode).display !== 'none';
                    return upgradeVisible ? upgradeMode : (mainForm || activePane);
                }

                return activePane;
            }

            function repositionProgressTracker() {
                const tracker = document.getElementById('progressTracker');
                if (!tracker || !tracker.classList.contains('active')) return;

                const root = resolveProgressTrackerRoot();
                if (!root) return;

                if (root.id === 'ftth-pane') {
                    const anchor = root.querySelector('#ftth_progress_anchor');
                    if (anchor && anchor.parentNode && anchor.nextSibling !== tracker) {
                        anchor.parentNode.insertBefore(tracker, anchor.nextSibling);
                        return;
                    }
                }

                const generateBtn = root.querySelector('button[onclick*="generate"], button[onclick*="Generate"], button[id*="generate"], button[id*="Generate"]') ||
                    Array.from(root.querySelectorAll('button')).find(btn =>
                        btn.textContent && btn.textContent.toLowerCase().includes('generate')
                    );

                if (generateBtn && generateBtn.parentElement) {
                    const container = generateBtn.closest('.section, div') || generateBtn.parentElement;
                    if (container && container.parentNode && container.nextSibling !== tracker) {
                        container.parentNode.insertBefore(tracker, container.nextSibling);
                        return;
                    }
                }

                if (root.firstChild) {
                    root.insertBefore(tracker, root.firstChild);
                } else {
                    root.appendChild(tracker);
                }
            }

            window.repositionProgressTracker = repositionProgressTracker;

            window.showProgressTracker = function (title = 'Configuration In Progress') {
                const tracker = document.getElementById('progressTracker');
                const titleEl = document.getElementById('progressTrackerTitle');
                const logContent = document.getElementById('progressLogContent');

                if (titleEl) titleEl.textContent = title;
                if (logContent) logContent.innerHTML = '';

                progressTrackerStartTime = Date.now();
                updateProgressPercent(0);
                updateProgressStep('Initializing...');

                if (tracker) {
                    // Remove collapsed state when showing
                    tracker.classList.remove('collapsed');
                    tracker.classList.add('active');

                    // Update collapse toggle text
                    const collapseToggle = document.getElementById('progressCollapseToggle');
                    if (collapseToggle) collapseToggle.textContent = ' Collapse';

                    // Place tracker near the active mode's Generate button.
                    repositionProgressTracker();
                }

                // Start elapsed time counter
                if (progressTrackerInterval) clearInterval(progressTrackerInterval);
                progressTrackerInterval = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - progressTrackerStartTime) / 1000);
                    const elapsedEl = document.getElementById('progressElapsed');
                    if (elapsedEl) {
                        const mins = Math.floor(elapsed / 60);
                        const secs = elapsed % 60;
                        elapsedEl.textContent = mins > 0 ? `Elapsed ${mins}m ${secs}s` : `Elapsed ${secs}s`;
                    }
                }, 1000);

                addProgressLog('info', 'Configuration generation started');
            };

            window.updateProgressStep = function (step) {
                const stepEl = document.getElementById('progressCurrentStep');
                if (stepEl) stepEl.textContent = step;
            };

            window.updateProgressPercent = function (percent) {
                const percentEl = document.getElementById('progressPercent');
                const barFill = document.getElementById('progressBarFill');

                if (percentEl) percentEl.textContent = Math.round(percent);
                if (barFill) barFill.style.width = percent + '%';
            };

            window.addProgressLog = function (type, message) {
                const logContent = document.getElementById('progressLogContent');
                if (!logContent) return;

                const timestamp = new Date().toLocaleTimeString();
                const icons = {
                    info: '',
                    success: '',
                    warning: '',
                    error: ''
                };

                const logEntry = document.createElement('div');
                logEntry.className = `log-entry ${type}`;
                logEntry.innerHTML = `
            <span class="log-icon">${icons[type] || ''}</span>
            <span class="log-timestamp">${timestamp}</span>
            <span>${message}</span>
        `;

                logContent.appendChild(logEntry);
                logContent.scrollTop = logContent.scrollHeight; // Auto-scroll to bottom
            };

            window.completeProgressTracker = function (success = true) {
                const badge = document.getElementById('progressStatusBadge');
                if (badge) {
                    badge.className = `status-badge ${success ? 'completed' : 'error'}`;
                    badge.textContent = success ? 'COMPLETED' : 'FAILED';
                }

                updateProgressPercent(100);
                if (progressTrackerInterval) {
                    clearInterval(progressTrackerInterval);
                    progressTrackerInterval = null;
                }

                if (success) {
                    addProgressLog('success', 'Configuration generated successfully!');
                } else {
                    addProgressLog('error', 'Configuration generation failed');
                }

                // DON'T hide the tracker - let user see completion status and close manually
                // The tracker stays visible showing COMPLETED or FAILED status
            };

            window.closeProgressTracker = function () {
                const tracker = document.getElementById('progressTracker');
                if (tracker) tracker.classList.remove('active');

                if (progressTrackerInterval) {
                    clearInterval(progressTrackerInterval);
                    progressTrackerInterval = null;
                }
            };

            window.toggleProgressTrackerCollapse = function () {
                const tracker = document.getElementById('progressTracker');
                const toggle = document.getElementById('progressCollapseToggle');

                if (!tracker || !toggle) return;

                if (tracker.classList.contains('collapsed')) {
                    // Expand
                    tracker.classList.remove('collapsed');
                    toggle.textContent = ' Collapse';
                } else {
                    // Collapse
                    tracker.classList.add('collapsed');
                    toggle.textContent = ' Expand';
                }
            };

            window.toggleProgressLog = function () {
                const logContent = document.getElementById('progressLogContent');
                const toggle = document.getElementById('progressLogToggle');

                if (!logContent || !toggle) return;

                if (logContent.classList.contains('expanded')) {
                    logContent.classList.remove('expanded');
                    toggle.textContent = ' EXPAND LOG';
                } else {
                    logContent.classList.add('expanded');
                    toggle.textContent = ' COLLAPSE LOG';
                }
            };

            // Integration function for simulating progress steps
            window.simulateProgress = function (steps, currentStep) {
                const percent = (currentStep / steps) * 100;
                updateProgressPercent(percent);
            };

            // Navigate to activity details
            window.navigateToActivity = function (type, activityId) {
                console.log(`[NAVIGATE] Type: ${type}, ID: ${activityId}`);

                // Always navigate to Log History tab when clicking recent activity
                navigateToTab('log-history');

                // Optionally scroll to the specific activity if needed
                setTimeout(() => {
                    if (activityId) {
                        // Try to highlight or scroll to the specific activity in log history
                        const activityElement = document.querySelector(`[data-activity-id="${activityId}"]`);
                        if (activityElement) {
                            activityElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            activityElement.style.backgroundColor = 'rgba(230, 126, 34, 0.2)';
                            setTimeout(() => {
                                activityElement.style.backgroundColor = '';
                            }, 2000);
                        }
                    }
                }, 300);
            };

            // ========================================
            // NOKIA 7250 MAKER FUNCTIONS
            // ========================================

            window.addBackhaul = function () {
                const container = document.getElementById('nokia7250_backhauls');
                const entry = document.createElement('div');
                entry.className = 'backhaul-entry';
                entry.style.cssText = 'margin-bottom: 15px; padding: 15px; background: var(--card-bg); border-radius: 4px;';
                entry.innerHTML = `
            <div class="form-group">
                <label>Backhaul Name:</label>
                <input type="text" class="backhaul-name" placeholder="TX-BRADSTEST-EA-1" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
            </div>
            <div class="form-group">
                <label>Backhaul IP/Netmask:</label>
                <input type="text" class="backhaul-ip" placeholder="10.10.10.49/29" style="width: 100%; padding: 10px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--input-bg); color: var(--text-color);">
            </div>
            <button type="button" onclick="removeBackhaul(this)" style="background: #dc3545; color: white; padding: 5px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">Remove</button>
        `;
                container.appendChild(entry);
            };

            window.removeBackhaul = function (btn) {
                btn.closest('.backhaul-entry').remove();
            };

            // Toggle fiber interface fields
            document.addEventListener('DOMContentLoaded', function () {
                const fiberCheckbox = document.getElementById('nokia7250_enableFiber');
                if (fiberCheckbox) {
                    fiberCheckbox.addEventListener('change', function () {
                        const fiberGroup = document.getElementById('nokia7250_fiberGroup');
                        const fiberIPGroup = document.getElementById('nokia7250_fiberIPGroup');
                        if (fiberGroup && fiberIPGroup) {
                            fiberGroup.style.display = this.checked ? 'block' : 'none';
                            fiberIPGroup.style.display = this.checked ? 'block' : 'none';
                        }
                    });
                }
            });

            window.generateNokia7250Config = async function () {
                const systemName = document.getElementById('nokia7250_systemName').value.trim();
                const systemIP = document.getElementById('nokia7250_systemIP').value.trim();
                const location = document.getElementById('nokia7250_location').value.trim();
                const port1Desc = document.getElementById('nokia7250_port1_desc').value.trim() || 'Switch';
                const port2Desc = document.getElementById('nokia7250_port2_desc').value.trim() || 'Switch';
                const port2Shutdown = document.getElementById('nokia7250_port2_shutdown').checked;
                const enableOSPF = document.getElementById('nokia7250_enableOSPF').checked;
                const enableBGP = document.getElementById('nokia7250_enableBGP').checked;

                console.log('[NOKIA7250] Generate button clicked');

                // Validation
                if (!systemName || !systemIP) {
                    console.warn('[NOKIA7250] Validation failed: Missing system name or IP');
                    alert(' Please fill in System Name and System IP');
                    return;
                }

                // Collect backhauls (required - at least one must be configured)
                const backhaulEntries = document.querySelectorAll('.backhaul-entry');
                const backhauls = [];
                for (const entry of backhaulEntries) {
                    const name = entry.querySelector('.backhaul-name').value.trim();
                    const ip = entry.querySelector('.backhaul-ip').value.trim();
                    if (name && ip) {
                        backhauls.push({ name, ip });
                    }
                }

                if (backhauls.length === 0) {
                    console.warn('[NOKIA7250] Validation failed: No backhauls configured');
                    alert(' At least one backhaul is required. Please configure at least one backhaul in Port Configuration.');
                    return;
                }

                console.log('[NOKIA7250] Validation passed:', {
                    systemName: systemName,
                    systemIP: systemIP,
                    backhaulCount: backhauls.length,
                    enableOSPF: enableOSPF,
                    enableBGP: enableBGP
                });

                // Auto-filled for IN-STATE configs (user doesn't need to fill these)
                const bgpGroup = 'DALLAS-RR';  // Auto-configured for instate
                const bgpNeighbors = ['10.2.0.107', '10.2.0.108'];  // Auto-configured for instate
                const vplsServices = ['1245', '2245', '3245', '4245'];  // Auto-configured for instate
                // SDP 101 and 102 are handled automatically in backend (no user input needed)
                const enableFiber = document.getElementById('nokia7250_enableFiber') ? document.getElementById('nokia7250_enableFiber').checked : false;
                const fiberInterfaceEl = document.getElementById('nokia7250_fiber_interface');
                const fiberIPEl = document.getElementById('nokia7250_fiber_ip');
                const fiberInterface = (fiberInterfaceEl && fiberInterfaceEl.value.trim()) || 'FIBERCOMM';
                const fiberIP = (fiberIPEl && fiberIPEl.value.trim()) || '';

                try {
                    console.log('[NOKIA7250] Starting configuration generation...');
                    if (window.showProgressTracker) window.showProgressTracker('Generating Nokia 7250 Configuration');
                    if (window.updateProgressStep) window.updateProgressStep('Sending request to backend...');
                    if (window.updateProgressPercent) window.updateProgressPercent(10);

                    const requestData = {
                        system_name: systemName,
                        system_ip: systemIP,
                        location: location,
                        port1_desc: port1Desc,
                        port2_desc: port2Desc,
                        port2_shutdown: port2Shutdown,
                        enable_ospf: enableOSPF,
                        enable_bgp: enableBGP,
                        bgp_group: bgpGroup,
                        bgp_neighbors: bgpNeighbors,
                        vpls_services: vplsServices,
                        // SDP 101 and 102 are automatically configured in backend
                        enable_fiber: enableFiber,
                        fiber_interface: fiberInterface,
                        fiber_ip: fiberIP,
                        backhauls: backhauls
                    };

                    console.log('[NOKIA7250] Sending request to:', `${AI_API_BASE}/generate-nokia7250`);
                    console.log('[NOKIA7250] Request data (sanitized):', {
                        ...requestData,
                        backhauls: requestData.backhauls.map(bh => ({ name: bh.name, ip: '[REDACTED]' }))
                    });

                    const response = await fetch(`${AI_API_BASE}/generate-nokia7250`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(requestData)
                    });

                    console.log('[NOKIA7250] Response status:', response.status, response.statusText);

                    if (window.updateProgressPercent) window.updateProgressPercent(60);
                    if (window.updateProgressStep) window.updateProgressStep('Processing configuration...');

                    if (!response.ok) {
                        const errorData = await response.json().catch(() => ({ error: 'Unknown error' }));
                        console.error('[NOKIA7250] Backend error:', errorData);
                        throw new Error(errorData.error || `HTTP ${response.status}: ${response.statusText}`);
                    }

                    const data = await response.json();
                    console.log('[NOKIA7250] Response received, config length:', data.config ? data.config.length : 0);

                    if (window.updateProgressPercent) window.updateProgressPercent(90);
                    if (window.updateProgressStep) window.updateProgressStep('Finalizing...');

                    if (data.config) {
                        document.getElementById('nokia7250_config_output').value = data.config;
                        document.getElementById('nokia7250_output').style.display = 'block';
                        if (window.updateProgressPercent) window.updateProgressPercent(100);
                        if (window.updateProgressStep) window.updateProgressStep('Configuration generated successfully!');
                        if (window.completeProgressTracker) window.completeProgressTracker(true);
                        console.log('[NOKIA7250]  Configuration generated successfully');
                    } else {
                        console.error('[NOKIA7250] No configuration in response:', data);
                        throw new Error('No configuration returned from backend');
                    }
                } catch (error) {
                    console.error('[NOKIA7250]  Error generating configuration:', {
                        message: error.message,
                        stack: error.stack,
                        name: error.name
                    });
                    alert(' Error generating configuration: ' + error.message);
                    if (window.completeProgressTracker) window.completeProgressTracker(false);
                }
            };

            window.copyNokia7250Config = function () {
                const textarea = document.getElementById('nokia7250_config_output');
                const text = textarea.value;
                if (!text) {
                    alert('No configuration to copy!');
                    return;
                }
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        alert(' Configuration copied to clipboard');
                    }).catch(() => {
                        textarea.select();
                        document.execCommand('copy');
                        alert('Copied to clipboard.');
                    });
                } else {
                    textarea.select();
                    document.execCommand('copy');
                    alert('Copied to clipboard.');
                }
            };

            window.downloadNokia7250Config = function () {
                const textarea = document.getElementById('nokia7250_config_output');
                const config = textarea.value;
                if (!config) {
                    alert('No configuration to download!');
                    return;
                }
                const systemName = document.getElementById('nokia7250_systemName').value.trim() || 'nokia7250';
                const ts = new Date().toISOString().split('T')[0];
                const blob = new Blob([config.replace(/\r?\n/g, '\n')], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `${systemName}-${ts}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            };

            // ========================================
            // NOKIA MIGRATION FUNCTIONS
            // ========================================

            window.fetchMikrotikConfigForNokiaMigration = async function () {
                const deviceIP = document.getElementById('nokia_migration_device_ip').value.trim();
                const rosVersion = document.getElementById('nokia_migration_ros_version').value;
                const statusDiv = document.getElementById('nokia_migration_ssh_status');
                const sshUsername = (document.getElementById('nokia_ssh_username')?.value || '').trim() ||
                    (document.getElementById('sshUsername')?.value || '').trim();
                const sshPassword = (document.getElementById('nokia_ssh_password')?.value || '') ||
                    (document.getElementById('sshPassword')?.value || '');
                const sshPorts = parseSshPorts(
                    (document.getElementById('nokia_ssh_ports')?.value || '').trim() ||
                    (document.getElementById('sshPorts')?.value || '').trim()
                );

                if (!deviceIP) {
                    statusDiv.style.display = 'block';
                    statusDiv.style.background = '#dc3545';
                    statusDiv.style.color = 'white';
                    statusDiv.style.padding = '10px';
                    statusDiv.style.borderRadius = '4px';
                    statusDiv.textContent = ' Please enter device IP address';
                    return;
                }

                if (!sshUsername || !sshPassword) {
                    statusDiv.style.display = 'block';
                    statusDiv.style.background = '#dc3545';
                    statusDiv.style.color = 'white';
                    statusDiv.style.padding = '10px';
                    statusDiv.style.borderRadius = '4px';
                    statusDiv.textContent = ' SSH credentials required. Enter username/password or configure NEXTLINK_SSH_USERNAME and NEXTLINK_SSH_PASSWORD on the server.';
                    return;
                }

                try {
                    statusDiv.style.display = 'block';
                    statusDiv.style.background = '#2196F3';
                    statusDiv.style.color = 'white';
                    statusDiv.style.padding = '10px';
                    statusDiv.style.borderRadius = '4px';
                    statusDiv.textContent = ` Connecting via SSH (trying ports: ${sshPorts.join(', ')})...`;

                    if (window.showProgressTracker) window.showProgressTracker('Fetching Config for Nokia Migration');
                    if (window.updateProgressStep) window.updateProgressStep('Connecting to device via SSH...');
                    if (window.updateProgressPercent) window.updateProgressPercent(10);

                    const response = await fetch(`${AI_API_BASE}/fetch-config-ssh`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            host: deviceIP,
                            ros_version: rosVersion,
                            command: 'export',
                            username: sshUsername,
                            password: sshPassword,
                            ports: sshPorts
                        })
                    });

                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                        throw new Error(error.error || `HTTP ${response.status}`);
                    }

                    const data = await response.json();

                    if (data.config) {
                        // Normalize and set the config in the textarea
                        const normalizedConfig = data.config.replace(/\\\s*\n/g, '\n');
                        document.getElementById('mikrotik_nokia_source').value = normalizedConfig;

                        statusDiv.style.background = '#4CAF50';
                        statusDiv.textContent = ` Config fetched successfully from ${deviceIP}:${data.port || '22/5022'}`;

                        if (window.updateProgressPercent) window.updateProgressPercent(100);
                        if (window.updateProgressStep) window.updateProgressStep('Config fetched successfully!');
                        if (window.completeProgressTracker) window.completeProgressTracker(true);
                    } else {
                        throw new Error('No configuration returned from device');
                    }
                } catch (error) {
                    console.error('Error fetching config:', error);
                    statusDiv.style.background = '#dc3545';
                    statusDiv.textContent = ' Error: ' + error.message;
                    if (window.completeProgressTracker) window.completeProgressTracker(false);
                }
            };

            window.convertMikrotikToNokia = async function () {
                const sourceConfig = document.getElementById('mikrotik_nokia_source').value.trim();
                const preserveIPs = document.getElementById('mikrotik_nokia_preserve_ips').checked;

                if (!sourceConfig) {
                    alert(' Please fetch config via SSH or paste a MikroTik RouterOS configuration');
                    return;
                }

                try {
                    if (window.showProgressTracker) window.showProgressTracker('Converting MikroTik to Nokia');
                    if (window.updateProgressStep) window.updateProgressStep('Analyzing source configuration...');
                    if (window.updateProgressPercent) window.updateProgressPercent(10);

                    const response = await fetch(`${AI_API_BASE}/migrate-mikrotik-to-nokia`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            source_config: sourceConfig,
                            preserve_ips: preserveIPs
                        })
                    });

                    if (window.updateProgressPercent) window.updateProgressPercent(50);
                    if (window.updateProgressStep) window.updateProgressStep('Converting syntax and commands...');

                    if (!response.ok) {
                        const error = await response.json().catch(() => ({ error: 'Unknown error' }));
                        throw new Error(error.error || `HTTP ${response.status}`);
                    }

                    const data = await response.json();
                    if (window.updateProgressPercent) window.updateProgressPercent(90);
                    if (window.updateProgressStep) window.updateProgressStep('Finalizing conversion...');

                    if (data.nokia_config) {
                        document.getElementById('mikrotik_nokia_config_output').value = data.nokia_config;
                        document.getElementById('mikrotik_nokia_output').style.display = 'block';
                        if (data.warning) {
                            console.warn('[NOKIA MIGRATION] Warning:', data.warning);
                            alert(`Note: ${data.warning}`);
                        }
                        if (window.updateProgressPercent) window.updateProgressPercent(100);
                        if (window.updateProgressStep) window.updateProgressStep('Conversion completed successfully!');
                        if (window.completeProgressTracker) window.completeProgressTracker(true);
                    } else {
                        throw new Error('No Nokia configuration returned from backend');
                    }
                } catch (error) {
                    console.error('Error converting MikroTik to Nokia:', error);
                    alert(' Error converting configuration: ' + error.message);
                    if (window.completeProgressTracker) window.completeProgressTracker(false);
                }
            };

            window.copyMikrotikNokiaConfig = function () {
                const textarea = document.getElementById('mikrotik_nokia_config_output');
                const text = textarea.value;
                if (!text) {
                    alert('No configuration to copy!');
                    return;
                }
                if (navigator.clipboard && window.isSecureContext) {
                    navigator.clipboard.writeText(text).then(() => {
                        alert(' Configuration copied to clipboard');
                    }).catch(() => {
                        textarea.select();
                        document.execCommand('copy');
                        alert('Copied to clipboard.');
                    });
                } else {
                    textarea.select();
                    document.execCommand('copy');
                    alert('Copied to clipboard.');
                }
            };

            window.downloadMikrotikNokiaConfig = function () {
                const textarea = document.getElementById('mikrotik_nokia_config_output');
                const config = textarea.value;
                if (!config) {
                    alert('No configuration to download!');
                    return;
                }
                const ts = new Date().toISOString().split('T')[0];
                const blob = new Blob([config.replace(/\r?\n/g, '\n')], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `nokia-migrated-${ts}.txt`;
                a.click();
                URL.revokeObjectURL(url);
            };
        });
    </script>

    <!-- Live Progress Tracker (MUSHU-style) -->
    <div id="progressTracker" class="progress-tracker">
        <div class="progress-header" onclick="toggleProgressTrackerCollapse()">
            <div class="progress-title" id="progressTrackerTitle">Configuration In Progress</div>
            <div class="progress-status" style="display: flex; align-items: center; gap: 10px;">
                <span class="status-badge in-progress" id="progressStatusBadge">IN PROGRESS</span>
                <span style="color: #888; font-size: 11px;" id="progressCollapseToggle"> Collapse</span>
            </div>
        </div>

        <div class="progress-bar-container">
            <div class="progress-bar-fill" id="progressBarFill"></div>
        </div>

        <div class="progress-details">
            <div class="progress-current-step" id="progressCurrentStep">
                Initializing configuration generator...
            </div>
            <div style="display: flex; align-items: center; gap: 15px;">
                <div class="progress-percent">
                    <span id="progressPercent">0</span>%
                </div>
                <div class="progress-elapsed" id="progressElapsed">Elapsed 0s</div>
            </div>
        </div>

        <div class="progress-log-header" onclick="toggleProgressLog()">
            <div class="progress-log-title"> LIVE LOG</div>
            <div class="progress-log-toggle" id="progressLogToggle"> COLLAPSE LOG</div>
        </div>

        <div class="progress-log-content expanded" id="progressLogContent">
            <!-- Log entries will be added here dynamically -->
        </div>

        <div class="progress-actions">
            <button class="progress-action-btn btn-close" onclick="closeProgressTracker()">Close</button>
        </div>
    </div>
    <script>
        // ==========================================
        // FEEDBACK MODAL LOGIC (RESTORED)
        // ==========================================

        window.openFeedbackModal = function () {
            const modal = document.getElementById('feedbackModal');
            if (modal) {
                modal.style.display = 'flex'; // Use flex to center
                modal.classList.add('show');
                modal.style.zIndex = '100000'; // Force on top

                // Reset form
                document.getElementById('feedbackForm').reset();
                document.getElementById('feedbackSuccess').style.display = 'none';
                document.getElementById('feedbackForm').style.display = 'block';

                // Set default tab
                switchFeedbackTab(document.querySelector('.feedback-tab[data-type="feedback"]'));
            }
        };

        window.closeFeedbackModal = function () {
            const modal = document.getElementById('feedbackModal');
            if (modal) {
                modal.style.display = 'none';
                modal.classList.remove('show');
            }
        };

        window.switchFeedbackTab = function (btn) {
            // Update active state
            document.querySelectorAll('.feedback-tab').forEach(b => b.classList.remove('active'));
            btn.classList.add('active');

            // Store type
            const type = btn.getAttribute('data-type');
            document.getElementById('feedbackForm').dataset.type = type;

            // Update placeholder
            const subjectInput = document.getElementById('feedbackSubject');
            if (type === 'bug') {
                subjectInput.placeholder = "What's broken?";
            } else if (type === 'feature') {
                subjectInput.placeholder = "What should we add?";
            } else {
                subjectInput.placeholder = "Give your request a short title";
            }
        };

        // Form Submission
        document.addEventListener('DOMContentLoaded', function () {
            const feedbackForm = document.getElementById('feedbackForm');
            if (feedbackForm) {
                feedbackForm.addEventListener('submit', async function (e) {
                    e.preventDefault();

                    const submitBtn = this.querySelector('.btn-submit');
                    const originalText = submitBtn.textContent;
                    submitBtn.disabled = true;
                    submitBtn.textContent = 'Sending...';

                    try {
                        const type = this.dataset.type || 'feedback';
                        const subject = document.getElementById('feedbackSubject').value;
                        const category = document.getElementById('feedbackCategory').value;
                        const experience = document.getElementById('feedbackExperience').value;
                        const details = document.getElementById('feedbackDetails').value;
                        const name = document.getElementById('feedbackName').value;

                        const token = localStorage.getItem('auth_token');

                        // Use relative URL
                        const apiBase = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';

                        const response = await fetch(`${apiBase}/feedback`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': token ? `Bearer ${token}` : ''
                            },
                            body: JSON.stringify({
                                type, subject, category, experience, details, name,
                                timestamp: new Date().toISOString() // Client time, backend will overwrite with CST
                            })
                        });

                        if (response.ok) {
                            // Show success
                            document.getElementById('feedbackForm').style.display = 'none';
                            document.getElementById('feedbackSuccess').style.display = 'block';

                            // Close after 2 seconds
                            setTimeout(closeFeedbackModal, 2000);
                        } else {
                            throw new Error('Submission failed');
                        }
                    } catch (error) {
                        console.error('Feedback Error:', error);
                        alert('Failed to submit feedback. Please try again.');
                    } finally {
                        submitBtn.disabled = false;
                        submitBtn.textContent = originalText;
                    }
                });
            }

            // Close modal on outside click
            window.onclick = function (event) {
                const modal = document.getElementById('feedbackModal');
                if (event.target == modal) {
                    closeFeedbackModal();
                }
            };
        });
    </script>

    <script>
        // FTTH page handlers (preview + generate)  uses ftth-pane with IN/OUT sections
        (function () {
            function isCidr(v, prefix) {
                try {
                    if (!v || !v.includes('/')) return false;
                    const parts = v.split('/');
                    if (parts.length !== 2) return false;
                    const p = parseInt(parts[1], 10);
                    if (isNaN(p)) return false;
                    return p === prefix;
                } catch (e) { return false; }
            }

            window.showFtthStateTab = function (tab) {
                const instateSection = document.getElementById('ftth-instate-section');
                const outstateSection = document.getElementById('ftth-outstate-section');
                const instateBtn = document.getElementById('ftth_instate_btn');
                const outstateBtn = document.getElementById('ftth_outstate_btn');

                if (tab === 'instate') {
                    if (instateSection) instateSection.style.display = 'block';
                    if (outstateSection) outstateSection.style.display = 'none';
                    if (instateBtn) { instateBtn.style.background = '#4CAF50'; instateBtn.classList.add('active'); }
                    if (outstateBtn) { outstateBtn.style.background = '#6c757d'; outstateBtn.classList.remove('active'); }
                } else {
                    if (instateSection) instateSection.style.display = 'none';
                    if (outstateSection) outstateSection.style.display = 'block';
                    if (instateBtn) { instateBtn.style.background = '#6c757d'; instateBtn.classList.remove('active'); }
                    if (outstateBtn) { outstateBtn.style.background = '#4CAF50'; outstateBtn.classList.add('active'); }
                }
            }

            function _ftth_active_suffix() {
                const instateSection = document.getElementById('ftth-instate-section');
                if (instateSection && instateSection.style.display !== 'none') return 'in';
                return 'out';
            }

            async function doFtthPreview() {
                const sfx = _ftth_active_suffix();
                const loopback = (document.getElementById(`ftth_loopback_${sfx}`) || {}).value || '';
                const cpe = (document.getElementById(`ftth_cpe_${sfx}`) || {}).value || '';
                const cgnat = (document.getElementById(`ftth_cgnat_${sfx}`) || {}).value || '';
                const olt = (document.getElementById(`ftth_olt_${sfx}`) || {}).value || '';
                const errEl = document.getElementById('ftthError');
                const previewEl = document.getElementById('ftthPreview');
                errEl.style.display = 'none'; errEl.textContent = ''; previewEl.style.display = 'none'; previewEl.textContent = '';

                if (!loopback || !isCidr(loopback, 32)) { errEl.textContent = 'Loopback must be a /32 (e.g., 10.13.100.5/32)'; errEl.style.display = 'block'; return false; }
                if (!isCidr(cpe, 22)) { errEl.textContent = 'CPE must be a /22 (e.g., 192.0.2.0/22)'; errEl.style.display = 'block'; return false; }
                if (!isCidr(cgnat, 22)) { errEl.textContent = 'CGNAT must be a /22 (e.g., 100.64.0.0/22)'; errEl.style.display = 'block'; return false; }
                if (!isCidr(olt, 29)) { errEl.textContent = 'OLT must be a /29 (e.g., 198.51.100.8/29)'; errEl.style.display = 'block'; return false; }

                try {
                    const r = await fetch('/api/preview-ftth-bng', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ loopback_ip: loopback, cpe_cidr: cpe, cgnat_cidr: cgnat, olt_cidr: olt }) });
                    if (!r.ok) {
                        const txt = await r.text();
                        errEl.textContent = 'Preview server responded with status ' + r.status + ': ' + (txt || '');
                        errEl.style.display = 'block'; return false;
                    }
                    const contentType = r.headers.get('content-type') || '';
                    let data;
                    if (contentType.includes('application/json')) {
                        data = await r.json();
                    } else {
                        const txt = await r.text();
                        errEl.textContent = 'Preview returned non-JSON response: ' + (txt || '');
                        errEl.style.display = 'block'; return false;
                    }
                    if (!data.success) { errEl.textContent = 'Preview error: ' + (data.error || 'unknown'); errEl.style.display = 'block'; return false; }
                    const p = data.preview || {};
                    let html = '<strong>Preview</strong><br/>';
                    html += `<div><b>Loopback:</b> ${p.loopback}</div>`;
                    html += `<div><b>OLT network:</b> ${p.olt.network}/${p.olt.prefix} - router IP suggestion: ${p.olt.router_ip || p.olt.first_host || 'n/a'}</div>`;
                    html += `<div><b>CPE pool:</b> ${p.cpe.network}/${p.cpe.prefix} - hosts: ${p.cpe.first_host} - ${p.cpe.last_host}</div>`;
                    html += `<div><b>CGNAT pool:</b> ${p.cgnat.network}/${p.cgnat.prefix} - hosts: ${p.cgnat.first_host} - ${p.cgnat.last_host}</div>`;
                    html += `<div style="margin-top:6px; color:#666;"><em>${p.note || ''}</em></div>`;
                    previewEl.innerHTML = html; previewEl.style.display = 'block'; document.getElementById('ftthGenerate').disabled = false;
                    return true;
                } catch (e) {
                    errEl.textContent = 'Preview request failed: ' + (e.message || e); errEl.style.display = 'block'; return false;
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                const previewBtn = document.getElementById('ftthPreviewBtn');
                const generateBtn = document.getElementById('ftthGenerate');
                const resetBtn = document.getElementById('ftthReset');

                previewBtn?.addEventListener('click', async () => { await doFtthPreview(); });

                generateBtn?.addEventListener('click', async () => {
                    if (generateBtn.disabled) { document.getElementById('ftthError').textContent = 'Please run Preview and correct any errors before generating.'; document.getElementById('ftthError').style.display = 'block'; return; }
                    const sfx = _ftth_active_suffix();
                    const loopback = (document.getElementById(`ftth_loopback_${sfx}`) || {}).value || '';
                    const cpe = (document.getElementById(`ftth_cpe_${sfx}`) || {}).value || '';
                    const cgnat = (document.getElementById(`ftth_cgnat_${sfx}`) || {}).value || '';
                    const olt = (document.getElementById(`ftth_olt_${sfx}`) || {}).value || '';
                    const olt_port = (document.getElementById(`ftth_olt_port_${sfx}`) || {}).value || 'sfp-sfpplus1';
                    const olt_port_speed = (document.getElementById(`ftth_olt_speed_${sfx}`) || {}).value || 'auto';
                    let identity = (document.getElementById(`ftth_identity_${sfx}`) || {}).value || '';
                    const errEl = document.getElementById('ftthError'); errEl.style.display = 'none'; errEl.textContent = '';
                    if (!identity) identity = `RTR-CCR2216.FTTH`;
                    try {
                        const r = await fetch('/api/gen-ftth-bng', {
                            method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({
                                device: 'CCR2216', target_version: (document.getElementById('targetVersion') || {}).value || '7.19.4', loopback_ip: loopback, cpe_cidr: cpe, cgnat_cidr: cgnat, olt_cidr: olt, olt_port: olt_port, olt_port_speed: olt_port_speed, identity: identity
                            })
                        });
                        const data = await r.json(); if (!data.success) { errEl.textContent = 'Generator error: ' + (data.error || 'unknown'); errEl.style.display = 'block'; return; }
                        const cfg = data.config || ''; document.getElementById('ftth_output').value = cfg; document.getElementById('ftth_output').parentElement.style.display = 'block';
                        saveConfigToHistory({ type: 'ftth', device: (document.getElementById('deviceSelect') || {}).value || 'ccr2004', siteName: identity, routeros: (document.getElementById('targetVersion') || {}).value || '7.19.4', success: true });
                        alert('FTTH BNG configuration generated and placed in Generated Configuration');
                    } catch (e) { errEl.textContent = 'Request failed: ' + (e.message || e); errEl.style.display = 'block'; }
                });

                resetBtn?.addEventListener('click', () => {
                    const sfx = _ftth_active_suffix();
                    const ids = [`ftth_loopback_${sfx}`, `ftth_cpe_${sfx}`, `ftth_cgnat_${sfx}`, `ftth_olt_${sfx}`, `ftth_olt_port_${sfx}`, `ftth_olt_speed_${sfx}`, `ftth_identity_${sfx}`];
                    ids.forEach(id => { const el = document.getElementById(id); if (el) el.value = ''; });
                    document.getElementById('ftthPreview').style.display = 'none'; document.getElementById('ftthPreview').textContent = '';
                    document.getElementById('ftthGenerate').disabled = true; document.getElementById('ftthError').style.display = 'none';
                });

                // FTTH -> Port & Uplink helpers
                const ftthAddOltBtn = document.getElementById('ftth_add_olt_port_btn');
                if (ftthAddOltBtn) ftthAddOltBtn.addEventListener('click', () => {
                    const sfx = _ftth_active_suffix();
                    const olt_port = (document.getElementById(`ftth_olt_port_${sfx}`) || {}).value || 'sfp-sfpplus1';
                    const olt_speed = (document.getElementById(`ftth_olt_speed_${sfx}`) || {}).value || 'auto';
                    addPortUplink({ port: olt_port, type: 'routed', speed: olt_speed, comment: 'OLT' });
                });

                const ftthAddBackBtn = document.getElementById('ftth_add_backhaul_btn');
                if (ftthAddBackBtn) ftthAddBackBtn.addEventListener('click', () => {
                    const sfx = _ftth_active_suffix();
                    const backhaul = (document.getElementById(`ftth_backhaul_${sfx}`) || {}).value || '';
                    const olt_port = (document.getElementById(`ftth_olt_port_${sfx}`) || {}).value || '';
                    addPortUplink({ port: olt_port, type: 'routed', speed: 'auto', comment: 'Backhaul', ip: backhaul });
                });

                const ftthOpenPortBtn = document.getElementById('ftth_open_portconfigs_btn');
                if (ftthOpenPortBtn) ftthOpenPortBtn.addEventListener('click', () => { ftthOpenPortConfigs(); });


                // FTTH helper: open the Port & Uplink section and scroll to it
                function ftthOpenPortConfigs() {
                    const el = document.getElementById('portConfigs');
                    if (!el) { alert('Port & Uplink configuration not found on this page.'); return; }
                    const pane = el.closest('.content-pane');
                    if (pane && pane.id) {
                        const tabId = pane.id.replace('-pane', '');
                        if (typeof navigateToTab === 'function') navigateToTab(tabId);
                        setTimeout(() => el.scrollIntoView({ behavior: 'smooth' }), 200);
                    } else {
                        el.scrollIntoView({ behavior: 'smooth' });
                    }
                }

                // Preset helpers
                function _ftth_load_presets() {
                    try {
                        const raw = localStorage.getItem('ftth_presets') || '{}';
                        return JSON.parse(raw);
                    } catch (e) { return {}; }
                }
                function _ftth_save_presets(obj) {
                    localStorage.setItem('ftth_presets', JSON.stringify(obj));
                }
                function _ftth_refresh_preset_list() {
                    const sel = document.getElementById('ftth_preset_select');
                    if (!sel) return;
                    const presets = _ftth_load_presets();
                    sel.innerHTML = '<option value="">Load preset...</option>';
                    Object.keys(presets).forEach(name => {
                        const opt = document.createElement('option');
                        opt.value = name; opt.textContent = name; sel.appendChild(opt);
                    });
                }
                function _ftth_collect_active_values() {
                    const sfx = _ftth_active_suffix();
                    return {
                        loopback: (document.getElementById(`ftth_loopback_${sfx}`) || {}).value || '',
                        cpe: (document.getElementById(`ftth_cpe_${sfx}`) || {}).value || '',
                        cgnat: (document.getElementById(`ftth_cgnat_${sfx}`) || {}).value || '',
                        olt: (document.getElementById(`ftth_olt_${sfx}`) || {}).value || '',
                        olt_port: (document.getElementById(`ftth_olt_port_${sfx}`) || {}).value || 'sfp-sfpplus1',
                        olt_port_speed: (document.getElementById(`ftth_olt_speed_${sfx}`) || {}).value || 'auto',
                        identity: (document.getElementById(`ftth_identity_${sfx}`) || {}).value || ''
                    };
                }
                document.getElementById('ftth_preset_save')?.addEventListener('click', () => {
                    const name = (document.getElementById('ftth_preset_name') || {}).value || '';
                    if (!name) { alert('Enter a preset name'); return; }
                    const presets = _ftth_load_presets();
                    presets[name] = _ftth_collect_active_values();
                    _ftth_save_presets(presets);
                    _ftth_refresh_preset_list();
                    alert('Preset saved');
                });
                document.getElementById('ftth_preset_select')?.addEventListener('change', (e) => {
                    const name = e.target.value; if (!name) return;
                    const presets = _ftth_load_presets();
                    const p = presets[name]; if (!p) return;
                    // Apply values into active suffix fields
                    const sfx = _ftth_active_suffix();
                    (document.getElementById(`ftth_loopback_${sfx}`) || {}).value = p.loopback || '';
                    (document.getElementById(`ftth_cpe_${sfx}`) || {}).value = p.cpe || '';
                    (document.getElementById(`ftth_cgnat_${sfx}`) || {}).value = p.cgnat || '';
                    (document.getElementById(`ftth_olt_${sfx}`) || {}).value = p.olt || '';
                    (document.getElementById(`ftth_olt_port_${sfx}`) || {}).value = p.olt_port || 'sfp-sfpplus1';
                    (document.getElementById(`ftth_olt_speed_${sfx}`) || {}).value = p.olt_port_speed || 'auto';
                    (document.getElementById(`ftth_identity_${sfx}`) || {}).value = p.identity || '';
                    document.getElementById('ftth_preset_select').value = '';
                });
                document.getElementById('ftth_preset_delete')?.addEventListener('click', () => {
                    const sel = document.getElementById('ftth_preset_select');
                    const name = sel?.value || '';
                    if (!name) { alert('Select a preset to delete'); return; }
                    const presets = _ftth_load_presets();
                    if (presets[name]) { delete presets[name]; _ftth_save_presets(presets); _ftth_refresh_preset_list(); alert('Preset deleted'); }
                });

                // Initialize to instate by default
                window.showFtthStateTab('instate');
                _ftth_refresh_preset_list();
            });
        })();

        // ========================================
        // FTTH BNG CONFIGURATION FUNCTIONS
        // ========================================

        // Global variable to track OLT ports
        window.ftthOltPortsCount = { in: 0, out: 0 };

        function buildFtthOltName(inputValue, tag) {
            const raw = (inputValue || '').trim();
            if (!raw) return '';
            if (raw.toUpperCase().startsWith('OLT-')) return raw;
            return `OLT-${tag}.${raw}`;
        }

        function getFtthOltName(suffix, group) {
            const suffixInput = group === 2
                ? document.getElementById(`ftth_olt_lag2_${suffix}`)?.value.trim()
                : document.getElementById(`ftth_olt_lag1_${suffix}`)?.value.trim();
            const tag = group === 2 ? 'MF2-2' : 'MF2-1';
            return buildFtthOltName(suffixInput, tag);
        }

        window.updateFtthOltLagName = function (suffix, group) {
            const fullName = getFtthOltName(suffix, group);
            const selector = group === 2 ? '[data-olt-group="2"]' : '[data-olt-group="1"]';
            const container = document.getElementById(`ftth_olt_ports_${suffix}`);
            if (!container) return;
            container.querySelectorAll(`${selector} .ftth-port-comment`).forEach((input) => {
                input.value = fullName;
                input.placeholder = fullName;
            });
        };


        function getFtthReservedPorts(suffix) {
            const container = document.getElementById(`ftth_olt_ports_${suffix}`);
            if (!container) return [];
            const reserved = new Set();
            container.querySelectorAll('input[readonly]').forEach((input) => {
                const val = (input.value || '').trim();
                if (val) reserved.add(val);
            });
            return Array.from(reserved);
        }

        window.updateFtthUplinkPortOptions = function (suffix) {
            const reserved = new Set(getFtthReservedPorts(suffix));
            const selects = document.querySelectorAll(`#ftth_uplink_rows_${suffix} .ftth-uplink-port`);
            selects.forEach((select) => {
                const options = Array.from(select.options);
                options.forEach((option) => {
                    const isReserved = reserved.has(option.value);
                    option.disabled = isReserved;
                    option.title = isReserved ? 'Reserved for OLT LAG ports' : '';
                });
                if (reserved.has(select.value)) {
                    const firstAvailable = options.find((option) => !option.disabled);
                    if (firstAvailable) select.value = firstAvailable.value;
                }
            });
        };

        window.addFtthUplinkRow = function (suffix) {
            const container = document.getElementById(`ftth_uplink_rows_${suffix}`);
            if (!container) return;
            const row = container.querySelector('.ftth-uplink-row');
            if (!row) return;
            const clone = row.cloneNode(true);
            clone.querySelectorAll('input').forEach((input) => {
                if (input.type === 'checkbox') {
                    input.checked = false;
                } else {
                    input.value = '';
                }
            });
            clone.querySelectorAll('select').forEach((select) => {
                select.selectedIndex = 0;
            });
            const cost = clone.querySelector('.ftth-uplink-cost');
            if (cost) cost.value = '10';
            const mtu = clone.querySelector('.ftth-uplink-mtu');
            if (mtu) mtu.value = '9000';
            const l2mtu = clone.querySelector('.ftth-uplink-l2mtu');
            if (l2mtu) l2mtu.value = '9212';
            container.appendChild(clone);
            if (window.updateFtthUplinkPortOptions) window.updateFtthUplinkPortOptions(suffix);
        };

        window.removeFtthUplinkRow = function (button) {
            const row = button?.closest('.ftth-uplink-row');
            if (!row) return;
            const container = row.parentElement;
            const rows = container?.querySelectorAll('.ftth-uplink-row') || [];
            if (rows.length <= 1) return;
            row.remove();
        };

        function collectFtthUplinks(suffix) {
            const container = document.getElementById(`ftth_uplink_rows_${suffix}`);
            if (!container) return [];
            const rows = Array.from(container.querySelectorAll('.ftth-uplink-row'));
            return rows.map(row => ({
                port: row.querySelector('.ftth-uplink-port')?.value || 'sfp28-1',
                type: row.querySelector('.ftth-uplink-type')?.value || 'routed',
                ip: row.querySelector('.ftth-uplink-ip')?.value.trim() || '',
                speed: row.querySelector('.ftth-uplink-speed')?.value || 'auto',
                comment: row.querySelector('.ftth-uplink-comment')?.value.trim() || 'to-CORE',
                cost: row.querySelector('.ftth-uplink-cost')?.value || '10',
                mtu: row.querySelector('.ftth-uplink-mtu')?.value || '9000',
                l2mtu: row.querySelector('.ftth-uplink-l2mtu')?.value || '9212',
                auto_negotiation: row.querySelector('.ftth-uplink-autoneg')?.checked || false
            }));
        }

        // Show/Hide State Tabs
        window.showFtthStateTab = function (state) {
            const instateSection = document.getElementById('ftth-instate-section');
            const outstateSection = document.getElementById('ftth-outstate-section');
            const instateBtn = document.getElementById('ftth_instate_btn');
            const outstateBtn = document.getElementById('ftth_outstate_btn');

            if (state === 'instate') {
                if (instateSection) instateSection.style.display = 'block';
                if (outstateSection) outstateSection.style.display = 'none';
                if (instateBtn) {
                    instateBtn.style.background = '#4CAF50';
                    instateBtn.classList.add('active');
                }
                if (outstateBtn) {
                    outstateBtn.style.background = '#6c757d';
                    outstateBtn.classList.remove('active');
                }
            } else {
                if (instateSection) instateSection.style.display = 'none';
                if (outstateSection) outstateSection.style.display = 'block';
                if (instateBtn) {
                    instateBtn.style.background = '#6c757d';
                    instateBtn.classList.remove('active');
                }
                if (outstateBtn) {
                    outstateBtn.style.background = '#4CAF50';
                    outstateBtn.classList.add('active');
                }
            }
            if (window.updateFtthUplinkPortOptions) {
                window.updateFtthUplinkPortOptions(state === 'instate' ? 'in' : 'out');
            }
        };

        // Auto-generate Router Identity from Site Name
        window.updateFtthRouterIdentity = function (suffix) {
            const siteNameInput = document.getElementById(`ftth_site_name_${suffix}`);
            const identityInput = document.getElementById(`ftth_identity_${suffix}`);

            if (!siteNameInput || !identityInput) return;

            const siteName = siteNameInput.value.trim().toUpperCase();
            if (siteName) {
                // Format: RTR-MT2216-AR1.SITENAME-FTTH-BNG
                identityInput.value = `RTR-MT2216-AR1.${siteName}-FTTH-BNG`;
            } else {
                identityInput.value = '';
            }
        };


        // Add OLT Ports (4-port bonding)
        window.addFtthOltPorts = function (suffix, group) {
            const container = document.getElementById(`ftth_olt_ports_${suffix}`);
            if (!container) return;

            const groupId = group === 2 ? '2' : '1';
            container.querySelectorAll(`[data-olt-group="${groupId}"]`).forEach(el => el.remove());

            const ports = groupId === '2'
                ? ['sfp28-7', 'sfp28-8', 'sfp28-9', 'sfp28-10']
                : ['sfp28-3', 'sfp28-4', 'sfp28-5', 'sfp28-6'];
            const oltName = getFtthOltName(suffix, groupId === '2' ? 2 : 1);
            ports.forEach((port, index) => {
                const portDiv = document.createElement('div');
                portDiv.className = 'uplink-item';
                portDiv.dataset.oltGroup = groupId;
                portDiv.style.cssText = 'margin-bottom: 10px; padding: 15px; background: var(--input-bg); border-radius: 4px; border: 1px solid var(--border-color);';
                portDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; align-items: center;">
                        <div>
                            <label>Port ${index + 1}:</label>
                            <input type="text" value="${port}" readonly style="background: var(--output-bg); cursor: not-allowed;">
                        </div>
                        <div>
                            <label>Speed:</label>
                            <select class="ftth-port-speed">
                                <option value="auto">Auto</option>
                                <option value="10G-baseSR-LR">10G-baseSR-LR</option>
                                <option value="10G-baseCR">10G-baseCR</option>
                            </select>
                        </div>
                        <div>
                            <label>Comment:</label>
                            <input type="text" class="ftth-port-comment" placeholder="${oltName}" value="${oltName}">
                        </div>
                    </div>
                `;
                container.appendChild(portDiv);
            });

            window.ftthOltPortsCount[suffix] = container.querySelectorAll('.uplink-item').length;
            console.log(`[FTTH] Added ${ports.length} OLT ports for ${suffix} group ${groupId}`);
            if (window.updateFtthUplinkPortOptions) window.updateFtthUplinkPortOptions(suffix);
        };

        // Clear OLT Ports
        window.clearFtthOltPorts = function (suffix) {
            const container = document.getElementById(`ftth_olt_ports_${suffix}`);
            if (container) {
                container.innerHTML = '';
                window.ftthOltPortsCount[suffix] = 0;
                console.log(`[FTTH] Cleared OLT ports for ${suffix} state`);
            }
            if (window.updateFtthUplinkPortOptions) window.updateFtthUplinkPortOptions(suffix);
        };

        // Validate CIDR notation
        function validateCIDR(value, expectedPrefix) {
            if (!value || !value.includes('/')) return false;
            const parts = value.split('/');
            if (parts.length !== 2) return false;
            const prefix = parseInt(parts[1], 10);
            if (isNaN(prefix)) return false;
            return prefix === expectedPrefix;
        }

        // Get active state suffix
        function getActiveStateSuffix() {
            const instateSection = document.getElementById('ftth-instate-section');
            return (instateSection && instateSection.style.display !== 'none') ? 'in' : 'out';
        }

        // Validate FTTH Configuration
        window.validateFtthConfig = function () {
            const suffix = getActiveStateSuffix();
            const errorDiv = document.getElementById('ftth_error');

            // Get all required fields
            const identity = document.getElementById(`ftth_identity_${suffix}`)?.value.trim();
            const loopback = document.getElementById(`ftth_loopback_${suffix}`)?.value.trim();
            const cpe = document.getElementById(`ftth_cpe_${suffix}`)?.value.trim();
            const cgnatPrivate = document.getElementById(`ftth_cgnat_private_${suffix}`)?.value.trim();
            const cgnatPublic = document.getElementById(`ftth_cgnat_public_${suffix}`)?.value.trim();
            const unauth = document.getElementById(`ftth_unauth_${suffix}`)?.value.trim();
            const oltNetwork = document.getElementById(`ftth_olt_network_${suffix}`)?.value.trim();
            const oltNetwork2 = document.getElementById(`ftth_olt_network2_${suffix}`)?.value.trim();
            const oltLag1 = document.getElementById(`ftth_olt_lag1_${suffix}`)?.value.trim();
            const oltLag2 = document.getElementById(`ftth_olt_lag2_${suffix}`)?.value.trim();
            const routerosVersion = document.getElementById(`ftth_routeros_${suffix}`)?.value.trim();
            const uplinks = collectFtthUplinks(suffix);
            const uplinkIp = uplinks.find(u => u.type === 'routed' && u.ip)?.ip || '';

            // Validation
            const errors = [];

            if (!identity) errors.push('Router Identity is required');
            if (!routerosVersion) errors.push('RouterOS Version is required');
            if (!loopback) errors.push('Loopback IP is required');
            else if (!validateCIDR(loopback, 32)) errors.push('Loopback must be a /32 (e.g., 10.26.1.111/32)');

            if (!cpe) errors.push('CPE Network is required');
            else if (!validateCIDR(cpe, 22)) errors.push('CPE Network must be a /22 (e.g., 10.30.100.0/22)');

            if (!cgnatPrivate) errors.push('CGNAT Private is required');
            else if (!validateCIDR(cgnatPrivate, 22)) errors.push('CGNAT Private must be a /22 (e.g., 100.80.108.0/22)');

            if (!cgnatPublic) errors.push('CGNAT Public IP is required');
            else if (!validateCIDR(cgnatPublic, 32)) errors.push('CGNAT Public must be a /32 (e.g., 52.128.63.173/32)');

            if (!unauth) errors.push('UNAUTH Network is required');
            else if (!validateCIDR(unauth, 22)) errors.push('UNAUTH Network must be a /22 (e.g., 10.130.100.0/22)');

            if (!oltNetwork) errors.push('OLT Network is required');
            else if (!validateCIDR(oltNetwork, 29)) errors.push('OLT Network must be a /29 (e.g., 10.246.46.88/29)');

            if (!oltLag1) errors.push('OLT LAG Name 1 is required');
            if (oltNetwork2 && !validateCIDR(oltNetwork2, 29)) errors.push('OLT Network 2 must be a /29 (e.g., 10.25.251.24/29)');
            if (oltLag2 && !oltNetwork2) errors.push('OLT Network 2 is required when OLT LAG Name 2 is provided');
            if (oltNetwork2 && !oltLag2) errors.push('OLT LAG Name 2 is required when OLT Network 2 is provided');
            if (!uplinks.length) {
                errors.push('At least one uplink is required');
            } else if (!uplinkIp) {
                errors.push('Uplink IP/Net is required for routed uplinks');
            }

            const reservedPorts = new Set(getFtthReservedPorts(suffix));
            const reservedUplinks = uplinks.map(u => u.port).filter(p => reservedPorts.has(p));
            if (reservedUplinks.length > 0) {
                errors.push(`Uplink ports cannot use OLT LAG ports: ${reservedUplinks.join(', ')}`);
            }

            // Check if OLT ports are configured
            const lag2Ports = Array.from(document.querySelectorAll(`#ftth_olt_ports_${suffix} [data-olt-group="2"]`));
            if (window.ftthOltPortsCount[suffix] < 4) {
                errors.push('Please add OLT LAG 1 ports (4 total ports)');
            }
            if (lag2Ports.length > 0 && !oltLag2) {
                errors.push('OLT LAG Name 2 is required when LAG 2 ports are added');
            }
            if (oltLag2 && lag2Ports.length < 4) {
                errors.push('Please add OLT LAG 2 ports (4 total ports)');
            }

            if (errors.length > 0) {
                errorDiv.innerHTML = '<strong>Validation Errors:</strong><ul style="margin: 10px 0; padding-left: 20px;">' +
                    errors.map(e => `<li>${e}</li>`).join('') + '</ul>';
                errorDiv.style.display = 'block';
                return false;
            }

            errorDiv.style.display = 'none';
            alert('Validation passed! You can now generate the configuration.');
            return true;
        };

        // Generate FTTH BNG Configuration
        window.generateFtthBngConfig = async function () {
            console.log('[FTTH] Generate button clicked');

            const suffix = getActiveStateSuffix();

            const deploymentType = suffix === 'in' ? 'instate' : 'outstate';
            const startTime = Date.now();
            const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
            const routerOSVersion = document.getElementById(`ftth_routeros_${suffix}`)?.value.trim() || '7.19.4';

            // Collect all configuration data
            const configData = {
                deployment_type: deploymentType,
                router_identity: document.getElementById(`ftth_identity_${suffix}`)?.value.trim(),
                location: document.getElementById(`ftth_location_${suffix}`)?.value.trim() || '',
                routeros_version: document.getElementById(`ftth_routeros_${suffix}`)?.value.trim() || '7.19.4',
                loopback_ip: document.getElementById(`ftth_loopback_${suffix}`)?.value.trim(),
                cpe_network: document.getElementById(`ftth_cpe_${suffix}`)?.value.trim(),
                cgnat_private: document.getElementById(`ftth_cgnat_private_${suffix}`)?.value.trim(),
                cgnat_public: document.getElementById(`ftth_cgnat_public_${suffix}`)?.value.trim(),
                unauth_network: document.getElementById(`ftth_unauth_${suffix}`)?.value.trim(),
                olt_network: document.getElementById(`ftth_olt_network_${suffix}`)?.value.trim(),
                olt_network_secondary: document.getElementById(`ftth_olt_network2_${suffix}`)?.value.trim(),
                olt_name_primary: getFtthOltName(suffix, 1),
                olt_name_secondary: getFtthOltName(suffix, 2),
                uplinks: collectFtthUplinks(suffix),
                olt_ports: []
            };

            // Collect OLT port configurations
            const container = document.getElementById(`ftth_olt_ports_${suffix}`);
            if (container) {
                const portItems = container.querySelectorAll('.uplink-item');
                portItems.forEach((item, index) => {
                    const portInput = item.querySelector('input[readonly]');
                    const speedSelect = item.querySelector('.ftth-port-speed');
                    const commentInput = item.querySelector('.ftth-port-comment');

                    if (portInput && speedSelect && commentInput) {
                        configData.olt_ports.push({
                            port: portInput.value,
                            speed: speedSelect.value,
                            comment: commentInput.value,
                            group: item.dataset.oltGroup || '1'
                        });
                    }
                });
            }

            console.log('[FTTH] Configuration data:', configData);

            try {
                // Show progress tracker
                if (window.showProgressTracker) window.showProgressTracker('Generating FTTH BNG Configuration');
                if (window.updateProgressStep) window.updateProgressStep('Validating inputs...');
                if (window.updateProgressPercent) window.updateProgressPercent(5);
                if (window.addProgressLog) window.addProgressLog('info', `Validating FTTH input fields (RouterOS ${routerOSVersion})`);
                await sleep(250);

                if (window.updateProgressStep) window.updateProgressStep('Preparing configuration payload...');
                if (window.updateProgressPercent) window.updateProgressPercent(12);
                if (window.addProgressLog) window.addProgressLog('info', 'Normalizing IP allocations and OLT details');
                await sleep(250);

                const apiBase = typeof resolveApiBase === 'function' ? resolveApiBase() : (window.AI_API_BASE || '/api');
                const targetUrl = `${apiBase.replace(/\/+$/, '')}/generate-ftth-bng`;
                console.log('[FTTH] API base:', apiBase);
                console.log('[FTTH] Fetching:', targetUrl, 'Data:', configData);

                if (window.updateProgressStep) window.updateProgressStep('Sending request to backend...');
                if (window.updateProgressPercent) window.updateProgressPercent(20);
                if (window.addProgressLog) window.addProgressLog('info', 'Submitting FTTH generation request');

                let fetchDone = false;
                const fetchPromise = fetch(targetUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(configData)
                }).then((res) => {
                    fetchDone = true;
                    return res;
                });

                const midSteps = [
                    { percent: 35, step: 'Building interface and bridge blocks...', log: 'Generating interfaces, bridges, and VLANs' },
                    { percent: 50, step: 'Configuring IP pools and DHCP...', log: 'Building DHCP pools and server networks' },
                    { percent: 65, step: 'Adding firewall and routing blocks...', log: 'Applying firewall, MPLS, and routing policies' },
                    { percent: 75, step: 'Finalizing configuration output...', log: 'Rendering FTTH template output' }
                ];

                for (const step of midSteps) {
                    if (fetchDone) break;
                    if (window.updateProgressStep) window.updateProgressStep(step.step);
                    if (window.updateProgressPercent) window.updateProgressPercent(step.percent);
                    if (window.addProgressLog) window.addProgressLog('info', step.log);
                    await sleep(350);
                }

                const response = await fetchPromise;
                const elapsedMs = Date.now() - startTime;
                if (elapsedMs < 1800) {
                    await sleep(1800 - elapsedMs);
                }

                console.log('[FTTH] Response status:', response.status, response.statusText);

                if (window.updateProgressPercent) window.updateProgressPercent(80);
                if (window.updateProgressStep) window.updateProgressStep('Processing configuration...');

                if (!response.ok) {
                    let errorPayload = { error: 'Unknown error' };
                    const contentType = response.headers.get('content-type') || '';
                    if (contentType.includes('application/json')) {
                        errorPayload = await response.json().catch(() => errorPayload);
                    } else {
                        const errorText = await response.text().catch(() => '');
                        if (errorText) errorPayload = { error: errorText };
                    }
                    console.error('[FTTH] Backend error:', errorPayload);
                    throw new Error(errorPayload.error || `HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('[FTTH] Response received, config length:', data.config ? data.config.length : 0);

                if (window.updateProgressPercent) window.updateProgressPercent(90);
                if (window.updateProgressStep) window.updateProgressStep('Finalizing...');
                if (window.addProgressLog) window.addProgressLog('success', 'FTTH configuration rendered successfully');

                if (data.config) {
                    document.getElementById('ftth_config_output').value = data.config;
                    document.getElementById('ftth_output_section').style.display = 'block';

                    // Scroll to output
                    document.getElementById('ftth_output_section').scrollIntoView({ behavior: 'smooth', block: 'start' });

                    if (window.updateProgressPercent) window.updateProgressPercent(100);
                    if (window.updateProgressStep) window.updateProgressStep('Configuration generated successfully!');
                    if (window.completeProgressTracker) window.completeProgressTracker(true);
                    if (window.addProgressLog) window.addProgressLog('success', `Config size: ${data.config.length} characters`);

                    console.log('[FTTH]  Configuration generated successfully');

                    // Save to history
                    if (typeof saveConfigToHistory === 'function') {
                        saveConfigToHistory({
                            type: 'ftth-bng',
                            device: 'CCR2216',
                            siteName: configData.router_identity,
                            routeros: routerOSVersion,
                            deploymentType: deploymentType,
                            success: true
                        });
                    }
                    if (typeof saveCompletedConfig === 'function') {
                        saveCompletedConfig({
                            config_type: 'ftth-bng',
                            device_name: configData.router_identity,
                            device_type: 'CCR2216',
                            customer_code: '',
                            loopback_ip: configData.loopback_ip,
                            routeros_version: routerOSVersion,
                            config_content: data.config,
                            site_name: document.getElementById(`ftth_site_name_${suffix}`)?.value.trim() || '',
                            router_id: configData.loopback_ip,
                            uplinks: configData.uplinks || [],
                            created_by: typeof getUsername === 'function' ? getUsername() : ''
                        });
                    }
                } else {
                    console.error('[FTTH] No configuration in response:', data);
                    throw new Error('No configuration returned from backend');
                }
            } catch (error) {
                console.error('[FTTH]  Error generating configuration:', {
                    message: error.message,
                    stack: error.stack,
                    name: error.name
                });

                const errorDiv = document.getElementById('ftth_error');
                errorDiv.innerHTML = `<strong> Error:</strong> ${error.message}`;
                errorDiv.style.display = 'block';

                if (window.completeProgressTracker) window.completeProgressTracker(false);
            }
        };

        // Copy Configuration to Clipboard
        window.copyFtthConfig = function () {
            const textarea = document.getElementById('ftth_config_output');
            const text = textarea.value;
            if (!text) {
                alert('No configuration to copy!');
                return;
            }
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text).then(() => {
                    alert(' Configuration copied to clipboard');
                }).catch(() => {
                    textarea.select();
                    document.execCommand('copy');
                    alert(' Configuration copied to clipboard');
                });
            } else {
                textarea.select();
                document.execCommand('copy');
                alert(' Configuration copied to clipboard');
            }
        };

        // Download Configuration
        window.downloadFtthConfig = function () {
            const textarea = document.getElementById('ftth_config_output');
            const config = textarea.value;
            if (!config) {
                alert('No configuration to download!');
                return;
            }

            const suffix = getActiveStateSuffix();
            const identity = document.getElementById(`ftth_identity_${suffix}`)?.value.trim() || 'ftth-bng';
            const ts = new Date().toISOString().split('T')[0];
            const blob = new Blob([config.replace(/\r?\n/g, '\n')], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${identity}-${ts}.rsc`;
            a.click();
            URL.revokeObjectURL(url);
        };

        // Reset Form
        window.resetFtthForm = function () {
            if (!confirm('Are you sure you want to reset the form? All entered data will be lost.')) {
                return;
            }

            const suffix = getActiveStateSuffix();

            // Clear all input fields
            const inputs = [
                `ftth_identity_${suffix}`,
                `ftth_location_${suffix}`,
                `ftth_loopback_${suffix}`,
                `ftth_cpe_${suffix}`,
                `ftth_cgnat_private_${suffix}`,
                `ftth_cgnat_public_${suffix}`,
                `ftth_unauth_${suffix}`,
                `ftth_olt_network_${suffix}`,
                `ftth_olt_network2_${suffix}`,
                `ftth_olt_lag1_${suffix}`,
                `ftth_olt_lag2_${suffix}`
            ];

            inputs.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.value = '';
            });

            const routerosSelect = document.getElementById(`ftth_routeros_${suffix}`);
            if (routerosSelect) routerosSelect.value = '7.19.4';

            // Clear OLT ports
            clearFtthOltPorts(suffix);

            // Reset uplink rows to one blank row
            const uplinkContainer = document.getElementById(`ftth_uplink_rows_${suffix}`);
            if (uplinkContainer) {
                const rows = uplinkContainer.querySelectorAll('.ftth-uplink-row');
                rows.forEach((row, idx) => {
                    if (idx === 0) {
                        row.querySelectorAll('input').forEach((input) => {
                            if (input.type === 'checkbox') {
                                input.checked = false;
                            } else {
                                input.value = '';
                            }
                        });
                        row.querySelectorAll('select').forEach((select) => {
                            select.selectedIndex = 0;
                        });
                        const cost = row.querySelector('.ftth-uplink-cost');
                        if (cost) cost.value = '10';
                        const mtu = row.querySelector('.ftth-uplink-mtu');
                        if (mtu) mtu.value = '9000';
                        const l2mtu = row.querySelector('.ftth-uplink-l2mtu');
                        if (l2mtu) l2mtu.value = '9212';
                    } else {
                        row.remove();
                    }
                });
            }

            // Hide output and error
            document.getElementById('ftth_output_section').style.display = 'none';
            document.getElementById('ftth_error').style.display = 'none';

            console.log('[FTTH] Form reset');
        };

        console.log('[FTTH] FTTH BNG Configuration functions loaded');
    </script>

    <!-- AVIAT BACKHAUL SCRIPT -->
    <script>
        (function () {
            const aviatState = {
                radios: [],
                isProcessing: false,
                currentTaskId: null,
                autoStatusInterval: null,
                nextStatusCheckAt: 0,
                globalStreamStarted: false
            };

            let aviatApiOverride = null;
            const aviatGetUsername = () => {
                if (typeof getUsername === 'function') {
                    return getUsername();
                }
                if (window.currentUser && typeof window.currentUser === 'string') {
                    return window.currentUser;
                }
                if (window.currentUser && typeof window.currentUser === 'object') {
                    return window.currentUser.username || window.currentUser.email || '';
                }
                return '';
            };

            function getAviatApiBase() {
                if (aviatApiOverride) return aviatApiOverride;
                const base = (typeof AI_API_BASE !== 'undefined' ? AI_API_BASE : window.AI_API_BASE) || '/api';
                return `${base}/aviat`;
            }

            function getAviatCandidateBases() {
                const bases = [];
                const originBase = `${window.location.origin}/api/aviat`;
                const apiBase = getAviatApiBase();
                const isFile = window.location.protocol === 'file:' || window.location.origin === 'null';

                bases.push(originBase);
                if (apiBase && apiBase !== originBase) {
                    bases.push(apiBase);
                }
                if (isFile) {
                    bases.push('http://localhost:5000/api/aviat');
                }
                return Array.from(new Set(bases.filter(Boolean)));
            }

            async function aviatFetch(path, options) {
                const bases = getAviatCandidateBases();
                const isLocalHost = ['localhost', '127.0.0.1'].includes(window.location.hostname);
                let lastError = null;
                for (const base of bases) {
                    try {
                        const response = await fetch(`${base}${path}`, options);
                        const shouldRetry = [403, 404, 405].includes(response.status);
                        if (shouldRetry && base !== bases[bases.length - 1]) {
                            continue;
                        }
                        if (response.ok) {
                            const allowOverride = base.startsWith(window.location.origin) || isLocalHost || window.location.protocol === 'file:';
                            if (allowOverride) {
                                aviatApiOverride = base;
                            }
                        }
                        return response;
                    } catch (err) {
                        lastError = err;
                    }
                }
                const baseList = bases.length ? ` (${bases.join(', ')})` : '';
                throw lastError || new Error(`Failed to fetch${baseList}`);
            }

            async function parseAviatJson(response) {
                const contentType = response.headers.get('content-type') || '';
                if (!contentType.includes('application/json')) {
                    return { error: `Unexpected response (${response.status})` };
                }
                try {
                    return await response.json();
                } catch (err) {
                    return { error: `Invalid JSON response (${response.status})` };
                }
            }

            function getAviatStreamBase() {
                if (aviatApiOverride && aviatApiOverride.startsWith('http')) return aviatApiOverride;
                return `${window.location.origin}/api/aviat`;
            }

            async function aviatFetchWithTimeout(path, options, timeoutMs = 15000) {
                const controller = new AbortController();
                const id = setTimeout(() => controller.abort(), timeoutMs);
                try {
                    const response = await aviatFetch(path, {
                        ...options,
                        signal: controller.signal
                    });
                    return response;
                } finally {
                    clearTimeout(id);
                }
            }

            function aviatAddLog(message, type = 'info') {
                const logBox = document.getElementById('logBox');
                if (!logBox) return;
                const time = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `aviat-log-entry log-${type}`;
                entry.innerHTML = `<span class="aviat-log-time">[${time}]</span> ${message}`;
                logBox.appendChild(entry);
                logBox.scrollTop = logBox.scrollHeight;
            }

            function aviatClearLog() {
                const logBox = document.getElementById('logBox');
                if (!logBox) return;
                logBox.innerHTML = '<div class="aviat-log-entry"><span class="aviat-log-time">[--:--:--]</span> Log cleared.</div>';
            }

            function aviatNormalizeStatus(status, successFlag) {
                if (!status) return successFlag ? 'success' : 'pending';
                const lower = String(status).toLowerCase();
                if (['success', 'error', 'pending', 'processing', 'loading', 'scheduled', 'manual'].includes(lower)) {
                    return lower;
                }
                if (['completed', 'done'].includes(lower)) {
                    return successFlag === false ? 'error' : 'success';
                }
                if (['failed', 'fail'].includes(lower)) {
                    return 'error';
                }
                return successFlag === true ? 'success' : lower;
            }

            function aviatStatusIcon(status) {
                const icons = {
                    pending: '.',
                    processing: '~',
                    loading: 'LD',
                    scheduled: 'S',
                    manual: 'M',
                    success: 'OK',
                    error: 'X'
                };
                return icons[status] || '?';
            }

            function aviatNormalizeRadio(r) {
                return {
                    ip: r.ip,
                    status: aviatNormalizeStatus(r.status, r.success),
                    firmwareStatus: aviatNormalizeStatus(r.firmwareStatus),
                    passwordStatus: aviatNormalizeStatus(r.passwordStatus),
                    snmpStatus: aviatNormalizeStatus(r.snmpStatus),
                    bufferStatus: aviatNormalizeStatus(r.bufferStatus),
                    sopStatus: aviatNormalizeStatus(r.sopStatus),
                    username: r.username || ''
                };
            }

            function aviatPersistRadios() {
                try {
                    localStorage.setItem('aviatRadios', JSON.stringify(aviatState.radios));
                } catch (e) {
                    // ignore storage errors
                }
            }

            function aviatRestoreRadios() {
                try {
                    const raw = localStorage.getItem('aviatRadios');
                    if (!raw) return;
                    const parsed = JSON.parse(raw);
                    if (Array.isArray(parsed)) {
                        aviatState.radios = parsed.map(aviatNormalizeRadio);
                    }
                } catch (e) {
                    // ignore storage errors
                }
            }

            function aviatUpdateUI() {
                const statsBar = document.getElementById('statsBar');
                const radioListCard = document.getElementById('radioListCard');
                const radioList = document.getElementById('radioList');

                if (!statsBar || !radioListCard || !radioList) return;

                if (aviatState.radios.length === 0) {
                    statsBar.style.display = 'none';
                    radioListCard.style.display = 'none';
                    return;
                }

                statsBar.style.display = 'flex';
                radioListCard.style.display = 'block';

                const stats = {
                    total: aviatState.radios.length,
                    pending: aviatState.radios.filter(r => aviatNormalizeStatus(r.status) === 'pending').length,
                    processing: aviatState.radios.filter(r => aviatNormalizeStatus(r.status) === 'processing').length,
                    loading: aviatState.radios.filter(r => aviatNormalizeStatus(r.status) === 'loading').length,
                    scheduled: aviatState.radios.filter(r => aviatNormalizeStatus(r.status) === 'scheduled').length,
                    success: aviatState.radios.filter(r => aviatNormalizeStatus(r.status) === 'success').length,
                    error: aviatState.radios.filter(r => aviatNormalizeStatus(r.status) === 'error').length
                };

                document.getElementById('statTotal').textContent = stats.total;
                document.getElementById('statPending').textContent = stats.pending;
                document.getElementById('statProcessing').textContent = stats.processing;
                document.getElementById('statLoading').textContent = stats.loading;
                document.getElementById('statScheduled').textContent = stats.scheduled;
                document.getElementById('statSuccess').textContent = stats.success;
                document.getElementById('statError').textContent = stats.error;

                radioList.innerHTML = aviatState.radios.map(r => {
                    const mainStatus = aviatNormalizeStatus(r.status);
                    const fwStatus = aviatNormalizeStatus(r.firmwareStatus);
                    const pwStatus = aviatNormalizeStatus(r.passwordStatus);
                    const snmpStatus = aviatNormalizeStatus(r.snmpStatus);
                    const bufferStatus = aviatNormalizeStatus(r.bufferStatus);
                    const sopStatus = aviatNormalizeStatus(r.sopStatus);
                    const disabled = mainStatus === 'processing' ? 'disabled' : '';
                    return `
                        <div class="aviat-queue-item">
                            <div>
                                <span class="aviat-status-badge ${mainStatus}">${aviatStatusIcon(mainStatus)}</span>
                                ${r.ip}
                                <div style="margin-top: 6px; display: flex; gap: 6px; flex-wrap: wrap;">
                                    <span class="aviat-status-badge ${fwStatus}" title="Firmware">${aviatStatusIcon(fwStatus)}</span>
                                    <span class="aviat-status-badge ${pwStatus}" title="Password">${aviatStatusIcon(pwStatus)}</span>
                                    <span class="aviat-status-badge ${snmpStatus}" title="SNMP">${aviatStatusIcon(snmpStatus)}</span>
                                    <span class="aviat-status-badge ${bufferStatus}" title="Buffer">${aviatStatusIcon(bufferStatus)}</span>
                                    <span class="aviat-status-badge ${sopStatus}" title="SOP">${aviatStatusIcon(sopStatus)}</span>
                                </div>
                            </div>
                            <div style="display: flex; gap: 6px; align-items: center;">
                                <button class="aviat-btn secondary" onclick="aviatRunSingle('${r.ip}')" ${disabled}>Run</button>
                                <button class="aviat-btn danger" onclick="aviatRemoveRadio('${r.ip}')" ${disabled}>Remove</button>
                            </div>
                        </div>
                    `;
                }).join('');

                aviatPersistRadios();
            }

            async function aviatLoadSharedQueue() {
                try {
                    const response = await aviatFetch('/queue');
                    if (!response.ok) {
                        throw new Error(`Queue fetch failed (${response.status})`);
                    }
                    const data = await response.json();
                    if (Array.isArray(data.radios)) {
                        aviatState.radios = data.radios.map(aviatNormalizeRadio);
                        aviatUpdateUI();
                        return true;
                    }
                } catch (err) {
                    aviatAddLog(`Shared queue unavailable: ${err.message}`, 'warning');
                }
                return false;
            }

            function aviatAddRadios() {
                const input = document.getElementById('ipInput');
                if (!input) return;
                const raw = input.value.trim();
                if (!raw) return;
                const newIPs = raw.split(/[\n,]+/)
                    .map(ip => ip.trim())
                    .filter(ip => ip && !aviatState.radios.find(r => r.ip === ip));
                if (newIPs.length === 0) return;
                const radios = newIPs.map(ip => ({
                    ip,
                    status: 'pending',
                    firmwareStatus: 'pending',
                    passwordStatus: 'pending',
                    snmpStatus: 'pending',
                    bufferStatus: 'pending',
                    sopStatus: 'pending',
                    username: aviatGetUsername()
                }));

                aviatFetch('/queue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'add', radios, username: aviatGetUsername() })
                }).then(res => res.json())
                  .then(data => {
                      if (Array.isArray(data.radios)) {
                          aviatState.radios = data.radios.map(aviatNormalizeRadio);
                          aviatAddLog(`Added ${newIPs.length} radio(s) to queue`, 'info');
                          aviatUpdateUI();
                      }
                  }).catch(err => {
                      aviatAddLog(`Queue add failed: ${err.message}`, 'error');
                  });

                input.value = '';
            }

            function aviatReplaceRadios() {
                const input = document.getElementById('ipInput');
                if (!input || !input.value.trim()) {
                    aviatAddLog('Please enter IPs to replace the list', 'warning');
                    return;
                }
                const raw = input.value.trim();
                const newIPs = raw.split(/[\n,]+/)
                    .map(ip => ip.trim())
                    .filter(ip => ip);
                const radios = newIPs.map(ip => ({
                    ip,
                    status: 'pending',
                    firmwareStatus: 'pending',
                    passwordStatus: 'pending',
                    snmpStatus: 'pending',
                    bufferStatus: 'pending',
                    sopStatus: 'pending',
                    username: aviatGetUsername()
                }));
                aviatFetch('/queue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'replace', radios, username: aviatGetUsername() })
                }).then(res => res.json())
                  .then(data => {
                      if (Array.isArray(data.radios)) {
                          aviatState.radios = data.radios.map(aviatNormalizeRadio);
                          aviatAddLog(`Replaced queue with ${newIPs.length} radio(s)`, 'info');
                          aviatUpdateUI();
                      }
                  }).catch(err => {
                      aviatAddLog(`Queue replace failed: ${err.message}`, 'error');
                  });
                input.value = '';
            }

            function aviatRemoveRadio(ip) {
                aviatFetch('/queue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'remove', radios: [{ ip }], username: aviatGetUsername() })
                }).then(res => res.json())
                  .then(data => {
                      if (Array.isArray(data.radios)) {
                          aviatState.radios = data.radios.map(aviatNormalizeRadio);
                          aviatUpdateUI();
                      }
                  }).catch(err => {
                      aviatAddLog(`Remove failed: ${err.message}`, 'error');
                  });
            }

            window.aviatRemoveRadio = aviatRemoveRadio;

            function aviatClearAll() {
                aviatFetch('/queue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'replace', radios: [], username: aviatGetUsername() })
                }).then(res => res.json())
                  .then(data => {
                      aviatState.radios = [];
                      aviatUpdateUI();
                      aviatAddLog('Cleared all radios', 'info');
                  }).catch(err => {
                      aviatAddLog(`Clear failed: ${err.message}`, 'error');
                  });
            }

            function aviatClearCompleted() {
                const remaining = aviatState.radios.filter(r => aviatNormalizeStatus(r.status) !== 'success');
                aviatFetch('/queue', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ mode: 'replace', radios: remaining, username: aviatGetUsername() })
                }).then(res => res.json())
                  .then(data => {
                      if (Array.isArray(data.radios)) {
                          aviatState.radios = data.radios.map(aviatNormalizeRadio);
                          aviatUpdateUI();
                          aviatAddLog('Cleared completed radios', 'info');
                      }
                  }).catch(err => {
                      aviatAddLog(`Clear completed failed: ${err.message}`, 'error');
                  });
            }

            function computeActivationAt(timeStr) {
                if (!timeStr) return null;
                const [hour, minute] = timeStr.split(':').map(v => parseInt(v, 10));
                const now = new Date();
                const target = new Date(now.getFullYear(), now.getMonth(), now.getDate(), hour, minute, 0, 0);
                if (target <= now) {
                    target.setDate(target.getDate() + 1);
                }
                return target.toISOString();
            }

            function buildRunPayload() {
                const doFirmware = document.getElementById('taskFirmware').checked;
                const doBuffer = document.getElementById('taskBuffer').checked;
                const doSNMP = document.getElementById('taskSNMP').checked;
                const doPassword = document.getElementById('taskPassword').checked;
                const doSOP = document.getElementById('taskSOP').checked;
                const activationTime = document.getElementById('activationTime').value;
                const activationMode = document.getElementById('activationMode').value;
                const firmwareTarget = document.getElementById('firmwareTarget').value;

                const tasks = [];
                if (doFirmware) tasks.push('firmware');
                if (doBuffer) tasks.push('buffer');
                if (doSNMP) tasks.push('snmp');
                if (doPassword) tasks.push('password');
                if (doSOP) tasks.push('sop');

                if (tasks.length === 0) {
                    aviatAddLog('No tasks selected', 'warning');
                    return null;
                }

                return {
                    tasks,
                    maintenance_params: {
                        activation_time: activationMode === 'scheduled' ? activationTime : null,
                        activation_at: activationMode === 'scheduled' ? computeActivationAt(activationTime) : null,
                        activate_now: activationMode === 'immediate',
                        activation_mode: activationMode,
                        firmware_target: firmwareTarget,
                        firmware_uri: null
                    },
                    username: aviatGetUsername()
                };
            }

            function buildScheduledSyncPayload(ips) {
                const doBuffer = document.getElementById('taskBuffer').checked;
                const doSNMP = document.getElementById('taskSNMP').checked;
                const doPassword = document.getElementById('taskPassword').checked;
                const doSOP = document.getElementById('taskSOP').checked;
                const activationTime = document.getElementById('activationTime').value;
                const activationMode = document.getElementById('activationMode').value;
                const firmwareTarget = document.getElementById('firmwareTarget').value;

                const remainingTasks = [];
                if (doBuffer) remainingTasks.push('buffer');
                if (doSNMP) remainingTasks.push('snmp');
                if (doPassword) remainingTasks.push('password');
                if (doSOP) remainingTasks.push('sop');

                return {
                    ips,
                    remaining_tasks: remainingTasks,
                    maintenance_params: {
                        activation_time: activationMode === 'scheduled' ? activationTime : null,
                        activation_at: activationMode === 'scheduled' ? computeActivationAt(activationTime) : null,
                        activate_now: false,
                        activation_mode: activationMode,
                        firmware_target: firmwareTarget,
                        firmware_uri: null
                    },
                    activation_at: activationMode === 'scheduled' ? computeActivationAt(activationTime) : null,
                    username: aviatGetUsername()
                };
            }

            async function aviatSubmitRun(ips) {
                const payload = buildRunPayload();
                if (!payload) return;
                ips.forEach(ip => {
                    const radio = aviatState.radios.find(r => r.ip === ip);
                    if (radio) {
                        radio.status = 'processing';
                    }
                });
                aviatUpdateUI();
                try {
                    const response = await aviatFetchWithTimeout('/run', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            ips,
                            tasks: payload.tasks,
                            maintenance_params: payload.maintenance_params,
                            username: payload.username
                        })
                    });
                    const data = await parseAviatJson(response);
                    if (data.task_id) {
                        aviatState.currentTaskId = data.task_id;
                        document.getElementById('abortBtn').disabled = false;
                        aviatStartLogStream(data.task_id);
                        aviatMonitorStatus(data.task_id);
                    } else {
                        aviatAddLog(`Error starting task: ${data.error || 'Unknown error'}`, 'error');
                        aviatResetRunButton();
                    }
                } catch (err) {
                    const message = err.name === 'AbortError'
                        ? 'Backend request timed out. Please retry.'
                        : `Failed to connect to backend: ${err.message}`;
                    aviatAddLog(message, 'error');
                    aviatResetRunButton();
                }
            }

            window.aviatRunSingle = async function (ip) {
                if (aviatState.isProcessing) return;
                aviatState.isProcessing = true;
                document.getElementById('runBtn').textContent = 'Processing...';
                document.getElementById('runBtn').disabled = true;
                await aviatSubmitRun([ip]);
            };

            async function aviatRunAll() {
                if (aviatState.isProcessing) return;
                const pending = aviatState.radios.filter(r => ['pending', 'error'].includes(aviatNormalizeStatus(r.status)));
                if (pending.length === 0) {
                    aviatAddLog('No radios to process', 'warning');
                    return;
                }
                aviatState.isProcessing = true;
                document.getElementById('runBtn').textContent = 'Processing...';
                document.getElementById('runBtn').disabled = true;
                aviatAddLog('----------------------------------------', 'info');
                aviatAddLog(`Starting Configuration for ${pending.length} radio(s)`, 'info');
                aviatAddLog('----------------------------------------', 'info');
                await aviatSubmitRun(pending.map(r => r.ip));
            }

            async function aviatActivateScheduled() {
                if (aviatState.isProcessing) return;
                aviatState.isProcessing = true;
                document.getElementById('runBtn').textContent = 'Processing...';
                document.getElementById('runBtn').disabled = true;
                try {
                    const now = new Date();
                    const scheduledIps = aviatState.radios.filter(r => aviatNormalizeStatus(r.status) === 'scheduled').map(r => r.ip);
                    scheduledIps.forEach(ip => {
                        const radio = aviatState.radios.find(r => r.ip === ip);
                        if (radio) {
                            radio.status = 'processing';
                        }
                    });
                    aviatUpdateUI();
                    const syncPayload = scheduledIps.length > 0 ? buildScheduledSyncPayload(scheduledIps) : null;
                    if (syncPayload) {
                        await aviatFetch('/scheduled/sync', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(syncPayload)
                        });
                    }
                    const response = await aviatFetchWithTimeout('/activate-scheduled', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            force: true,
                            client_hour: now.getHours(),
                            client_minute: now.getMinutes(),
                            ips: scheduledIps,
                            remaining_tasks: syncPayload ? syncPayload.remaining_tasks : [],
                            maintenance_params: syncPayload ? syncPayload.maintenance_params : {},
                            activation_at: syncPayload ? syncPayload.activation_at : null,
                            username: aviatGetUsername()
                        })
                    });
                    const data = await parseAviatJson(response);
                    if (!response.ok) {
                        aviatAddLog(data.error || 'Activate scheduled failed', 'error');
                        aviatResetRunButton();
                        return;
                    }
                if (data.task_id) {
                        aviatState.activationCheckStart = Date.now();
                        aviatState.nextStatusCheckAt = aviatState.activationCheckStart + 3600000;
                        setTimeout(() => { aviatCheckStatus(); }, 3600000);
                        aviatState.currentTaskId = data.task_id;
                        document.getElementById('abortBtn').disabled = false;
                        aviatStartLogStream(data.task_id);
                        aviatMonitorStatus(data.task_id);
                    } else {
                        aviatAddLog('No scheduled devices to activate', 'warning');
                        aviatResetRunButton();
                    }
                } catch (err) {
                    const message = err.name === 'AbortError'
                        ? 'Activate scheduled timed out. Please retry.'
                        : `Activate scheduled failed: ${err.message}`;
                    aviatAddLog(message, 'error');
                    aviatResetRunButton();
                }
            }

            async function aviatAbortRun() {
                if (!aviatState.currentTaskId) return;
                try {
                    await aviatFetch(`/abort/${aviatState.currentTaskId}`, { method: 'POST' });
                    aviatAddLog('Abort requested', 'warning');
                } catch (err) {
                    aviatAddLog(`Abort failed: ${err.message}`, 'error');
                }
            }

            function aviatResetRunButton() {
                aviatState.isProcessing = false;
                aviatState.currentTaskId = null;
                const abortBtn = document.getElementById('abortBtn');
                if (abortBtn) abortBtn.disabled = true;
                document.getElementById('runBtn').textContent = 'Run All';
                document.getElementById('runBtn').disabled = false;
            }

            function aviatStartAutoStatusChecks() {
                if (aviatState.autoStatusInterval) return;
                aviatState.autoStatusInterval = setInterval(() => {
                    const hasRunning = aviatState.radios.some(r => aviatNormalizeStatus(r.status) === 'processing');
                    if (hasRunning) {
                        aviatCheckStatus();
                    }
                }, 3600000);
            }

            async function aviatCheckStatus() {
                try {
                    const now = Date.now();
                    if (now < aviatState.nextStatusCheckAt) {
                        const mins = Math.ceil((aviatState.nextStatusCheckAt - now) / 60000);
                        aviatAddLog(`Status check deferred (${mins} min until post-activation window).`, 'info');
                        return;
                    }
                    aviatAddLog(`Checking status for ${aviatState.radios.length} radio(s)...`, 'info');
                    const response = await aviatFetch('/check-status', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ ips: aviatState.radios.map(r => r.ip) })
                    });
                    const data = await parseAviatJson(response);
                    if (!response.ok) {
                        aviatAddLog(data.error || 'Check status failed', 'error');
                        return;
                    }
                    const results = data.results || [];
                    results.forEach(res => {
                        const radio = aviatState.radios.find(r => r.ip === res.ip);
                        if (!radio) return;
                        if (res.error || !res.reachable) {
                            const currentStatus = aviatNormalizeStatus(radio.status);
                            if (currentStatus === 'processing' || currentStatus === 'scheduled') {
                                return;
                            }
                            radio.status = 'error';
                            return;
                        }
                        const firmwareOk = res.firmware && res.firmware.startsWith('6.');
                        radio.firmwareStatus = firmwareOk ? 'success' : 'pending';
                        radio.snmpStatus = res.snmp_ok ? 'success' : 'pending';
                        radio.bufferStatus = res.buffer_ok ? 'success' : 'pending';
                        radio.sopStatus = firmwareOk && res.snmp_ok && res.buffer_ok ? 'success' : 'pending';
                        if (radio.sopStatus === 'success') {
                            radio.status = 'success';
                        } else if (aviatNormalizeStatus(radio.status) !== 'scheduled') {
                            radio.status = 'pending';
                        }
                    });
                    aviatUpdateUI();
                    aviatAddLog(`Status check completed (${results.length} radios)`, 'info');
                    if (aviatState.activationCheckStart) {
                        const elapsed = now - aviatState.activationCheckStart;
                        if (elapsed < 5400000) {
                            aviatState.nextStatusCheckAt = Date.now() + 3600000;
                        } else {
                            aviatState.activationCheckStart = null;
                        }
                    }
                } catch (err) {
                    aviatAddLog(`Check status failed: ${err.message}`, 'error');
                }
            }

            async function aviatRefreshStatus(options = {}) {
                const quiet = options.quiet === true;
                try {
                    const queueLoaded = await aviatLoadSharedQueue();
                    const scheduledResponse = await aviatFetch('/scheduled');
                    const scheduledData = await parseAviatJson(scheduledResponse);
                    const loadingResponse = await aviatFetch('/loading');
                    const loadingData = await parseAviatJson(loadingResponse);
                    if (!scheduledResponse.ok || !loadingResponse.ok) {
                        if (!quiet) {
                            const errMsg = scheduledData.error || loadingData.error || `Refresh failed (${scheduledResponse.status}/${loadingResponse.status})`;
                            aviatAddLog(errMsg, 'error');
                        }
                        return;
                    }
                    const scheduled = new Set(scheduledData.scheduled || []);
                    const loading = new Set(loadingData.loading || []);
                    aviatState.radios = aviatState.radios.map(r => {
                        if (loading.has(r.ip)) {
                            return { ...r, status: 'loading', firmwareStatus: 'loading' };
                        }
                        if (scheduled.has(r.ip)) {
                            return { ...r, status: 'scheduled' };
                        }
                        if (r.status === 'loading' || r.status === 'scheduled') {
                            return { ...r, status: 'pending' };
                        }
                        return r;
                    });
                    aviatUpdateUI();
                    if (!quiet) {
                        aviatAddLog(queueLoaded ? 'Refreshed shared queue' : 'Refreshed scheduled queue', 'info');
                    }
                } catch (err) {
                    if (!quiet) {
                        aviatAddLog(`Refresh failed: ${err.message}`, 'error');
                    }
                }
            }

            function aviatHandleStreamMessage(data) {
                aviatAddLog(data.message, data.level);
                const ipMatch = data.message.match(/\[(\d+\.\d+\.\d+\.\d+)\]/);
                if (ipMatch) {
                    const ip = ipMatch[1];
                    const radio = aviatState.radios.find(r => r.ip === ip);
                    if (radio) {
                        radio.status = 'processing';
                        if (data.message.includes('Triggering firmware download')) {
                            radio.firmwareStatus = 'processing';
                        } else if (data.message.includes('Firmware download complete') || data.message.includes('Firmware download started')) {
                            radio.firmwareStatus = 'loading';
                        } else if (data.message.includes('Added to loading queue')) {
                            radio.status = 'loading';
                            radio.firmwareStatus = 'loading';
                        } else if (data.message.includes('Scheduled activation queued')) {
                            radio.status = 'scheduled';
                        } else if (data.message.includes('Activation started')) {
                            radio.firmwareStatus = 'success';
                        } else if (data.message.includes('Password changed')) {
                            radio.passwordStatus = 'success';
                        } else if (data.message.includes('SNMP configured')) {
                            radio.snmpStatus = 'success';
                        } else if (data.message.includes('Buffer script applied')) {
                            radio.bufferStatus = 'success';
                        } else if (data.message.includes('SOP check')) {
                            if (data.message.includes('FAIL')) {
                                radio.sopStatus = 'error';
                            } else if (data.message.includes('PASS')) {
                                radio.sopStatus = 'success';
                            }
                        } else if (data.message.includes('SUCCESS')) {
                            radio.status = 'success';
                        } else if (data.message.includes('FAILED')) {
                            radio.status = 'error';
                        } else if (data.level === 'error' && data.message.toLowerCase().includes('failed')) {
                            radio.status = 'error';
                        }
                    }
                }
                aviatUpdateUI();
            }

            function aviatStartGlobalLogStream() {
                if (aviatState.globalStreamStarted) return;
                aviatState.globalStreamStarted = true;
                const eventSource = new EventSource(`${getAviatStreamBase()}/stream/global`);
                eventSource.onopen = function () {
                    aviatAddLog('Live log stream connected', 'info');
                };
                eventSource.onmessage = function (event) {
                    let data;
                    try {
                        data = JSON.parse(event.data);
                    } catch (err) {
                        aviatAddLog('Live log stream parse failed. Monitoring status only.', 'warning');
                        eventSource.close();
                        return;
                    }
                    aviatHandleStreamMessage(data);
                };
                eventSource.onerror = function () {
                    eventSource.close();
                    aviatState.globalStreamStarted = false;
                    aviatAddLog('Live log stream disconnected. Monitoring status only.', 'warning');
                    setTimeout(() => {
                        if (!aviatState.globalStreamStarted) {
                            aviatStartGlobalLogStream();
                        }
                    }, 5000);
                };
            }

            function aviatStartLogStream(taskId) {
                aviatStartGlobalLogStream();
            }

            function aviatMonitorStatus(taskId) {
                const interval = setInterval(async () => {
                    try {
                        const response = await aviatFetch(`/status/${taskId}`);
                        const data = await parseAviatJson(response);
                        if (data.status === 'completed' || data.status === 'aborted') {
                            clearInterval(interval);
                            (data.results || []).forEach(res => {
                                const radio = aviatState.radios.find(r => r.ip === res.ip);
                                if (radio) {
                                    radio.status = aviatNormalizeStatus(res.status, res.success);
                                    radio.firmwareStatus = res.firmware_downloaded ? 'success' : 'pending';
                                    radio.passwordStatus = res.password_changed ? 'success' : 'pending';
                                    radio.snmpStatus = res.snmp_configured ? 'success' : 'pending';
                                    radio.bufferStatus = res.buffer_configured ? 'success' : 'pending';
                                    radio.sopStatus = res.sop_checked ? (res.sop_passed ? 'success' : 'error') : 'pending';
                                }
                            });
                            aviatUpdateUI();
                            aviatResetRunButton();
                            const success = (data.results || []).filter(r => r.success).length;
                            aviatAddLog('----------------------------------------', 'info');
                            aviatAddLog(`Batch complete: ${success}/${(data.results || []).length} successful`, success === (data.results || []).length ? 'success' : 'warning');
                            if (data.status === 'aborted') {
                                aviatAddLog('Batch aborted', 'warning');
                            }
                        }
                    } catch (err) {
                        console.error('Aviat status check failed', err);
                    }
                }, 2000);
            }

            function aviatUpdateMaintenanceBanner() {
                const banner = document.getElementById('maintenanceBanner');
                if (!banner) return;
                const now = new Date();
                const hour = now.getHours();
                const inWindow = hour >= 2 && hour < 6;
                const canActivate = hour >= 2 && hour < 5;
                banner.className = `aviat-maintenance-banner ${inWindow ? 'aviat-maintenance-on' : 'aviat-maintenance-off'}`;
                banner.textContent = inWindow
                    ? 'MAINTENANCE WINDOW ACTIVE (2:00 AM - 6:00 AM) | Activation allowed until 5:00 AM'
                    : 'OUTSIDE MAINTENANCE WINDOW (2:00 AM - 6:00 AM) | Activation allowed 2:00 AM - 5:00 AM';
                const activateBtn = document.getElementById('activateScheduledBtn');
                if (activateBtn) {
                    activateBtn.disabled = !canActivate;
                    activateBtn.title = canActivate ? '' : 'Activation disabled after 5:00 AM local time';
                }
            }

            function aviatBindControls() {
                const addBtn = document.getElementById('aviatAddBtn');
                const replaceBtn = document.getElementById('aviatReplaceBtn');
                const clearDoneBtn = document.getElementById('aviatClearDoneBtn');
                const clearAllBtn = document.getElementById('aviatClearAllBtn');
                const refreshBtn = document.getElementById('aviatRefreshBtn');
                const checkStatusBtn = document.getElementById('aviatCheckStatusBtn');
                const activateBtn = document.getElementById('activateScheduledBtn');
                const abortBtn = document.getElementById('abortBtn');
                const runBtn = document.getElementById('runBtn');
                const logRefreshBtn = document.getElementById('aviatLogRefreshBtn');
                const logStatusBtn = document.getElementById('aviatLogStatusBtn');
                const reloadBtn = document.getElementById('aviatReloadUiBtn');
                const clearLogBtn = document.getElementById('aviatClearLogBtn');
                const ipInput = document.getElementById('ipInput');

                if (addBtn) addBtn.addEventListener('click', aviatAddRadios);
                if (replaceBtn) replaceBtn.addEventListener('click', aviatReplaceRadios);
                if (clearDoneBtn) clearDoneBtn.addEventListener('click', aviatClearCompleted);
                if (clearAllBtn) clearAllBtn.addEventListener('click', aviatClearAll);
                if (refreshBtn) refreshBtn.addEventListener('click', aviatRefreshStatus);
                if (checkStatusBtn) checkStatusBtn.addEventListener('click', aviatCheckStatus);
                if (activateBtn) activateBtn.addEventListener('click', aviatActivateScheduled);
                if (abortBtn) abortBtn.addEventListener('click', aviatAbortRun);
                if (runBtn) runBtn.addEventListener('click', aviatRunAll);
                if (logRefreshBtn) logRefreshBtn.addEventListener('click', aviatRefreshStatus);
                if (logStatusBtn) logStatusBtn.addEventListener('click', aviatCheckStatus);
                if (reloadBtn) reloadBtn.addEventListener('click', () => window.location.reload());
                if (clearLogBtn) clearLogBtn.addEventListener('click', aviatClearLog);

                if (ipInput) {
                    ipInput.addEventListener('keydown', (e) => {
                        if (e.key === 'Enter' && !e.shiftKey) {
                            e.preventDefault();
                            aviatAddRadios();
                        }
                    });
                }

                const activationModeSelect = document.getElementById('activationMode');
                const activationTimeInput = document.getElementById('activationTime');
                if (activationModeSelect && activationTimeInput) {
                    activationTimeInput.disabled = activationModeSelect.value !== 'scheduled';
                    activationModeSelect.addEventListener('change', () => {
                        activationTimeInput.disabled = activationModeSelect.value !== 'scheduled';
                    });
                }
            }

            document.addEventListener('DOMContentLoaded', () => {
                aviatLoadSharedQueue().then(loaded => {
                    if (!loaded) {
                        aviatRestoreRadios();
                        aviatUpdateUI();
                    }
                    aviatRefreshStatus();
                });
                aviatBindControls();
                aviatUpdateMaintenanceBanner();
                setInterval(aviatUpdateMaintenanceBanner, 60000);
                setInterval(() => aviatRefreshStatus({ quiet: true }), 30000);
                aviatStartAutoStatusChecks();
                aviatStartGlobalLogStream();
                aviatAddLog('Tool initialized', 'info');
            });
        })();
    </script>
</body>

</html>





